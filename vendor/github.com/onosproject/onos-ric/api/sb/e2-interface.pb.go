// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/sb/e2-interface.proto

package sb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Definition of all message types in E2 interface
type MessageType int32

const (
	MessageType_UNKNOWN_MESSAGE            MessageType = 0
	MessageType_CELL_CONFIG_REQUEST        MessageType = 1
	MessageType_CELL_CONFIG_REPORT         MessageType = 2
	MessageType_UE_ADMISSION_REQUEST       MessageType = 3
	MessageType_UE_ADMISSION_RESPONSE      MessageType = 4
	MessageType_UE_ADMISSION_STATUS        MessageType = 5
	MessageType_UE_CONTEXT_UPDATE          MessageType = 6
	MessageType_UE_RECONFIG_IND            MessageType = 7
	MessageType_UE_RELEASE_IND             MessageType = 8
	MessageType_BEARER_ADMISSION_REQUEST   MessageType = 9
	MessageType_BEARER_ADMISSION_RESPONSE  MessageType = 10
	MessageType_BEARER_ADMISSION_STATUS    MessageType = 11
	MessageType_BEARER_RELEASE_IND         MessageType = 12
	MessageType_HO_REQUEST                 MessageType = 13
	MessageType_HO_FAILURE                 MessageType = 14
	MessageType_HO_COMPLETE                MessageType = 15
	MessageType_RXSIG_MEAS_REPORT          MessageType = 16
	MessageType_L2_MEAS_CONFIG             MessageType = 17
	MessageType_RADIO_MEAS_REPORT_PER_UE   MessageType = 18
	MessageType_RADIO_MEAS_REPORT_PER_CELL MessageType = 19
	MessageType_SCHED_MEAS_REPORT_PER_UE   MessageType = 20
	MessageType_SCHED_MEAS_REPORT_PER_CELL MessageType = 21
	MessageType_PDCP_MEAS_REPORT_PER_UE    MessageType = 22
	MessageType_UE_CAPABILITY_INFO         MessageType = 23
	MessageType_UE_CAPABILITY_ENQUIRY      MessageType = 24
	MessageType_SCELL_ADD                  MessageType = 25
	MessageType_SCELL_ADD_STATUS           MessageType = 26
	MessageType_SCELL_DELETE               MessageType = 27
	MessageType_RRM_CONFIG                 MessageType = 28
	MessageType_RRM_CONFIG_STATUS          MessageType = 29
	MessageType_SENB_ADD                   MessageType = 30
	MessageType_SENB_ADD_STATUS            MessageType = 31
	MessageType_SENB_DELETE                MessageType = 32
	MessageType_TRAFFIC_SPLIT_CONFIG       MessageType = 33
	MessageType_HO_CAUSE                   MessageType = 34
	MessageType_RRC_MEAS_CONFIG            MessageType = 35
)

var MessageType_name = map[int32]string{
	0:  "UNKNOWN_MESSAGE",
	1:  "CELL_CONFIG_REQUEST",
	2:  "CELL_CONFIG_REPORT",
	3:  "UE_ADMISSION_REQUEST",
	4:  "UE_ADMISSION_RESPONSE",
	5:  "UE_ADMISSION_STATUS",
	6:  "UE_CONTEXT_UPDATE",
	7:  "UE_RECONFIG_IND",
	8:  "UE_RELEASE_IND",
	9:  "BEARER_ADMISSION_REQUEST",
	10: "BEARER_ADMISSION_RESPONSE",
	11: "BEARER_ADMISSION_STATUS",
	12: "BEARER_RELEASE_IND",
	13: "HO_REQUEST",
	14: "HO_FAILURE",
	15: "HO_COMPLETE",
	16: "RXSIG_MEAS_REPORT",
	17: "L2_MEAS_CONFIG",
	18: "RADIO_MEAS_REPORT_PER_UE",
	19: "RADIO_MEAS_REPORT_PER_CELL",
	20: "SCHED_MEAS_REPORT_PER_UE",
	21: "SCHED_MEAS_REPORT_PER_CELL",
	22: "PDCP_MEAS_REPORT_PER_UE",
	23: "UE_CAPABILITY_INFO",
	24: "UE_CAPABILITY_ENQUIRY",
	25: "SCELL_ADD",
	26: "SCELL_ADD_STATUS",
	27: "SCELL_DELETE",
	28: "RRM_CONFIG",
	29: "RRM_CONFIG_STATUS",
	30: "SENB_ADD",
	31: "SENB_ADD_STATUS",
	32: "SENB_DELETE",
	33: "TRAFFIC_SPLIT_CONFIG",
	34: "HO_CAUSE",
	35: "RRC_MEAS_CONFIG",
}

var MessageType_value = map[string]int32{
	"UNKNOWN_MESSAGE":            0,
	"CELL_CONFIG_REQUEST":        1,
	"CELL_CONFIG_REPORT":         2,
	"UE_ADMISSION_REQUEST":       3,
	"UE_ADMISSION_RESPONSE":      4,
	"UE_ADMISSION_STATUS":        5,
	"UE_CONTEXT_UPDATE":          6,
	"UE_RECONFIG_IND":            7,
	"UE_RELEASE_IND":             8,
	"BEARER_ADMISSION_REQUEST":   9,
	"BEARER_ADMISSION_RESPONSE":  10,
	"BEARER_ADMISSION_STATUS":    11,
	"BEARER_RELEASE_IND":         12,
	"HO_REQUEST":                 13,
	"HO_FAILURE":                 14,
	"HO_COMPLETE":                15,
	"RXSIG_MEAS_REPORT":          16,
	"L2_MEAS_CONFIG":             17,
	"RADIO_MEAS_REPORT_PER_UE":   18,
	"RADIO_MEAS_REPORT_PER_CELL": 19,
	"SCHED_MEAS_REPORT_PER_UE":   20,
	"SCHED_MEAS_REPORT_PER_CELL": 21,
	"PDCP_MEAS_REPORT_PER_UE":    22,
	"UE_CAPABILITY_INFO":         23,
	"UE_CAPABILITY_ENQUIRY":      24,
	"SCELL_ADD":                  25,
	"SCELL_ADD_STATUS":           26,
	"SCELL_DELETE":               27,
	"RRM_CONFIG":                 28,
	"RRM_CONFIG_STATUS":          29,
	"SENB_ADD":                   30,
	"SENB_ADD_STATUS":            31,
	"SENB_DELETE":                32,
	"TRAFFIC_SPLIT_CONFIG":       33,
	"HO_CAUSE":                   34,
	"RRC_MEAS_CONFIG":            35,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{0}
}

type AdmEstCause int32

const (
	AdmEstCause_EMERGENCY     AdmEstCause = 0
	AdmEstCause_HIGHHP_ACCESS AdmEstCause = 1
	AdmEstCause_MT_ACCESS     AdmEstCause = 2
	AdmEstCause_MO_SIGNALLING AdmEstCause = 3
	AdmEstCause_MO_DATA       AdmEstCause = 4
)

var AdmEstCause_name = map[int32]string{
	0: "EMERGENCY",
	1: "HIGHHP_ACCESS",
	2: "MT_ACCESS",
	3: "MO_SIGNALLING",
	4: "MO_DATA",
}

var AdmEstCause_value = map[string]int32{
	"EMERGENCY":     0,
	"HIGHHP_ACCESS": 1,
	"MT_ACCESS":     2,
	"MO_SIGNALLING": 3,
	"MO_DATA":       4,
}

func (x AdmEstCause) String() string {
	return proto.EnumName(AdmEstCause_name, int32(x))
}

func (AdmEstCause) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{1}
}

type SuccessOrFailure int32

const (
	SuccessOrFailure_SUCCESS SuccessOrFailure = 0
	SuccessOrFailure_FAILURE SuccessOrFailure = 1
)

var SuccessOrFailure_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILURE",
}

var SuccessOrFailure_value = map[string]int32{
	"SUCCESS": 0,
	"FAILURE": 1,
}

func (x SuccessOrFailure) String() string {
	return proto.EnumName(SuccessOrFailure_name, int32(x))
}

func (SuccessOrFailure) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{2}
}

type ReconfigCause int32

const (
	ReconfigCause_RECONFIG_RLF     ReconfigCause = 0
	ReconfigCause_RECONFIG_HO_FAIL ReconfigCause = 1
	ReconfigCause_RECONFIG_OTHERS  ReconfigCause = 2
)

var ReconfigCause_name = map[int32]string{
	0: "RECONFIG_RLF",
	1: "RECONFIG_HO_FAIL",
	2: "RECONFIG_OTHERS",
}

var ReconfigCause_value = map[string]int32{
	"RECONFIG_RLF":     0,
	"RECONFIG_HO_FAIL": 1,
	"RECONFIG_OTHERS":  2,
}

func (x ReconfigCause) String() string {
	return proto.EnumName(ReconfigCause_name, int32(x))
}

func (ReconfigCause) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{3}
}

type ReleaseCause int32

const (
	ReleaseCause_RELEASE_INACTIVITY ReleaseCause = 0
	ReleaseCause_RELEASE_RLF        ReleaseCause = 1
	ReleaseCause_RELEASE_OTHERS     ReleaseCause = 2
)

var ReleaseCause_name = map[int32]string{
	0: "RELEASE_INACTIVITY",
	1: "RELEASE_RLF",
	2: "RELEASE_OTHERS",
}

var ReleaseCause_value = map[string]int32{
	"RELEASE_INACTIVITY": 0,
	"RELEASE_RLF":        1,
	"RELEASE_OTHERS":     2,
}

func (x ReleaseCause) String() string {
	return proto.EnumName(ReleaseCause_name, int32(x))
}

func (ReleaseCause) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{4}
}

type ERABDirection int32

const (
	ERABDirection_DL   ERABDirection = 0
	ERABDirection_UL   ERABDirection = 1
	ERABDirection_BOTH ERABDirection = 2
)

var ERABDirection_name = map[int32]string{
	0: "DL",
	1: "UL",
	2: "BOTH",
}

var ERABDirection_value = map[string]int32{
	"DL":   0,
	"UL":   1,
	"BOTH": 2,
}

func (x ERABDirection) String() string {
	return proto.EnumName(ERABDirection_name, int32(x))
}

func (ERABDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{5}
}

type ERABType int32

const (
	ERABType_ERAB_DEFAULT   ERABType = 0
	ERABType_ERAB_DEDICATED ERABType = 1
)

var ERABType_name = map[int32]string{
	0: "ERAB_DEFAULT",
	1: "ERAB_DEDICATED",
}

var ERABType_value = map[string]int32{
	"ERAB_DEFAULT":   0,
	"ERAB_DEDICATED": 1,
}

func (x ERABType) String() string {
	return proto.EnumName(ERABType_name, int32(x))
}

func (ERABType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{6}
}

type ReportParamPR int32

const (
	ReportParamPR_REPORT_PARAM_PR_NOTHING   ReportParamPR = 0
	ReportParamPR_REPORT_PARAM_PR_PER_PARAM ReportParamPR = 1
	ReportParamPR_REPORT_PARAM_PR_A1PARAM   ReportParamPR = 2
	ReportParamPR_REPORT_PARAM_PR_A2PARAM   ReportParamPR = 3
	ReportParamPR_REPORT_PARAM_PR_A3PARAM   ReportParamPR = 4
	ReportParamPR_REPORT_PARAM_PR_A4PARAM   ReportParamPR = 5
	ReportParamPR_REPORT_PARAM_PR_A5PARAM   ReportParamPR = 6
	ReportParamPR_REPORT_PARAM_PR_A6PARAM   ReportParamPR = 7
)

var ReportParamPR_name = map[int32]string{
	0: "REPORT_PARAM_PR_NOTHING",
	1: "REPORT_PARAM_PR_PER_PARAM",
	2: "REPORT_PARAM_PR_A1PARAM",
	3: "REPORT_PARAM_PR_A2PARAM",
	4: "REPORT_PARAM_PR_A3PARAM",
	5: "REPORT_PARAM_PR_A4PARAM",
	6: "REPORT_PARAM_PR_A5PARAM",
	7: "REPORT_PARAM_PR_A6PARAM",
}

var ReportParamPR_value = map[string]int32{
	"REPORT_PARAM_PR_NOTHING":   0,
	"REPORT_PARAM_PR_PER_PARAM": 1,
	"REPORT_PARAM_PR_A1PARAM":   2,
	"REPORT_PARAM_PR_A2PARAM":   3,
	"REPORT_PARAM_PR_A3PARAM":   4,
	"REPORT_PARAM_PR_A4PARAM":   5,
	"REPORT_PARAM_PR_A5PARAM":   6,
	"REPORT_PARAM_PR_A6PARAM":   7,
}

func (x ReportParamPR) String() string {
	return proto.EnumName(ReportParamPR_name, int32(x))
}

func (ReportParamPR) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{7}
}

type PerParamReportIntervalMs int32

const (
	PerParamReportIntervalMs_PER_PARAM_MS_120   PerParamReportIntervalMs = 0
	PerParamReportIntervalMs_PER_PARAM_MS_240   PerParamReportIntervalMs = 1
	PerParamReportIntervalMs_PER_PARAM_MS_480   PerParamReportIntervalMs = 2
	PerParamReportIntervalMs_PER_PARAM_MS_640   PerParamReportIntervalMs = 3
	PerParamReportIntervalMs_PER_PARAM_MS_1024  PerParamReportIntervalMs = 4
	PerParamReportIntervalMs_PER_PARAM_MS_2048  PerParamReportIntervalMs = 5
	PerParamReportIntervalMs_PER_PARAM_MS_5120  PerParamReportIntervalMs = 6
	PerParamReportIntervalMs_PER_PARAM_MS_10240 PerParamReportIntervalMs = 7
	PerParamReportIntervalMs_PER_PARAM_MIN_1    PerParamReportIntervalMs = 8
	PerParamReportIntervalMs_PER_PARAM_MIN_6    PerParamReportIntervalMs = 9
	PerParamReportIntervalMs_PER_PARAM_MIN_12   PerParamReportIntervalMs = 10
	PerParamReportIntervalMs_PER_PARAM_MIN_30   PerParamReportIntervalMs = 11
	PerParamReportIntervalMs_PER_PARAM_MIN_60   PerParamReportIntervalMs = 12
)

var PerParamReportIntervalMs_name = map[int32]string{
	0:  "PER_PARAM_MS_120",
	1:  "PER_PARAM_MS_240",
	2:  "PER_PARAM_MS_480",
	3:  "PER_PARAM_MS_640",
	4:  "PER_PARAM_MS_1024",
	5:  "PER_PARAM_MS_2048",
	6:  "PER_PARAM_MS_5120",
	7:  "PER_PARAM_MS_10240",
	8:  "PER_PARAM_MIN_1",
	9:  "PER_PARAM_MIN_6",
	10: "PER_PARAM_MIN_12",
	11: "PER_PARAM_MIN_30",
	12: "PER_PARAM_MIN_60",
}

var PerParamReportIntervalMs_value = map[string]int32{
	"PER_PARAM_MS_120":   0,
	"PER_PARAM_MS_240":   1,
	"PER_PARAM_MS_480":   2,
	"PER_PARAM_MS_640":   3,
	"PER_PARAM_MS_1024":  4,
	"PER_PARAM_MS_2048":  5,
	"PER_PARAM_MS_5120":  6,
	"PER_PARAM_MS_10240": 7,
	"PER_PARAM_MIN_1":    8,
	"PER_PARAM_MIN_6":    9,
	"PER_PARAM_MIN_12":   10,
	"PER_PARAM_MIN_30":   11,
	"PER_PARAM_MIN_60":   12,
}

func (x PerParamReportIntervalMs) String() string {
	return proto.EnumName(PerParamReportIntervalMs_name, int32(x))
}

func (PerParamReportIntervalMs) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{8}
}

type ThresholdEUTRAPR int32

const (
	ThresholdEUTRAPR_THRESHOLD_EUTRA_PR_NOTHING ThresholdEUTRAPR = 0
	ThresholdEUTRAPR_THRESHOLD_EUTRA_PR_RSRP    ThresholdEUTRAPR = 1
	ThresholdEUTRAPR_THRESHOLD_EUTRA_PR_RSRQ    ThresholdEUTRAPR = 2
)

var ThresholdEUTRAPR_name = map[int32]string{
	0: "THRESHOLD_EUTRA_PR_NOTHING",
	1: "THRESHOLD_EUTRA_PR_RSRP",
	2: "THRESHOLD_EUTRA_PR_RSRQ",
}

var ThresholdEUTRAPR_value = map[string]int32{
	"THRESHOLD_EUTRA_PR_NOTHING": 0,
	"THRESHOLD_EUTRA_PR_RSRP":    1,
	"THRESHOLD_EUTRA_PR_RSRQ":    2,
}

func (x ThresholdEUTRAPR) String() string {
	return proto.EnumName(ThresholdEUTRAPR_name, int32(x))
}

func (ThresholdEUTRAPR) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{9}
}

type TimeToTrigger int32

const (
	TimeToTrigger_TTT_MS0    TimeToTrigger = 0
	TimeToTrigger_TTT_MS40   TimeToTrigger = 1
	TimeToTrigger_TTT_MS64   TimeToTrigger = 2
	TimeToTrigger_TTT_MS80   TimeToTrigger = 3
	TimeToTrigger_TTT_MS100  TimeToTrigger = 4
	TimeToTrigger_TTT_MS128  TimeToTrigger = 5
	TimeToTrigger_TTT_MS160  TimeToTrigger = 6
	TimeToTrigger_TTT_MS256  TimeToTrigger = 7
	TimeToTrigger_TTT_MS320  TimeToTrigger = 8
	TimeToTrigger_TTT_MS480  TimeToTrigger = 9
	TimeToTrigger_TTT_MS512  TimeToTrigger = 10
	TimeToTrigger_TTT_MS640  TimeToTrigger = 11
	TimeToTrigger_TTT_MS1024 TimeToTrigger = 12
	TimeToTrigger_TTT_MS1280 TimeToTrigger = 13
	TimeToTrigger_TTT_MS2560 TimeToTrigger = 14
	TimeToTrigger_TTT_MS5120 TimeToTrigger = 15
)

var TimeToTrigger_name = map[int32]string{
	0:  "TTT_MS0",
	1:  "TTT_MS40",
	2:  "TTT_MS64",
	3:  "TTT_MS80",
	4:  "TTT_MS100",
	5:  "TTT_MS128",
	6:  "TTT_MS160",
	7:  "TTT_MS256",
	8:  "TTT_MS320",
	9:  "TTT_MS480",
	10: "TTT_MS512",
	11: "TTT_MS640",
	12: "TTT_MS1024",
	13: "TTT_MS1280",
	14: "TTT_MS2560",
	15: "TTT_MS5120",
}

var TimeToTrigger_value = map[string]int32{
	"TTT_MS0":    0,
	"TTT_MS40":   1,
	"TTT_MS64":   2,
	"TTT_MS80":   3,
	"TTT_MS100":  4,
	"TTT_MS128":  5,
	"TTT_MS160":  6,
	"TTT_MS256":  7,
	"TTT_MS320":  8,
	"TTT_MS480":  9,
	"TTT_MS512":  10,
	"TTT_MS640":  11,
	"TTT_MS1024": 12,
	"TTT_MS1280": 13,
	"TTT_MS2560": 14,
	"TTT_MS5120": 15,
}

func (x TimeToTrigger) String() string {
	return proto.EnumName(TimeToTrigger_name, int32(x))
}

func (TimeToTrigger) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{10}
}

type TriggerQuantity int32

const (
	TriggerQuantity_TQ_RSRP TriggerQuantity = 0
	TriggerQuantity_TQ_RSRQ TriggerQuantity = 1
)

var TriggerQuantity_name = map[int32]string{
	0: "TQ_RSRP",
	1: "TQ_RSRQ",
}

var TriggerQuantity_value = map[string]int32{
	"TQ_RSRP": 0,
	"TQ_RSRQ": 1,
}

func (x TriggerQuantity) String() string {
	return proto.EnumName(TriggerQuantity_name, int32(x))
}

func (TriggerQuantity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{11}
}

type ReportQuality int32

const (
	ReportQuality_RQ_SAME ReportQuality = 0
	ReportQuality_RQ_BOTH ReportQuality = 1
)

var ReportQuality_name = map[int32]string{
	0: "RQ_SAME",
	1: "RQ_BOTH",
}

var ReportQuality_value = map[string]int32{
	"RQ_SAME": 0,
	"RQ_BOTH": 1,
}

func (x ReportQuality) String() string {
	return proto.EnumName(ReportQuality_name, int32(x))
}

func (ReportQuality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{12}
}

type MeasIdActionPR int32

const (
	MeasIdActionPR_MEAS_ID_ACTION_PR_NOTHING    MeasIdActionPR = 0
	MeasIdActionPR_MEAS_ID_ACTION_PR_ADDMEASID  MeasIdActionPR = 1
	MeasIdActionPR_MEAS_ID_ACTION_PR_DELMEASID  MeasIdActionPR = 2
	MeasIdActionPR_MEAS_ID_ACTION_PR_HOTOTARGET MeasIdActionPR = 3
)

var MeasIdActionPR_name = map[int32]string{
	0: "MEAS_ID_ACTION_PR_NOTHING",
	1: "MEAS_ID_ACTION_PR_ADDMEASID",
	2: "MEAS_ID_ACTION_PR_DELMEASID",
	3: "MEAS_ID_ACTION_PR_HOTOTARGET",
}

var MeasIdActionPR_value = map[string]int32{
	"MEAS_ID_ACTION_PR_NOTHING":    0,
	"MEAS_ID_ACTION_PR_ADDMEASID":  1,
	"MEAS_ID_ACTION_PR_DELMEASID":  2,
	"MEAS_ID_ACTION_PR_HOTOTARGET": 3,
}

func (x MeasIdActionPR) String() string {
	return proto.EnumName(MeasIdActionPR_name, int32(x))
}

func (MeasIdActionPR) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{13}
}

type L2MeasReportInterval int32

const (
	L2MeasReportInterval_NO_REPORT L2MeasReportInterval = 0
	L2MeasReportInterval_MS_10     L2MeasReportInterval = 1
	L2MeasReportInterval_MS_50     L2MeasReportInterval = 2
	L2MeasReportInterval_MS_100    L2MeasReportInterval = 3
	L2MeasReportInterval_MS_200    L2MeasReportInterval = 4
	L2MeasReportInterval_MS_500    L2MeasReportInterval = 5
	L2MeasReportInterval_MS_1024   L2MeasReportInterval = 6
	L2MeasReportInterval_S_10      L2MeasReportInterval = 7
	L2MeasReportInterval_MIN_1     L2MeasReportInterval = 8
	L2MeasReportInterval_MIN_2     L2MeasReportInterval = 9
	L2MeasReportInterval_MIN_5     L2MeasReportInterval = 10
)

var L2MeasReportInterval_name = map[int32]string{
	0:  "NO_REPORT",
	1:  "MS_10",
	2:  "MS_50",
	3:  "MS_100",
	4:  "MS_200",
	5:  "MS_500",
	6:  "MS_1024",
	7:  "S_10",
	8:  "MIN_1",
	9:  "MIN_2",
	10: "MIN_5",
}

var L2MeasReportInterval_value = map[string]int32{
	"NO_REPORT": 0,
	"MS_10":     1,
	"MS_50":     2,
	"MS_100":    3,
	"MS_200":    4,
	"MS_500":    5,
	"MS_1024":   6,
	"S_10":      7,
	"MIN_1":     8,
	"MIN_2":     9,
	"MIN_5":     10,
}

func (x L2MeasReportInterval) String() string {
	return proto.EnumName(L2MeasReportInterval_name, int32(x))
}

func (L2MeasReportInterval) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{14}
}

type XICICPA int32

const (
	XICICPA_XICIC_PA_DB_MINUS6      XICICPA = 0
	XICICPA_XICIC_PA_DB_MINUX4DOT77 XICICPA = 1
	XICICPA_XICIC_PA_DB_MINUS3      XICICPA = 2
	XICICPA_XICIC_PA_DB_MINUS1DOT77 XICICPA = 3
	XICICPA_XICIC_PA_DB_0           XICICPA = 4
	XICICPA_XICIC_PA_DB_1           XICICPA = 5
	XICICPA_XICIC_PA_DB_2           XICICPA = 6
	XICICPA_XICIC_PA_DB_3           XICICPA = 7
)

var XICICPA_name = map[int32]string{
	0: "XICIC_PA_DB_MINUS6",
	1: "XICIC_PA_DB_MINUX4DOT77",
	2: "XICIC_PA_DB_MINUS3",
	3: "XICIC_PA_DB_MINUS1DOT77",
	4: "XICIC_PA_DB_0",
	5: "XICIC_PA_DB_1",
	6: "XICIC_PA_DB_2",
	7: "XICIC_PA_DB_3",
}

var XICICPA_value = map[string]int32{
	"XICIC_PA_DB_MINUS6":      0,
	"XICIC_PA_DB_MINUX4DOT77": 1,
	"XICIC_PA_DB_MINUS3":      2,
	"XICIC_PA_DB_MINUS1DOT77": 3,
	"XICIC_PA_DB_0":           4,
	"XICIC_PA_DB_1":           5,
	"XICIC_PA_DB_2":           6,
	"XICIC_PA_DB_3":           7,
}

func (x XICICPA) String() string {
	return proto.EnumName(XICICPA_name, int32(x))
}

func (XICICPA) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{15}
}

type CACapClassDl int32

const (
	CACapClassDl_CACAP_CLASSDL_A CACapClassDl = 0
	CACapClassDl_CACAP_CLASSDL_B CACapClassDl = 1
	CACapClassDl_CACAP_CLASSDL_C CACapClassDl = 2
	CACapClassDl_CACAP_CLASSDL_D CACapClassDl = 3
	CACapClassDl_CACAP_CLASSDL_E CACapClassDl = 4
	CACapClassDl_CACAP_CLASSDL_F CACapClassDl = 5
)

var CACapClassDl_name = map[int32]string{
	0: "CACAP_CLASSDL_A",
	1: "CACAP_CLASSDL_B",
	2: "CACAP_CLASSDL_C",
	3: "CACAP_CLASSDL_D",
	4: "CACAP_CLASSDL_E",
	5: "CACAP_CLASSDL_F",
}

var CACapClassDl_value = map[string]int32{
	"CACAP_CLASSDL_A": 0,
	"CACAP_CLASSDL_B": 1,
	"CACAP_CLASSDL_C": 2,
	"CACAP_CLASSDL_D": 3,
	"CACAP_CLASSDL_E": 4,
	"CACAP_CLASSDL_F": 5,
}

func (x CACapClassDl) String() string {
	return proto.EnumName(CACapClassDl_name, int32(x))
}

func (CACapClassDl) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{16}
}

type CACapClassUl int32

const (
	CACapClassUl_CACAP_CLASSUL_A CACapClassUl = 0
	CACapClassUl_CACAP_CLASSUL_B CACapClassUl = 1
	CACapClassUl_CACAP_CLASSUL_C CACapClassUl = 2
	CACapClassUl_CACAP_CLASSUL_D CACapClassUl = 3
	CACapClassUl_CACAP_CLASSUL_E CACapClassUl = 4
	CACapClassUl_CACAP_CLASSUL_F CACapClassUl = 5
)

var CACapClassUl_name = map[int32]string{
	0: "CACAP_CLASSUL_A",
	1: "CACAP_CLASSUL_B",
	2: "CACAP_CLASSUL_C",
	3: "CACAP_CLASSUL_D",
	4: "CACAP_CLASSUL_E",
	5: "CACAP_CLASSUL_F",
}

var CACapClassUl_value = map[string]int32{
	"CACAP_CLASSUL_A": 0,
	"CACAP_CLASSUL_B": 1,
	"CACAP_CLASSUL_C": 2,
	"CACAP_CLASSUL_D": 3,
	"CACAP_CLASSUL_E": 4,
	"CACAP_CLASSUL_F": 5,
}

func (x CACapClassUl) String() string {
	return proto.EnumName(CACapClassUl_name, int32(x))
}

func (CACapClassUl) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{17}
}

type DCCapDrbType int32

const (
	DCCapDrbType_DCCAP_DRBTYPE_SUPPORTED DCCapDrbType = 0
)

var DCCapDrbType_name = map[int32]string{
	0: "DCCAP_DRBTYPE_SUPPORTED",
}

var DCCapDrbType_value = map[string]int32{
	"DCCAP_DRBTYPE_SUPPORTED": 0,
}

func (x DCCapDrbType) String() string {
	return proto.EnumName(DCCapDrbType_name, int32(x))
}

func (DCCapDrbType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{18}
}

type CADirection int32

const (
	CADirection_CADIRECTION_DL   CADirection = 0
	CADirection_CADIRECTION_UL   CADirection = 1
	CADirection_CADIRECTION_BOTH CADirection = 2
)

var CADirection_name = map[int32]string{
	0: "CADIRECTION_DL",
	1: "CADIRECTION_UL",
	2: "CADIRECTION_BOTH",
}

var CADirection_value = map[string]int32{
	"CADIRECTION_DL":   0,
	"CADIRECTION_UL":   1,
	"CADIRECTION_BOTH": 2,
}

func (x CADirection) String() string {
	return proto.EnumName(CADirection_name, int32(x))
}

func (CADirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{19}
}

type ECGI struct {
	PlmnId string `protobuf:"bytes,1,opt,name=plmnId,proto3" json:"plmnId,omitempty"`
	Ecid   string `protobuf:"bytes,2,opt,name=ecid,proto3" json:"ecid,omitempty"`
}

func (m *ECGI) Reset()         { *m = ECGI{} }
func (m *ECGI) String() string { return proto.CompactTextString(m) }
func (*ECGI) ProtoMessage()    {}
func (*ECGI) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{0}
}
func (m *ECGI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ECGI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ECGI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ECGI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ECGI.Merge(m, src)
}
func (m *ECGI) XXX_Size() int {
	return m.Size()
}
func (m *ECGI) XXX_DiscardUnknown() {
	xxx_messageInfo_ECGI.DiscardUnknown(m)
}

var xxx_messageInfo_ECGI proto.InternalMessageInfo

func (m *ECGI) GetPlmnId() string {
	if m != nil {
		return m.PlmnId
	}
	return ""
}

func (m *ECGI) GetEcid() string {
	if m != nil {
		return m.Ecid
	}
	return ""
}

type CandScell struct {
	Pci      uint32 `protobuf:"varint,1,opt,name=pci,proto3" json:"pci,omitempty"`
	EarfcnDl string `protobuf:"bytes,2,opt,name=earfcnDl,proto3" json:"earfcnDl,omitempty"`
	Ecgi     *ECGI  `protobuf:"bytes,3,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
}

func (m *CandScell) Reset()         { *m = CandScell{} }
func (m *CandScell) String() string { return proto.CompactTextString(m) }
func (*CandScell) ProtoMessage()    {}
func (*CandScell) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{1}
}
func (m *CandScell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CandScell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CandScell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CandScell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CandScell.Merge(m, src)
}
func (m *CandScell) XXX_Size() int {
	return m.Size()
}
func (m *CandScell) XXX_DiscardUnknown() {
	xxx_messageInfo_CandScell.DiscardUnknown(m)
}

var xxx_messageInfo_CandScell proto.InternalMessageInfo

func (m *CandScell) GetPci() uint32 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *CandScell) GetEarfcnDl() string {
	if m != nil {
		return m.EarfcnDl
	}
	return ""
}

func (m *CandScell) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

// CellConfigRequest message
type CellConfigRequest struct {
	Ecgi *ECGI `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
}

func (m *CellConfigRequest) Reset()         { *m = CellConfigRequest{} }
func (m *CellConfigRequest) String() string { return proto.CompactTextString(m) }
func (*CellConfigRequest) ProtoMessage()    {}
func (*CellConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{2}
}
func (m *CellConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CellConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CellConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CellConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CellConfigRequest.Merge(m, src)
}
func (m *CellConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *CellConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CellConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CellConfigRequest proto.InternalMessageInfo

func (m *CellConfigRequest) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

// CellConfigReport message
type CellConfigReport struct {
	Ecgi                   *ECGI        `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Pci                    uint32       `protobuf:"varint,2,opt,name=pci,proto3" json:"pci,omitempty"`
	CandScells             []*CandScell `protobuf:"bytes,3,rep,name=candScells,proto3" json:"candScells,omitempty"`
	EarfcnDl               string       `protobuf:"bytes,4,opt,name=earfcnDl,proto3" json:"earfcnDl,omitempty"`
	EarfcnUl               string       `protobuf:"bytes,5,opt,name=earfcnUl,proto3" json:"earfcnUl,omitempty"`
	RbsPerTtiDl            uint32       `protobuf:"varint,6,opt,name=rbsPerTtiDl,proto3" json:"rbsPerTtiDl,omitempty"`
	RbsPerTtiUl            uint32       `protobuf:"varint,7,opt,name=rbsPerTtiUl,proto3" json:"rbsPerTtiUl,omitempty"`
	NumTxAntenna           uint32       `protobuf:"varint,8,opt,name=numTxAntenna,proto3" json:"numTxAntenna,omitempty"`
	DuplexMode             string       `protobuf:"bytes,9,opt,name=duplexMode,proto3" json:"duplexMode,omitempty"`
	MaxNumConnectedUes     uint32       `protobuf:"varint,10,opt,name=maxNumConnectedUes,proto3" json:"maxNumConnectedUes,omitempty"`
	MaxNumConnectedBearers uint32       `protobuf:"varint,11,opt,name=maxNumConnectedBearers,proto3" json:"maxNumConnectedBearers,omitempty"`
	MaxNumUesSchedPerTtiDl uint32       `protobuf:"varint,12,opt,name=maxNumUesSchedPerTtiDl,proto3" json:"maxNumUesSchedPerTtiDl,omitempty"`
	MaxNumUesSchedPerTtiUl uint32       `protobuf:"varint,13,opt,name=maxNumUesSchedPerTtiUl,proto3" json:"maxNumUesSchedPerTtiUl,omitempty"`
	DlfsSchedEnable        string       `protobuf:"bytes,14,opt,name=dlfsSchedEnable,proto3" json:"dlfsSchedEnable,omitempty"`
}

func (m *CellConfigReport) Reset()         { *m = CellConfigReport{} }
func (m *CellConfigReport) String() string { return proto.CompactTextString(m) }
func (*CellConfigReport) ProtoMessage()    {}
func (*CellConfigReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{3}
}
func (m *CellConfigReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CellConfigReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CellConfigReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CellConfigReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CellConfigReport.Merge(m, src)
}
func (m *CellConfigReport) XXX_Size() int {
	return m.Size()
}
func (m *CellConfigReport) XXX_DiscardUnknown() {
	xxx_messageInfo_CellConfigReport.DiscardUnknown(m)
}

var xxx_messageInfo_CellConfigReport proto.InternalMessageInfo

func (m *CellConfigReport) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *CellConfigReport) GetPci() uint32 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *CellConfigReport) GetCandScells() []*CandScell {
	if m != nil {
		return m.CandScells
	}
	return nil
}

func (m *CellConfigReport) GetEarfcnDl() string {
	if m != nil {
		return m.EarfcnDl
	}
	return ""
}

func (m *CellConfigReport) GetEarfcnUl() string {
	if m != nil {
		return m.EarfcnUl
	}
	return ""
}

func (m *CellConfigReport) GetRbsPerTtiDl() uint32 {
	if m != nil {
		return m.RbsPerTtiDl
	}
	return 0
}

func (m *CellConfigReport) GetRbsPerTtiUl() uint32 {
	if m != nil {
		return m.RbsPerTtiUl
	}
	return 0
}

func (m *CellConfigReport) GetNumTxAntenna() uint32 {
	if m != nil {
		return m.NumTxAntenna
	}
	return 0
}

func (m *CellConfigReport) GetDuplexMode() string {
	if m != nil {
		return m.DuplexMode
	}
	return ""
}

func (m *CellConfigReport) GetMaxNumConnectedUes() uint32 {
	if m != nil {
		return m.MaxNumConnectedUes
	}
	return 0
}

func (m *CellConfigReport) GetMaxNumConnectedBearers() uint32 {
	if m != nil {
		return m.MaxNumConnectedBearers
	}
	return 0
}

func (m *CellConfigReport) GetMaxNumUesSchedPerTtiDl() uint32 {
	if m != nil {
		return m.MaxNumUesSchedPerTtiDl
	}
	return 0
}

func (m *CellConfigReport) GetMaxNumUesSchedPerTtiUl() uint32 {
	if m != nil {
		return m.MaxNumUesSchedPerTtiUl
	}
	return 0
}

func (m *CellConfigReport) GetDlfsSchedEnable() string {
	if m != nil {
		return m.DlfsSchedEnable
	}
	return ""
}

// UEAdmissionRequest message
type UEAdmissionRequest struct {
	Crnti             string      `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi              *ECGI       `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	AdmissionEstCause AdmEstCause `protobuf:"varint,3,opt,name=admissionEstCause,proto3,enum=interface.e2.AdmEstCause" json:"admissionEstCause,omitempty"`
	Imsi              uint64      `protobuf:"varint,4,opt,name=imsi,proto3" json:"imsi,omitempty"`
}

func (m *UEAdmissionRequest) Reset()         { *m = UEAdmissionRequest{} }
func (m *UEAdmissionRequest) String() string { return proto.CompactTextString(m) }
func (*UEAdmissionRequest) ProtoMessage()    {}
func (*UEAdmissionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{4}
}
func (m *UEAdmissionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEAdmissionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEAdmissionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEAdmissionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEAdmissionRequest.Merge(m, src)
}
func (m *UEAdmissionRequest) XXX_Size() int {
	return m.Size()
}
func (m *UEAdmissionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UEAdmissionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UEAdmissionRequest proto.InternalMessageInfo

func (m *UEAdmissionRequest) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UEAdmissionRequest) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEAdmissionRequest) GetAdmissionEstCause() AdmEstCause {
	if m != nil {
		return m.AdmissionEstCause
	}
	return AdmEstCause_EMERGENCY
}

func (m *UEAdmissionRequest) GetImsi() uint64 {
	if m != nil {
		return m.Imsi
	}
	return 0
}

// UEAdmissionResponse message
type UEAdmissionResponse struct {
	Crnti                string           `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi                 *ECGI            `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	AdmissionEstResponse SuccessOrFailure `protobuf:"varint,3,opt,name=admissionEstResponse,proto3,enum=interface.e2.SuccessOrFailure" json:"admissionEstResponse,omitempty"`
}

func (m *UEAdmissionResponse) Reset()         { *m = UEAdmissionResponse{} }
func (m *UEAdmissionResponse) String() string { return proto.CompactTextString(m) }
func (*UEAdmissionResponse) ProtoMessage()    {}
func (*UEAdmissionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{5}
}
func (m *UEAdmissionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEAdmissionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEAdmissionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEAdmissionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEAdmissionResponse.Merge(m, src)
}
func (m *UEAdmissionResponse) XXX_Size() int {
	return m.Size()
}
func (m *UEAdmissionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UEAdmissionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UEAdmissionResponse proto.InternalMessageInfo

func (m *UEAdmissionResponse) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UEAdmissionResponse) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEAdmissionResponse) GetAdmissionEstResponse() SuccessOrFailure {
	if m != nil {
		return m.AdmissionEstResponse
	}
	return SuccessOrFailure_SUCCESS
}

// UEAdmissionStatus message
type UEAdmissionStatus struct {
	Crnti              string           `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi               *ECGI            `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	AdmissionEstStatus SuccessOrFailure `protobuf:"varint,3,opt,name=admissionEstStatus,proto3,enum=interface.e2.SuccessOrFailure" json:"admissionEstStatus,omitempty"`
}

func (m *UEAdmissionStatus) Reset()         { *m = UEAdmissionStatus{} }
func (m *UEAdmissionStatus) String() string { return proto.CompactTextString(m) }
func (*UEAdmissionStatus) ProtoMessage()    {}
func (*UEAdmissionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{6}
}
func (m *UEAdmissionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEAdmissionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEAdmissionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEAdmissionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEAdmissionStatus.Merge(m, src)
}
func (m *UEAdmissionStatus) XXX_Size() int {
	return m.Size()
}
func (m *UEAdmissionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UEAdmissionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UEAdmissionStatus proto.InternalMessageInfo

func (m *UEAdmissionStatus) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UEAdmissionStatus) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEAdmissionStatus) GetAdmissionEstStatus() SuccessOrFailure {
	if m != nil {
		return m.AdmissionEstStatus
	}
	return SuccessOrFailure_SUCCESS
}

// UEContextUpdate message
type UEContextUpdate struct {
	Crnti       string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi        *ECGI  `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	MmeUeS1ApId string `protobuf:"bytes,3,opt,name=mmeUeS1apId,proto3" json:"mmeUeS1apId,omitempty"`
	EnbUeS1ApId string `protobuf:"bytes,4,opt,name=enbUeS1apId,proto3" json:"enbUeS1apId,omitempty"`
	Imsi        string `protobuf:"bytes,5,opt,name=imsi,proto3" json:"imsi,omitempty"`
}

func (m *UEContextUpdate) Reset()         { *m = UEContextUpdate{} }
func (m *UEContextUpdate) String() string { return proto.CompactTextString(m) }
func (*UEContextUpdate) ProtoMessage()    {}
func (*UEContextUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{7}
}
func (m *UEContextUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEContextUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEContextUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEContextUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEContextUpdate.Merge(m, src)
}
func (m *UEContextUpdate) XXX_Size() int {
	return m.Size()
}
func (m *UEContextUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_UEContextUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_UEContextUpdate proto.InternalMessageInfo

func (m *UEContextUpdate) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UEContextUpdate) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEContextUpdate) GetMmeUeS1ApId() string {
	if m != nil {
		return m.MmeUeS1ApId
	}
	return ""
}

func (m *UEContextUpdate) GetEnbUeS1ApId() string {
	if m != nil {
		return m.EnbUeS1ApId
	}
	return ""
}

func (m *UEContextUpdate) GetImsi() string {
	if m != nil {
		return m.Imsi
	}
	return ""
}

// UEReconfigInd message
type UEReconfigInd struct {
	CrntiOld      string        `protobuf:"bytes,1,opt,name=crntiOld,proto3" json:"crntiOld,omitempty"`
	Ecgi          *ECGI         `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	CrntiNew      string        `protobuf:"bytes,3,opt,name=crntiNew,proto3" json:"crntiNew,omitempty"`
	ReconfigCause ReconfigCause `protobuf:"varint,4,opt,name=reconfigCause,proto3,enum=interface.e2.ReconfigCause" json:"reconfigCause,omitempty"`
}

func (m *UEReconfigInd) Reset()         { *m = UEReconfigInd{} }
func (m *UEReconfigInd) String() string { return proto.CompactTextString(m) }
func (*UEReconfigInd) ProtoMessage()    {}
func (*UEReconfigInd) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{8}
}
func (m *UEReconfigInd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEReconfigInd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEReconfigInd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEReconfigInd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEReconfigInd.Merge(m, src)
}
func (m *UEReconfigInd) XXX_Size() int {
	return m.Size()
}
func (m *UEReconfigInd) XXX_DiscardUnknown() {
	xxx_messageInfo_UEReconfigInd.DiscardUnknown(m)
}

var xxx_messageInfo_UEReconfigInd proto.InternalMessageInfo

func (m *UEReconfigInd) GetCrntiOld() string {
	if m != nil {
		return m.CrntiOld
	}
	return ""
}

func (m *UEReconfigInd) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEReconfigInd) GetCrntiNew() string {
	if m != nil {
		return m.CrntiNew
	}
	return ""
}

func (m *UEReconfigInd) GetReconfigCause() ReconfigCause {
	if m != nil {
		return m.ReconfigCause
	}
	return ReconfigCause_RECONFIG_RLF
}

// UEReleaseInd message
type UEReleaseInd struct {
	Crnti        string       `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi         *ECGI        `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	ReleaseCause ReleaseCause `protobuf:"varint,3,opt,name=releaseCause,proto3,enum=interface.e2.ReleaseCause" json:"releaseCause,omitempty"`
}

func (m *UEReleaseInd) Reset()         { *m = UEReleaseInd{} }
func (m *UEReleaseInd) String() string { return proto.CompactTextString(m) }
func (*UEReleaseInd) ProtoMessage()    {}
func (*UEReleaseInd) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{9}
}
func (m *UEReleaseInd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEReleaseInd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEReleaseInd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEReleaseInd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEReleaseInd.Merge(m, src)
}
func (m *UEReleaseInd) XXX_Size() int {
	return m.Size()
}
func (m *UEReleaseInd) XXX_DiscardUnknown() {
	xxx_messageInfo_UEReleaseInd.DiscardUnknown(m)
}

var xxx_messageInfo_UEReleaseInd proto.InternalMessageInfo

func (m *UEReleaseInd) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UEReleaseInd) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEReleaseInd) GetReleaseCause() ReleaseCause {
	if m != nil {
		return m.ReleaseCause
	}
	return ReleaseCause_RELEASE_INACTIVITY
}

type UEAMBR struct {
	AmbrDl string `protobuf:"bytes,1,opt,name=ambrDl,proto3" json:"ambrDl,omitempty"`
	AmbrUl string `protobuf:"bytes,2,opt,name=ambrUl,proto3" json:"ambrUl,omitempty"`
}

func (m *UEAMBR) Reset()         { *m = UEAMBR{} }
func (m *UEAMBR) String() string { return proto.CompactTextString(m) }
func (*UEAMBR) ProtoMessage()    {}
func (*UEAMBR) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{10}
}
func (m *UEAMBR) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEAMBR) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEAMBR.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEAMBR) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEAMBR.Merge(m, src)
}
func (m *UEAMBR) XXX_Size() int {
	return m.Size()
}
func (m *UEAMBR) XXX_DiscardUnknown() {
	xxx_messageInfo_UEAMBR.DiscardUnknown(m)
}

var xxx_messageInfo_UEAMBR proto.InternalMessageInfo

func (m *UEAMBR) GetAmbrDl() string {
	if m != nil {
		return m.AmbrDl
	}
	return ""
}

func (m *UEAMBR) GetAmbrUl() string {
	if m != nil {
		return m.AmbrUl
	}
	return ""
}

type ERABParamsItem struct {
	Id        string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Direction ERABDirection `protobuf:"varint,2,opt,name=direction,proto3,enum=interface.e2.ERABDirection" json:"direction,omitempty"`
	Type      ERABType      `protobuf:"varint,3,opt,name=type,proto3,enum=interface.e2.ERABType" json:"type,omitempty"`
	Qci       string        `protobuf:"bytes,4,opt,name=qci,proto3" json:"qci,omitempty"`
	Arp       uint32        `protobuf:"varint,5,opt,name=arp,proto3" json:"arp,omitempty"`
	GbrDl     string        `protobuf:"bytes,6,opt,name=gbrDl,proto3" json:"gbrDl,omitempty"`
	GbrUl     string        `protobuf:"bytes,7,opt,name=gbrUl,proto3" json:"gbrUl,omitempty"`
	MbrDl     string        `protobuf:"bytes,8,opt,name=mbrDl,proto3" json:"mbrDl,omitempty"`
	MbrUl     string        `protobuf:"bytes,9,opt,name=mbrUl,proto3" json:"mbrUl,omitempty"`
}

func (m *ERABParamsItem) Reset()         { *m = ERABParamsItem{} }
func (m *ERABParamsItem) String() string { return proto.CompactTextString(m) }
func (*ERABParamsItem) ProtoMessage()    {}
func (*ERABParamsItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{11}
}
func (m *ERABParamsItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ERABParamsItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ERABParamsItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ERABParamsItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ERABParamsItem.Merge(m, src)
}
func (m *ERABParamsItem) XXX_Size() int {
	return m.Size()
}
func (m *ERABParamsItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ERABParamsItem.DiscardUnknown(m)
}

var xxx_messageInfo_ERABParamsItem proto.InternalMessageInfo

func (m *ERABParamsItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ERABParamsItem) GetDirection() ERABDirection {
	if m != nil {
		return m.Direction
	}
	return ERABDirection_DL
}

func (m *ERABParamsItem) GetType() ERABType {
	if m != nil {
		return m.Type
	}
	return ERABType_ERAB_DEFAULT
}

func (m *ERABParamsItem) GetQci() string {
	if m != nil {
		return m.Qci
	}
	return ""
}

func (m *ERABParamsItem) GetArp() uint32 {
	if m != nil {
		return m.Arp
	}
	return 0
}

func (m *ERABParamsItem) GetGbrDl() string {
	if m != nil {
		return m.GbrDl
	}
	return ""
}

func (m *ERABParamsItem) GetGbrUl() string {
	if m != nil {
		return m.GbrUl
	}
	return ""
}

func (m *ERABParamsItem) GetMbrDl() string {
	if m != nil {
		return m.MbrDl
	}
	return ""
}

func (m *ERABParamsItem) GetMbrUl() string {
	if m != nil {
		return m.MbrUl
	}
	return ""
}

type ERABResponseItem struct {
	Id       string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Decision SuccessOrFailure `protobuf:"varint,2,opt,name=decision,proto3,enum=interface.e2.SuccessOrFailure" json:"decision,omitempty"`
}

func (m *ERABResponseItem) Reset()         { *m = ERABResponseItem{} }
func (m *ERABResponseItem) String() string { return proto.CompactTextString(m) }
func (*ERABResponseItem) ProtoMessage()    {}
func (*ERABResponseItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{12}
}
func (m *ERABResponseItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ERABResponseItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ERABResponseItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ERABResponseItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ERABResponseItem.Merge(m, src)
}
func (m *ERABResponseItem) XXX_Size() int {
	return m.Size()
}
func (m *ERABResponseItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ERABResponseItem.DiscardUnknown(m)
}

var xxx_messageInfo_ERABResponseItem proto.InternalMessageInfo

func (m *ERABResponseItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ERABResponseItem) GetDecision() SuccessOrFailure {
	if m != nil {
		return m.Decision
	}
	return SuccessOrFailure_SUCCESS
}

// BearerAdmissionRequest message
type BearerAdmissionRequest struct {
	Crnti        string            `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi         *ECGI             `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	UeAmbr       *UEAMBR           `protobuf:"bytes,3,opt,name=ueAmbr,proto3" json:"ueAmbr,omitempty"`
	NumErabsList uint32            `protobuf:"varint,4,opt,name=numErabsList,proto3" json:"numErabsList,omitempty"`
	ErabsParams  []*ERABParamsItem `protobuf:"bytes,5,rep,name=erabsParams,proto3" json:"erabsParams,omitempty"`
}

func (m *BearerAdmissionRequest) Reset()         { *m = BearerAdmissionRequest{} }
func (m *BearerAdmissionRequest) String() string { return proto.CompactTextString(m) }
func (*BearerAdmissionRequest) ProtoMessage()    {}
func (*BearerAdmissionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{13}
}
func (m *BearerAdmissionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerAdmissionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerAdmissionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerAdmissionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerAdmissionRequest.Merge(m, src)
}
func (m *BearerAdmissionRequest) XXX_Size() int {
	return m.Size()
}
func (m *BearerAdmissionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerAdmissionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BearerAdmissionRequest proto.InternalMessageInfo

func (m *BearerAdmissionRequest) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *BearerAdmissionRequest) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *BearerAdmissionRequest) GetUeAmbr() *UEAMBR {
	if m != nil {
		return m.UeAmbr
	}
	return nil
}

func (m *BearerAdmissionRequest) GetNumErabsList() uint32 {
	if m != nil {
		return m.NumErabsList
	}
	return 0
}

func (m *BearerAdmissionRequest) GetErabsParams() []*ERABParamsItem {
	if m != nil {
		return m.ErabsParams
	}
	return nil
}

// BearerAdmissionResponse message
type BearerAdmissionResponse struct {
	Crnti        string              `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi         *ECGI               `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	NumErabsList uint32              `protobuf:"varint,3,opt,name=numErabsList,proto3" json:"numErabsList,omitempty"`
	ErabResponse []*ERABResponseItem `protobuf:"bytes,4,rep,name=erabResponse,proto3" json:"erabResponse,omitempty"`
}

func (m *BearerAdmissionResponse) Reset()         { *m = BearerAdmissionResponse{} }
func (m *BearerAdmissionResponse) String() string { return proto.CompactTextString(m) }
func (*BearerAdmissionResponse) ProtoMessage()    {}
func (*BearerAdmissionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{14}
}
func (m *BearerAdmissionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerAdmissionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerAdmissionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerAdmissionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerAdmissionResponse.Merge(m, src)
}
func (m *BearerAdmissionResponse) XXX_Size() int {
	return m.Size()
}
func (m *BearerAdmissionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerAdmissionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BearerAdmissionResponse proto.InternalMessageInfo

func (m *BearerAdmissionResponse) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *BearerAdmissionResponse) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *BearerAdmissionResponse) GetNumErabsList() uint32 {
	if m != nil {
		return m.NumErabsList
	}
	return 0
}

func (m *BearerAdmissionResponse) GetErabResponse() []*ERABResponseItem {
	if m != nil {
		return m.ErabResponse
	}
	return nil
}

// BearerAdmissionStatus message
type BearerAdmissionStatus struct {
	Crnti        string              `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi         *ECGI               `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	NumErabsList uint32              `protobuf:"varint,3,opt,name=numErabsList,proto3" json:"numErabsList,omitempty"`
	ErabStatus   []*ERABResponseItem `protobuf:"bytes,4,rep,name=erabStatus,proto3" json:"erabStatus,omitempty"`
}

func (m *BearerAdmissionStatus) Reset()         { *m = BearerAdmissionStatus{} }
func (m *BearerAdmissionStatus) String() string { return proto.CompactTextString(m) }
func (*BearerAdmissionStatus) ProtoMessage()    {}
func (*BearerAdmissionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{15}
}
func (m *BearerAdmissionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerAdmissionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerAdmissionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerAdmissionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerAdmissionStatus.Merge(m, src)
}
func (m *BearerAdmissionStatus) XXX_Size() int {
	return m.Size()
}
func (m *BearerAdmissionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerAdmissionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_BearerAdmissionStatus proto.InternalMessageInfo

func (m *BearerAdmissionStatus) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *BearerAdmissionStatus) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *BearerAdmissionStatus) GetNumErabsList() uint32 {
	if m != nil {
		return m.NumErabsList
	}
	return 0
}

func (m *BearerAdmissionStatus) GetErabStatus() []*ERABResponseItem {
	if m != nil {
		return m.ErabStatus
	}
	return nil
}

// BearerReleaseInd message
type BearerReleaseInd struct {
	Crnti        string   `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi         *ECGI    `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	NumErabsList uint32   `protobuf:"varint,3,opt,name=numErabsList,proto3" json:"numErabsList,omitempty"`
	ErabIds      []string `protobuf:"bytes,4,rep,name=erabIds,proto3" json:"erabIds,omitempty"`
}

func (m *BearerReleaseInd) Reset()         { *m = BearerReleaseInd{} }
func (m *BearerReleaseInd) String() string { return proto.CompactTextString(m) }
func (*BearerReleaseInd) ProtoMessage()    {}
func (*BearerReleaseInd) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{16}
}
func (m *BearerReleaseInd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerReleaseInd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerReleaseInd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerReleaseInd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerReleaseInd.Merge(m, src)
}
func (m *BearerReleaseInd) XXX_Size() int {
	return m.Size()
}
func (m *BearerReleaseInd) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerReleaseInd.DiscardUnknown(m)
}

var xxx_messageInfo_BearerReleaseInd proto.InternalMessageInfo

func (m *BearerReleaseInd) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *BearerReleaseInd) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *BearerReleaseInd) GetNumErabsList() uint32 {
	if m != nil {
		return m.NumErabsList
	}
	return 0
}

func (m *BearerReleaseInd) GetErabIds() []string {
	if m != nil {
		return m.ErabIds
	}
	return nil
}

// HORequest message
type HORequest struct {
	Crnti  string   `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	EcgiS  *ECGI    `protobuf:"bytes,2,opt,name=ecgiS,proto3" json:"ecgiS,omitempty"`
	EcgiT  *ECGI    `protobuf:"bytes,3,opt,name=ecgiT,proto3" json:"ecgiT,omitempty"`
	Crntis []string `protobuf:"bytes,4,rep,name=crntis,proto3" json:"crntis,omitempty"`
}

func (m *HORequest) Reset()         { *m = HORequest{} }
func (m *HORequest) String() string { return proto.CompactTextString(m) }
func (*HORequest) ProtoMessage()    {}
func (*HORequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{17}
}
func (m *HORequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HORequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HORequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HORequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HORequest.Merge(m, src)
}
func (m *HORequest) XXX_Size() int {
	return m.Size()
}
func (m *HORequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HORequest.DiscardUnknown(m)
}

var xxx_messageInfo_HORequest proto.InternalMessageInfo

func (m *HORequest) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *HORequest) GetEcgiS() *ECGI {
	if m != nil {
		return m.EcgiS
	}
	return nil
}

func (m *HORequest) GetEcgiT() *ECGI {
	if m != nil {
		return m.EcgiT
	}
	return nil
}

func (m *HORequest) GetCrntis() []string {
	if m != nil {
		return m.Crntis
	}
	return nil
}

// HOFailure message
type HOFailure struct {
	Crnti          string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	EcgiS          *ECGI  `protobuf:"bytes,2,opt,name=ecgiS,proto3" json:"ecgiS,omitempty"`
	HoFailureCause string `protobuf:"bytes,3,opt,name=hoFailureCause,proto3" json:"hoFailureCause,omitempty"`
}

func (m *HOFailure) Reset()         { *m = HOFailure{} }
func (m *HOFailure) String() string { return proto.CompactTextString(m) }
func (*HOFailure) ProtoMessage()    {}
func (*HOFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{18}
}
func (m *HOFailure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HOFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HOFailure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HOFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HOFailure.Merge(m, src)
}
func (m *HOFailure) XXX_Size() int {
	return m.Size()
}
func (m *HOFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_HOFailure.DiscardUnknown(m)
}

var xxx_messageInfo_HOFailure proto.InternalMessageInfo

func (m *HOFailure) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *HOFailure) GetEcgiS() *ECGI {
	if m != nil {
		return m.EcgiS
	}
	return nil
}

func (m *HOFailure) GetHoFailureCause() string {
	if m != nil {
		return m.HoFailureCause
	}
	return ""
}

// HOComplete message
type HOComplete struct {
	CrntiNew string `protobuf:"bytes,1,opt,name=crntiNew,proto3" json:"crntiNew,omitempty"`
	EcgiS    *ECGI  `protobuf:"bytes,2,opt,name=ecgiS,proto3" json:"ecgiS,omitempty"`
	EcgiT    *ECGI  `protobuf:"bytes,3,opt,name=ecgiT,proto3" json:"ecgiT,omitempty"`
}

func (m *HOComplete) Reset()         { *m = HOComplete{} }
func (m *HOComplete) String() string { return proto.CompactTextString(m) }
func (*HOComplete) ProtoMessage()    {}
func (*HOComplete) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{19}
}
func (m *HOComplete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HOComplete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HOComplete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HOComplete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HOComplete.Merge(m, src)
}
func (m *HOComplete) XXX_Size() int {
	return m.Size()
}
func (m *HOComplete) XXX_DiscardUnknown() {
	xxx_messageInfo_HOComplete.DiscardUnknown(m)
}

var xxx_messageInfo_HOComplete proto.InternalMessageInfo

func (m *HOComplete) GetCrntiNew() string {
	if m != nil {
		return m.CrntiNew
	}
	return ""
}

func (m *HOComplete) GetEcgiS() *ECGI {
	if m != nil {
		return m.EcgiS
	}
	return nil
}

func (m *HOComplete) GetEcgiT() *ECGI {
	if m != nil {
		return m.EcgiT
	}
	return nil
}

// HOCause message
type HOCause struct {
	Crnti     string         `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	EcgiS     *ECGI          `protobuf:"bytes,2,opt,name=ecgiS,proto3" json:"ecgiS,omitempty"`
	EcgiT     *ECGI          `protobuf:"bytes,3,opt,name=ecgiT,proto3" json:"ecgiT,omitempty"`
	HoCause   string         `protobuf:"bytes,4,opt,name=hoCause,proto3" json:"hoCause,omitempty"`
	HoTrigger []*RXSigReport `protobuf:"bytes,5,rep,name=hoTrigger,proto3" json:"hoTrigger,omitempty"`
}

func (m *HOCause) Reset()         { *m = HOCause{} }
func (m *HOCause) String() string { return proto.CompactTextString(m) }
func (*HOCause) ProtoMessage()    {}
func (*HOCause) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{20}
}
func (m *HOCause) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HOCause) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HOCause.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HOCause) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HOCause.Merge(m, src)
}
func (m *HOCause) XXX_Size() int {
	return m.Size()
}
func (m *HOCause) XXX_DiscardUnknown() {
	xxx_messageInfo_HOCause.DiscardUnknown(m)
}

var xxx_messageInfo_HOCause proto.InternalMessageInfo

func (m *HOCause) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *HOCause) GetEcgiS() *ECGI {
	if m != nil {
		return m.EcgiS
	}
	return nil
}

func (m *HOCause) GetEcgiT() *ECGI {
	if m != nil {
		return m.EcgiT
	}
	return nil
}

func (m *HOCause) GetHoCause() string {
	if m != nil {
		return m.HoCause
	}
	return ""
}

func (m *HOCause) GetHoTrigger() []*RXSigReport {
	if m != nil {
		return m.HoTrigger
	}
	return nil
}

type MeasCell struct {
	Pci                  uint32 `protobuf:"varint,1,opt,name=pci,proto3" json:"pci,omitempty"`
	CellIndividualOffset string `protobuf:"bytes,2,opt,name=cellIndividualOffset,proto3" json:"cellIndividualOffset,omitempty"`
}

func (m *MeasCell) Reset()         { *m = MeasCell{} }
func (m *MeasCell) String() string { return proto.CompactTextString(m) }
func (*MeasCell) ProtoMessage()    {}
func (*MeasCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{21}
}
func (m *MeasCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeasCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeasCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeasCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeasCell.Merge(m, src)
}
func (m *MeasCell) XXX_Size() int {
	return m.Size()
}
func (m *MeasCell) XXX_DiscardUnknown() {
	xxx_messageInfo_MeasCell.DiscardUnknown(m)
}

var xxx_messageInfo_MeasCell proto.InternalMessageInfo

func (m *MeasCell) GetPci() uint32 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *MeasCell) GetCellIndividualOffset() string {
	if m != nil {
		return m.CellIndividualOffset
	}
	return ""
}

type MeasObject struct {
	DlFreq    string      `protobuf:"bytes,1,opt,name=dlFreq,proto3" json:"dlFreq,omitempty"`
	MeasCells []*MeasCell `protobuf:"bytes,2,rep,name=measCells,proto3" json:"measCells,omitempty"`
}

func (m *MeasObject) Reset()         { *m = MeasObject{} }
func (m *MeasObject) String() string { return proto.CompactTextString(m) }
func (*MeasObject) ProtoMessage()    {}
func (*MeasObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{22}
}
func (m *MeasObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeasObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeasObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeasObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeasObject.Merge(m, src)
}
func (m *MeasObject) XXX_Size() int {
	return m.Size()
}
func (m *MeasObject) XXX_DiscardUnknown() {
	xxx_messageInfo_MeasObject.DiscardUnknown(m)
}

var xxx_messageInfo_MeasObject proto.InternalMessageInfo

func (m *MeasObject) GetDlFreq() string {
	if m != nil {
		return m.DlFreq
	}
	return ""
}

func (m *MeasObject) GetMeasCells() []*MeasCell {
	if m != nil {
		return m.MeasCells
	}
	return nil
}

type ReportParamChoice struct {
	// Types that are valid to be assigned to Choice:
	//	*ReportParamChoice_PerParam
	//	*ReportParamChoice_A1Param
	//	*ReportParamChoice_A2Param
	//	*ReportParamChoice_A3Param
	//	*ReportParamChoice_A4Param
	//	*ReportParamChoice_A5Param
	//	*ReportParamChoice_A6Param
	Choice isReportParamChoice_Choice `protobuf_oneof:"choice"`
}

func (m *ReportParamChoice) Reset()         { *m = ReportParamChoice{} }
func (m *ReportParamChoice) String() string { return proto.CompactTextString(m) }
func (*ReportParamChoice) ProtoMessage()    {}
func (*ReportParamChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{23}
}
func (m *ReportParamChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportParamChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportParamChoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportParamChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportParamChoice.Merge(m, src)
}
func (m *ReportParamChoice) XXX_Size() int {
	return m.Size()
}
func (m *ReportParamChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportParamChoice.DiscardUnknown(m)
}

var xxx_messageInfo_ReportParamChoice proto.InternalMessageInfo

type isReportParamChoice_Choice interface {
	isReportParamChoice_Choice()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReportParamChoice_PerParam struct {
	PerParam *PerParam `protobuf:"bytes,1,opt,name=perParam,proto3,oneof" json:"perParam,omitempty"`
}
type ReportParamChoice_A1Param struct {
	A1Param *A1Param `protobuf:"bytes,2,opt,name=a1Param,proto3,oneof" json:"a1Param,omitempty"`
}
type ReportParamChoice_A2Param struct {
	A2Param *A2Param `protobuf:"bytes,3,opt,name=a2Param,proto3,oneof" json:"a2Param,omitempty"`
}
type ReportParamChoice_A3Param struct {
	A3Param *A3Param `protobuf:"bytes,4,opt,name=a3Param,proto3,oneof" json:"a3Param,omitempty"`
}
type ReportParamChoice_A4Param struct {
	A4Param *A4Param `protobuf:"bytes,5,opt,name=a4Param,proto3,oneof" json:"a4Param,omitempty"`
}
type ReportParamChoice_A5Param struct {
	A5Param *A5Param `protobuf:"bytes,6,opt,name=a5Param,proto3,oneof" json:"a5Param,omitempty"`
}
type ReportParamChoice_A6Param struct {
	A6Param *A6Param `protobuf:"bytes,7,opt,name=a6Param,proto3,oneof" json:"a6Param,omitempty"`
}

func (*ReportParamChoice_PerParam) isReportParamChoice_Choice() {}
func (*ReportParamChoice_A1Param) isReportParamChoice_Choice()  {}
func (*ReportParamChoice_A2Param) isReportParamChoice_Choice()  {}
func (*ReportParamChoice_A3Param) isReportParamChoice_Choice()  {}
func (*ReportParamChoice_A4Param) isReportParamChoice_Choice()  {}
func (*ReportParamChoice_A5Param) isReportParamChoice_Choice()  {}
func (*ReportParamChoice_A6Param) isReportParamChoice_Choice()  {}

func (m *ReportParamChoice) GetChoice() isReportParamChoice_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *ReportParamChoice) GetPerParam() *PerParam {
	if x, ok := m.GetChoice().(*ReportParamChoice_PerParam); ok {
		return x.PerParam
	}
	return nil
}

func (m *ReportParamChoice) GetA1Param() *A1Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A1Param); ok {
		return x.A1Param
	}
	return nil
}

func (m *ReportParamChoice) GetA2Param() *A2Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A2Param); ok {
		return x.A2Param
	}
	return nil
}

func (m *ReportParamChoice) GetA3Param() *A3Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A3Param); ok {
		return x.A3Param
	}
	return nil
}

func (m *ReportParamChoice) GetA4Param() *A4Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A4Param); ok {
		return x.A4Param
	}
	return nil
}

func (m *ReportParamChoice) GetA5Param() *A5Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A5Param); ok {
		return x.A5Param
	}
	return nil
}

func (m *ReportParamChoice) GetA6Param() *A6Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A6Param); ok {
		return x.A6Param
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReportParamChoice) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReportParamChoice_PerParam)(nil),
		(*ReportParamChoice_A1Param)(nil),
		(*ReportParamChoice_A2Param)(nil),
		(*ReportParamChoice_A3Param)(nil),
		(*ReportParamChoice_A4Param)(nil),
		(*ReportParamChoice_A5Param)(nil),
		(*ReportParamChoice_A6Param)(nil),
	}
}

type ThresholdEUTRAChoice struct {
	// Types that are valid to be assigned to Choice:
	//	*ThresholdEUTRAChoice_ThresholdRSRP
	//	*ThresholdEUTRAChoice_ThresholdRSRQ
	Choice isThresholdEUTRAChoice_Choice `protobuf_oneof:"choice"`
}

func (m *ThresholdEUTRAChoice) Reset()         { *m = ThresholdEUTRAChoice{} }
func (m *ThresholdEUTRAChoice) String() string { return proto.CompactTextString(m) }
func (*ThresholdEUTRAChoice) ProtoMessage()    {}
func (*ThresholdEUTRAChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{24}
}
func (m *ThresholdEUTRAChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdEUTRAChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdEUTRAChoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThresholdEUTRAChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdEUTRAChoice.Merge(m, src)
}
func (m *ThresholdEUTRAChoice) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdEUTRAChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdEUTRAChoice.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdEUTRAChoice proto.InternalMessageInfo

type isThresholdEUTRAChoice_Choice interface {
	isThresholdEUTRAChoice_Choice()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ThresholdEUTRAChoice_ThresholdRSRP struct {
	ThresholdRSRP string `protobuf:"bytes,1,opt,name=thresholdRSRP,proto3,oneof" json:"thresholdRSRP,omitempty"`
}
type ThresholdEUTRAChoice_ThresholdRSRQ struct {
	ThresholdRSRQ string `protobuf:"bytes,2,opt,name=thresholdRSRQ,proto3,oneof" json:"thresholdRSRQ,omitempty"`
}

func (*ThresholdEUTRAChoice_ThresholdRSRP) isThresholdEUTRAChoice_Choice() {}
func (*ThresholdEUTRAChoice_ThresholdRSRQ) isThresholdEUTRAChoice_Choice() {}

func (m *ThresholdEUTRAChoice) GetChoice() isThresholdEUTRAChoice_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *ThresholdEUTRAChoice) GetThresholdRSRP() string {
	if x, ok := m.GetChoice().(*ThresholdEUTRAChoice_ThresholdRSRP); ok {
		return x.ThresholdRSRP
	}
	return ""
}

func (m *ThresholdEUTRAChoice) GetThresholdRSRQ() string {
	if x, ok := m.GetChoice().(*ThresholdEUTRAChoice_ThresholdRSRQ); ok {
		return x.ThresholdRSRQ
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ThresholdEUTRAChoice) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ThresholdEUTRAChoice_ThresholdRSRP)(nil),
		(*ThresholdEUTRAChoice_ThresholdRSRQ)(nil),
	}
}

type ThreasholdEUTRA struct {
	Present ThresholdEUTRAPR      `protobuf:"varint,1,opt,name=present,proto3,enum=interface.e2.ThresholdEUTRAPR" json:"present,omitempty"`
	Choice  *ThresholdEUTRAChoice `protobuf:"bytes,2,opt,name=choice,proto3" json:"choice,omitempty"`
}

func (m *ThreasholdEUTRA) Reset()         { *m = ThreasholdEUTRA{} }
func (m *ThreasholdEUTRA) String() string { return proto.CompactTextString(m) }
func (*ThreasholdEUTRA) ProtoMessage()    {}
func (*ThreasholdEUTRA) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{25}
}
func (m *ThreasholdEUTRA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThreasholdEUTRA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThreasholdEUTRA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThreasholdEUTRA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThreasholdEUTRA.Merge(m, src)
}
func (m *ThreasholdEUTRA) XXX_Size() int {
	return m.Size()
}
func (m *ThreasholdEUTRA) XXX_DiscardUnknown() {
	xxx_messageInfo_ThreasholdEUTRA.DiscardUnknown(m)
}

var xxx_messageInfo_ThreasholdEUTRA proto.InternalMessageInfo

func (m *ThreasholdEUTRA) GetPresent() ThresholdEUTRAPR {
	if m != nil {
		return m.Present
	}
	return ThresholdEUTRAPR_THRESHOLD_EUTRA_PR_NOTHING
}

func (m *ThreasholdEUTRA) GetChoice() *ThresholdEUTRAChoice {
	if m != nil {
		return m.Choice
	}
	return nil
}

type PerParam struct {
	ReportIntervalMs PerParamReportIntervalMs `protobuf:"varint,1,opt,name=reportIntervalMs,proto3,enum=interface.e2.PerParamReportIntervalMs" json:"reportIntervalMs,omitempty"`
}

func (m *PerParam) Reset()         { *m = PerParam{} }
func (m *PerParam) String() string { return proto.CompactTextString(m) }
func (*PerParam) ProtoMessage()    {}
func (*PerParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{26}
}
func (m *PerParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerParam.Merge(m, src)
}
func (m *PerParam) XXX_Size() int {
	return m.Size()
}
func (m *PerParam) XXX_DiscardUnknown() {
	xxx_messageInfo_PerParam.DiscardUnknown(m)
}

var xxx_messageInfo_PerParam proto.InternalMessageInfo

func (m *PerParam) GetReportIntervalMs() PerParamReportIntervalMs {
	if m != nil {
		return m.ReportIntervalMs
	}
	return PerParamReportIntervalMs_PER_PARAM_MS_120
}

type A1Param struct {
	A1Threshold *ThreasholdEUTRA `protobuf:"bytes,1,opt,name=a1Threshold,proto3" json:"a1Threshold,omitempty"`
}

func (m *A1Param) Reset()         { *m = A1Param{} }
func (m *A1Param) String() string { return proto.CompactTextString(m) }
func (*A1Param) ProtoMessage()    {}
func (*A1Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{27}
}
func (m *A1Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A1Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A1Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A1Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A1Param.Merge(m, src)
}
func (m *A1Param) XXX_Size() int {
	return m.Size()
}
func (m *A1Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A1Param.DiscardUnknown(m)
}

var xxx_messageInfo_A1Param proto.InternalMessageInfo

func (m *A1Param) GetA1Threshold() *ThreasholdEUTRA {
	if m != nil {
		return m.A1Threshold
	}
	return nil
}

type A2Param struct {
	A2Threshold *ThreasholdEUTRA `protobuf:"bytes,1,opt,name=a2Threshold,proto3" json:"a2Threshold,omitempty"`
}

func (m *A2Param) Reset()         { *m = A2Param{} }
func (m *A2Param) String() string { return proto.CompactTextString(m) }
func (*A2Param) ProtoMessage()    {}
func (*A2Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{28}
}
func (m *A2Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A2Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A2Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A2Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A2Param.Merge(m, src)
}
func (m *A2Param) XXX_Size() int {
	return m.Size()
}
func (m *A2Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A2Param.DiscardUnknown(m)
}

var xxx_messageInfo_A2Param proto.InternalMessageInfo

func (m *A2Param) GetA2Threshold() *ThreasholdEUTRA {
	if m != nil {
		return m.A2Threshold
	}
	return nil
}

type A3Param struct {
	A3Offset string `protobuf:"bytes,1,opt,name=a3Offset,proto3" json:"a3Offset,omitempty"`
}

func (m *A3Param) Reset()         { *m = A3Param{} }
func (m *A3Param) String() string { return proto.CompactTextString(m) }
func (*A3Param) ProtoMessage()    {}
func (*A3Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{29}
}
func (m *A3Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A3Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A3Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A3Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A3Param.Merge(m, src)
}
func (m *A3Param) XXX_Size() int {
	return m.Size()
}
func (m *A3Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A3Param.DiscardUnknown(m)
}

var xxx_messageInfo_A3Param proto.InternalMessageInfo

func (m *A3Param) GetA3Offset() string {
	if m != nil {
		return m.A3Offset
	}
	return ""
}

type A4Param struct {
	A4Threshold *ThreasholdEUTRA `protobuf:"bytes,1,opt,name=a4Threshold,proto3" json:"a4Threshold,omitempty"`
}

func (m *A4Param) Reset()         { *m = A4Param{} }
func (m *A4Param) String() string { return proto.CompactTextString(m) }
func (*A4Param) ProtoMessage()    {}
func (*A4Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{30}
}
func (m *A4Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A4Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A4Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A4Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A4Param.Merge(m, src)
}
func (m *A4Param) XXX_Size() int {
	return m.Size()
}
func (m *A4Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A4Param.DiscardUnknown(m)
}

var xxx_messageInfo_A4Param proto.InternalMessageInfo

func (m *A4Param) GetA4Threshold() *ThreasholdEUTRA {
	if m != nil {
		return m.A4Threshold
	}
	return nil
}

type A5Param struct {
	A5Threshold1 *ThreasholdEUTRA `protobuf:"bytes,1,opt,name=a5Threshold1,proto3" json:"a5Threshold1,omitempty"`
	A5Threshold2 *ThreasholdEUTRA `protobuf:"bytes,2,opt,name=a5Threshold2,proto3" json:"a5Threshold2,omitempty"`
}

func (m *A5Param) Reset()         { *m = A5Param{} }
func (m *A5Param) String() string { return proto.CompactTextString(m) }
func (*A5Param) ProtoMessage()    {}
func (*A5Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{31}
}
func (m *A5Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A5Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A5Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A5Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A5Param.Merge(m, src)
}
func (m *A5Param) XXX_Size() int {
	return m.Size()
}
func (m *A5Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A5Param.DiscardUnknown(m)
}

var xxx_messageInfo_A5Param proto.InternalMessageInfo

func (m *A5Param) GetA5Threshold1() *ThreasholdEUTRA {
	if m != nil {
		return m.A5Threshold1
	}
	return nil
}

func (m *A5Param) GetA5Threshold2() *ThreasholdEUTRA {
	if m != nil {
		return m.A5Threshold2
	}
	return nil
}

type A6Param struct {
	A6Offset string `protobuf:"bytes,1,opt,name=a6Offset,proto3" json:"a6Offset,omitempty"`
}

func (m *A6Param) Reset()         { *m = A6Param{} }
func (m *A6Param) String() string { return proto.CompactTextString(m) }
func (*A6Param) ProtoMessage()    {}
func (*A6Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{32}
}
func (m *A6Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A6Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A6Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A6Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A6Param.Merge(m, src)
}
func (m *A6Param) XXX_Size() int {
	return m.Size()
}
func (m *A6Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A6Param.DiscardUnknown(m)
}

var xxx_messageInfo_A6Param proto.InternalMessageInfo

func (m *A6Param) GetA6Offset() string {
	if m != nil {
		return m.A6Offset
	}
	return ""
}

type ReportParam struct {
	Present       ReportParamPR      `protobuf:"varint,1,opt,name=present,proto3,enum=interface.e2.ReportParamPR" json:"present,omitempty"`
	Choice        *ReportParamChoice `protobuf:"bytes,2,opt,name=choice,proto3" json:"choice,omitempty"`
	Hysteresis    string             `protobuf:"bytes,3,opt,name=hysteresis,proto3" json:"hysteresis,omitempty"`
	Timetotrigger TimeToTrigger      `protobuf:"varint,4,opt,name=timetotrigger,proto3,enum=interface.e2.TimeToTrigger" json:"timetotrigger,omitempty"`
}

func (m *ReportParam) Reset()         { *m = ReportParam{} }
func (m *ReportParam) String() string { return proto.CompactTextString(m) }
func (*ReportParam) ProtoMessage()    {}
func (*ReportParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{33}
}
func (m *ReportParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportParam.Merge(m, src)
}
func (m *ReportParam) XXX_Size() int {
	return m.Size()
}
func (m *ReportParam) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportParam.DiscardUnknown(m)
}

var xxx_messageInfo_ReportParam proto.InternalMessageInfo

func (m *ReportParam) GetPresent() ReportParamPR {
	if m != nil {
		return m.Present
	}
	return ReportParamPR_REPORT_PARAM_PR_NOTHING
}

func (m *ReportParam) GetChoice() *ReportParamChoice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *ReportParam) GetHysteresis() string {
	if m != nil {
		return m.Hysteresis
	}
	return ""
}

func (m *ReportParam) GetTimetotrigger() TimeToTrigger {
	if m != nil {
		return m.Timetotrigger
	}
	return TimeToTrigger_TTT_MS0
}

type ReportConfig struct {
	ReportParams    *ReportParam    `protobuf:"bytes,1,opt,name=reportParams,proto3" json:"reportParams,omitempty"`
	TriggerQuantity TriggerQuantity `protobuf:"varint,2,opt,name=triggerQuantity,proto3,enum=interface.e2.TriggerQuantity" json:"triggerQuantity,omitempty"`
	ReportQuality   ReportQuality   `protobuf:"varint,3,opt,name=reportQuality,proto3,enum=interface.e2.ReportQuality" json:"reportQuality,omitempty"`
}

func (m *ReportConfig) Reset()         { *m = ReportConfig{} }
func (m *ReportConfig) String() string { return proto.CompactTextString(m) }
func (*ReportConfig) ProtoMessage()    {}
func (*ReportConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{34}
}
func (m *ReportConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportConfig.Merge(m, src)
}
func (m *ReportConfig) XXX_Size() int {
	return m.Size()
}
func (m *ReportConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ReportConfig proto.InternalMessageInfo

func (m *ReportConfig) GetReportParams() *ReportParam {
	if m != nil {
		return m.ReportParams
	}
	return nil
}

func (m *ReportConfig) GetTriggerQuantity() TriggerQuantity {
	if m != nil {
		return m.TriggerQuantity
	}
	return TriggerQuantity_TQ_RSRP
}

func (m *ReportConfig) GetReportQuality() ReportQuality {
	if m != nil {
		return m.ReportQuality
	}
	return ReportQuality_RQ_SAME
}

type AddMeasId struct {
	AddMeasId []string `protobuf:"bytes,1,rep,name=addMeasId,proto3" json:"addMeasId,omitempty"`
}

func (m *AddMeasId) Reset()         { *m = AddMeasId{} }
func (m *AddMeasId) String() string { return proto.CompactTextString(m) }
func (*AddMeasId) ProtoMessage()    {}
func (*AddMeasId) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{35}
}
func (m *AddMeasId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMeasId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMeasId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMeasId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMeasId.Merge(m, src)
}
func (m *AddMeasId) XXX_Size() int {
	return m.Size()
}
func (m *AddMeasId) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMeasId.DiscardUnknown(m)
}

var xxx_messageInfo_AddMeasId proto.InternalMessageInfo

func (m *AddMeasId) GetAddMeasId() []string {
	if m != nil {
		return m.AddMeasId
	}
	return nil
}

type DelMeasId struct {
	DelMeasId []string `protobuf:"bytes,1,rep,name=delMeasId,proto3" json:"delMeasId,omitempty"`
}

func (m *DelMeasId) Reset()         { *m = DelMeasId{} }
func (m *DelMeasId) String() string { return proto.CompactTextString(m) }
func (*DelMeasId) ProtoMessage()    {}
func (*DelMeasId) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{36}
}
func (m *DelMeasId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelMeasId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelMeasId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelMeasId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelMeasId.Merge(m, src)
}
func (m *DelMeasId) XXX_Size() int {
	return m.Size()
}
func (m *DelMeasId) XXX_DiscardUnknown() {
	xxx_messageInfo_DelMeasId.DiscardUnknown(m)
}

var xxx_messageInfo_DelMeasId proto.InternalMessageInfo

func (m *DelMeasId) GetDelMeasId() []string {
	if m != nil {
		return m.DelMeasId
	}
	return nil
}

type MeasIdActionChoice struct {
	// Types that are valid to be assigned to Choice:
	//	*MeasIdActionChoice_AddMeasId
	//	*MeasIdActionChoice_DelMeasId
	//	*MeasIdActionChoice_Hototarget
	Choice isMeasIdActionChoice_Choice `protobuf_oneof:"choice"`
}

func (m *MeasIdActionChoice) Reset()         { *m = MeasIdActionChoice{} }
func (m *MeasIdActionChoice) String() string { return proto.CompactTextString(m) }
func (*MeasIdActionChoice) ProtoMessage()    {}
func (*MeasIdActionChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{37}
}
func (m *MeasIdActionChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeasIdActionChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeasIdActionChoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeasIdActionChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeasIdActionChoice.Merge(m, src)
}
func (m *MeasIdActionChoice) XXX_Size() int {
	return m.Size()
}
func (m *MeasIdActionChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_MeasIdActionChoice.DiscardUnknown(m)
}

var xxx_messageInfo_MeasIdActionChoice proto.InternalMessageInfo

type isMeasIdActionChoice_Choice interface {
	isMeasIdActionChoice_Choice()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MeasIdActionChoice_AddMeasId struct {
	AddMeasId *AddMeasId `protobuf:"bytes,1,opt,name=addMeasId,proto3,oneof" json:"addMeasId,omitempty"`
}
type MeasIdActionChoice_DelMeasId struct {
	DelMeasId *DelMeasId `protobuf:"bytes,2,opt,name=delMeasId,proto3,oneof" json:"delMeasId,omitempty"`
}
type MeasIdActionChoice_Hototarget struct {
	Hototarget string `protobuf:"bytes,3,opt,name=hototarget,proto3,oneof" json:"hototarget,omitempty"`
}

func (*MeasIdActionChoice_AddMeasId) isMeasIdActionChoice_Choice()  {}
func (*MeasIdActionChoice_DelMeasId) isMeasIdActionChoice_Choice()  {}
func (*MeasIdActionChoice_Hototarget) isMeasIdActionChoice_Choice() {}

func (m *MeasIdActionChoice) GetChoice() isMeasIdActionChoice_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *MeasIdActionChoice) GetAddMeasId() *AddMeasId {
	if x, ok := m.GetChoice().(*MeasIdActionChoice_AddMeasId); ok {
		return x.AddMeasId
	}
	return nil
}

func (m *MeasIdActionChoice) GetDelMeasId() *DelMeasId {
	if x, ok := m.GetChoice().(*MeasIdActionChoice_DelMeasId); ok {
		return x.DelMeasId
	}
	return nil
}

func (m *MeasIdActionChoice) GetHototarget() string {
	if x, ok := m.GetChoice().(*MeasIdActionChoice_Hototarget); ok {
		return x.Hototarget
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MeasIdActionChoice) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MeasIdActionChoice_AddMeasId)(nil),
		(*MeasIdActionChoice_DelMeasId)(nil),
		(*MeasIdActionChoice_Hototarget)(nil),
	}
}

type MeasIdAction struct {
	Present MeasIdActionPR      `protobuf:"varint,1,opt,name=present,proto3,enum=interface.e2.MeasIdActionPR" json:"present,omitempty"`
	Choice  *MeasIdActionChoice `protobuf:"bytes,2,opt,name=choice,proto3" json:"choice,omitempty"`
}

func (m *MeasIdAction) Reset()         { *m = MeasIdAction{} }
func (m *MeasIdAction) String() string { return proto.CompactTextString(m) }
func (*MeasIdAction) ProtoMessage()    {}
func (*MeasIdAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{38}
}
func (m *MeasIdAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeasIdAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeasIdAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeasIdAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeasIdAction.Merge(m, src)
}
func (m *MeasIdAction) XXX_Size() int {
	return m.Size()
}
func (m *MeasIdAction) XXX_DiscardUnknown() {
	xxx_messageInfo_MeasIdAction.DiscardUnknown(m)
}

var xxx_messageInfo_MeasIdAction proto.InternalMessageInfo

func (m *MeasIdAction) GetPresent() MeasIdActionPR {
	if m != nil {
		return m.Present
	}
	return MeasIdActionPR_MEAS_ID_ACTION_PR_NOTHING
}

func (m *MeasIdAction) GetChoice() *MeasIdActionChoice {
	if m != nil {
		return m.Choice
	}
	return nil
}

type MeasID struct {
	MeasObjectId   string        `protobuf:"bytes,1,opt,name=measObjectId,proto3" json:"measObjectId,omitempty"`
	ReportConfigId string        `protobuf:"bytes,2,opt,name=reportConfigId,proto3" json:"reportConfigId,omitempty"`
	Action         *MeasIdAction `protobuf:"bytes,3,opt,name=action,proto3" json:"action,omitempty"`
}

func (m *MeasID) Reset()         { *m = MeasID{} }
func (m *MeasID) String() string { return proto.CompactTextString(m) }
func (*MeasID) ProtoMessage()    {}
func (*MeasID) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{39}
}
func (m *MeasID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeasID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeasID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeasID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeasID.Merge(m, src)
}
func (m *MeasID) XXX_Size() int {
	return m.Size()
}
func (m *MeasID) XXX_DiscardUnknown() {
	xxx_messageInfo_MeasID.DiscardUnknown(m)
}

var xxx_messageInfo_MeasID proto.InternalMessageInfo

func (m *MeasID) GetMeasObjectId() string {
	if m != nil {
		return m.MeasObjectId
	}
	return ""
}

func (m *MeasID) GetReportConfigId() string {
	if m != nil {
		return m.ReportConfigId
	}
	return ""
}

func (m *MeasID) GetAction() *MeasIdAction {
	if m != nil {
		return m.Action
	}
	return nil
}

// RRCMeasConfig message
type RRCMeasConfig struct {
	Ecgi          *ECGI           `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti         []string        `protobuf:"bytes,2,rep,name=crnti,proto3" json:"crnti,omitempty"`
	MeasObjects   []*MeasObject   `protobuf:"bytes,3,rep,name=measObjects,proto3" json:"measObjects,omitempty"`
	ReportConfigs []*ReportConfig `protobuf:"bytes,4,rep,name=reportConfigs,proto3" json:"reportConfigs,omitempty"`
	MeasIds       []*MeasID       `protobuf:"bytes,5,rep,name=measIds,proto3" json:"measIds,omitempty"`
}

func (m *RRCMeasConfig) Reset()         { *m = RRCMeasConfig{} }
func (m *RRCMeasConfig) String() string { return proto.CompactTextString(m) }
func (*RRCMeasConfig) ProtoMessage()    {}
func (*RRCMeasConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{40}
}
func (m *RRCMeasConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RRCMeasConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RRCMeasConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RRCMeasConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RRCMeasConfig.Merge(m, src)
}
func (m *RRCMeasConfig) XXX_Size() int {
	return m.Size()
}
func (m *RRCMeasConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RRCMeasConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RRCMeasConfig proto.InternalMessageInfo

func (m *RRCMeasConfig) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RRCMeasConfig) GetCrnti() []string {
	if m != nil {
		return m.Crnti
	}
	return nil
}

func (m *RRCMeasConfig) GetMeasObjects() []*MeasObject {
	if m != nil {
		return m.MeasObjects
	}
	return nil
}

func (m *RRCMeasConfig) GetReportConfigs() []*ReportConfig {
	if m != nil {
		return m.ReportConfigs
	}
	return nil
}

func (m *RRCMeasConfig) GetMeasIds() []*MeasID {
	if m != nil {
		return m.MeasIds
	}
	return nil
}

type PCIARFCN struct {
	Pci      uint32 `protobuf:"varint,1,opt,name=pci,proto3" json:"pci,omitempty"`
	EarfcnDl string `protobuf:"bytes,2,opt,name=earfcnDl,proto3" json:"earfcnDl,omitempty"`
}

func (m *PCIARFCN) Reset()         { *m = PCIARFCN{} }
func (m *PCIARFCN) String() string { return proto.CompactTextString(m) }
func (*PCIARFCN) ProtoMessage()    {}
func (*PCIARFCN) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{41}
}
func (m *PCIARFCN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PCIARFCN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PCIARFCN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PCIARFCN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PCIARFCN.Merge(m, src)
}
func (m *PCIARFCN) XXX_Size() int {
	return m.Size()
}
func (m *PCIARFCN) XXX_DiscardUnknown() {
	xxx_messageInfo_PCIARFCN.DiscardUnknown(m)
}

var xxx_messageInfo_PCIARFCN proto.InternalMessageInfo

func (m *PCIARFCN) GetPci() uint32 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *PCIARFCN) GetEarfcnDl() string {
	if m != nil {
		return m.EarfcnDl
	}
	return ""
}

type RXSigReport struct {
	PciArfcn *PCIARFCN `protobuf:"bytes,1,opt,name=pciArfcn,proto3" json:"pciArfcn,omitempty"`
	Ecgi     *ECGI     `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Rsrp     string    `protobuf:"bytes,3,opt,name=rsrp,proto3" json:"rsrp,omitempty"`
	Rsrq     string    `protobuf:"bytes,4,opt,name=rsrq,proto3" json:"rsrq,omitempty"`
}

func (m *RXSigReport) Reset()         { *m = RXSigReport{} }
func (m *RXSigReport) String() string { return proto.CompactTextString(m) }
func (*RXSigReport) ProtoMessage()    {}
func (*RXSigReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{42}
}
func (m *RXSigReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RXSigReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RXSigReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RXSigReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RXSigReport.Merge(m, src)
}
func (m *RXSigReport) XXX_Size() int {
	return m.Size()
}
func (m *RXSigReport) XXX_DiscardUnknown() {
	xxx_messageInfo_RXSigReport.DiscardUnknown(m)
}

var xxx_messageInfo_RXSigReport proto.InternalMessageInfo

func (m *RXSigReport) GetPciArfcn() *PCIARFCN {
	if m != nil {
		return m.PciArfcn
	}
	return nil
}

func (m *RXSigReport) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RXSigReport) GetRsrp() string {
	if m != nil {
		return m.Rsrp
	}
	return ""
}

func (m *RXSigReport) GetRsrq() string {
	if m != nil {
		return m.Rsrq
	}
	return ""
}

// RxSigMeasReport message
type RxSigMeasReport struct {
	Crnti          []string       `protobuf:"bytes,1,rep,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi           *ECGI          `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	CellMeasReport []*RXSigReport `protobuf:"bytes,3,rep,name=cellMeasReport,proto3" json:"cellMeasReport,omitempty"`
}

func (m *RxSigMeasReport) Reset()         { *m = RxSigMeasReport{} }
func (m *RxSigMeasReport) String() string { return proto.CompactTextString(m) }
func (*RxSigMeasReport) ProtoMessage()    {}
func (*RxSigMeasReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{43}
}
func (m *RxSigMeasReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RxSigMeasReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RxSigMeasReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RxSigMeasReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RxSigMeasReport.Merge(m, src)
}
func (m *RxSigMeasReport) XXX_Size() int {
	return m.Size()
}
func (m *RxSigMeasReport) XXX_DiscardUnknown() {
	xxx_messageInfo_RxSigMeasReport.DiscardUnknown(m)
}

var xxx_messageInfo_RxSigMeasReport proto.InternalMessageInfo

func (m *RxSigMeasReport) GetCrnti() []string {
	if m != nil {
		return m.Crnti
	}
	return nil
}

func (m *RxSigMeasReport) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RxSigMeasReport) GetCellMeasReport() []*RXSigReport {
	if m != nil {
		return m.CellMeasReport
	}
	return nil
}

type L2MeasConfig struct {
	RadioMeasReportPerUe   L2MeasReportInterval `protobuf:"varint,1,opt,name=radioMeasReportPerUe,proto3,enum=interface.e2.L2MeasReportInterval" json:"radioMeasReportPerUe,omitempty"`
	RadioMeasReportPerCell L2MeasReportInterval `protobuf:"varint,2,opt,name=radioMeasReportPerCell,proto3,enum=interface.e2.L2MeasReportInterval" json:"radioMeasReportPerCell,omitempty"`
	SchedMeasReportPerUe   L2MeasReportInterval `protobuf:"varint,3,opt,name=schedMeasReportPerUe,proto3,enum=interface.e2.L2MeasReportInterval" json:"schedMeasReportPerUe,omitempty"`
	SchedMeasReportPerCell L2MeasReportInterval `protobuf:"varint,4,opt,name=schedMeasReportPerCell,proto3,enum=interface.e2.L2MeasReportInterval" json:"schedMeasReportPerCell,omitempty"`
	PdcpMeasReportPerUe    L2MeasReportInterval `protobuf:"varint,5,opt,name=pdcpMeasReportPerUe,proto3,enum=interface.e2.L2MeasReportInterval" json:"pdcpMeasReportPerUe,omitempty"`
}

func (m *L2MeasConfig) Reset()         { *m = L2MeasConfig{} }
func (m *L2MeasConfig) String() string { return proto.CompactTextString(m) }
func (*L2MeasConfig) ProtoMessage()    {}
func (*L2MeasConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{44}
}
func (m *L2MeasConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2MeasConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2MeasConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2MeasConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2MeasConfig.Merge(m, src)
}
func (m *L2MeasConfig) XXX_Size() int {
	return m.Size()
}
func (m *L2MeasConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_L2MeasConfig.DiscardUnknown(m)
}

var xxx_messageInfo_L2MeasConfig proto.InternalMessageInfo

func (m *L2MeasConfig) GetRadioMeasReportPerUe() L2MeasReportInterval {
	if m != nil {
		return m.RadioMeasReportPerUe
	}
	return L2MeasReportInterval_NO_REPORT
}

func (m *L2MeasConfig) GetRadioMeasReportPerCell() L2MeasReportInterval {
	if m != nil {
		return m.RadioMeasReportPerCell
	}
	return L2MeasReportInterval_NO_REPORT
}

func (m *L2MeasConfig) GetSchedMeasReportPerUe() L2MeasReportInterval {
	if m != nil {
		return m.SchedMeasReportPerUe
	}
	return L2MeasReportInterval_NO_REPORT
}

func (m *L2MeasConfig) GetSchedMeasReportPerCell() L2MeasReportInterval {
	if m != nil {
		return m.SchedMeasReportPerCell
	}
	return L2MeasReportInterval_NO_REPORT
}

func (m *L2MeasConfig) GetPdcpMeasReportPerUe() L2MeasReportInterval {
	if m != nil {
		return m.PdcpMeasReportPerUe
	}
	return L2MeasReportInterval_NO_REPORT
}

// L2MeasureReports (periodic) messages
type RadioRepPerServCell struct {
	Ecgi          *ECGI    `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	CqiHist       []uint32 `protobuf:"varint,2,rep,packed,name=cqiHist,proto3" json:"cqiHist,omitempty"`
	RiHist        []string `protobuf:"bytes,3,rep,name=riHist,proto3" json:"riHist,omitempty"`
	PuschSinrHist []string `protobuf:"bytes,4,rep,name=puschSinrHist,proto3" json:"puschSinrHist,omitempty"`
	PucchSinrHist []string `protobuf:"bytes,5,rep,name=pucchSinrHist,proto3" json:"pucchSinrHist,omitempty"`
}

func (m *RadioRepPerServCell) Reset()         { *m = RadioRepPerServCell{} }
func (m *RadioRepPerServCell) String() string { return proto.CompactTextString(m) }
func (*RadioRepPerServCell) ProtoMessage()    {}
func (*RadioRepPerServCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{45}
}
func (m *RadioRepPerServCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RadioRepPerServCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RadioRepPerServCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RadioRepPerServCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadioRepPerServCell.Merge(m, src)
}
func (m *RadioRepPerServCell) XXX_Size() int {
	return m.Size()
}
func (m *RadioRepPerServCell) XXX_DiscardUnknown() {
	xxx_messageInfo_RadioRepPerServCell.DiscardUnknown(m)
}

var xxx_messageInfo_RadioRepPerServCell proto.InternalMessageInfo

func (m *RadioRepPerServCell) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RadioRepPerServCell) GetCqiHist() []uint32 {
	if m != nil {
		return m.CqiHist
	}
	return nil
}

func (m *RadioRepPerServCell) GetRiHist() []string {
	if m != nil {
		return m.RiHist
	}
	return nil
}

func (m *RadioRepPerServCell) GetPuschSinrHist() []string {
	if m != nil {
		return m.PuschSinrHist
	}
	return nil
}

func (m *RadioRepPerServCell) GetPucchSinrHist() []string {
	if m != nil {
		return m.PucchSinrHist
	}
	return nil
}

// RadioMeasReportPerUE message
type RadioMeasReportPerUE struct {
	Ecgi                 *ECGI                  `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti                string                 `protobuf:"bytes,2,opt,name=crnti,proto3" json:"crnti,omitempty"`
	RadioReportServCells []*RadioRepPerServCell `protobuf:"bytes,3,rep,name=radioReportServCells,proto3" json:"radioReportServCells,omitempty"`
}

func (m *RadioMeasReportPerUE) Reset()         { *m = RadioMeasReportPerUE{} }
func (m *RadioMeasReportPerUE) String() string { return proto.CompactTextString(m) }
func (*RadioMeasReportPerUE) ProtoMessage()    {}
func (*RadioMeasReportPerUE) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{46}
}
func (m *RadioMeasReportPerUE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RadioMeasReportPerUE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RadioMeasReportPerUE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RadioMeasReportPerUE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadioMeasReportPerUE.Merge(m, src)
}
func (m *RadioMeasReportPerUE) XXX_Size() int {
	return m.Size()
}
func (m *RadioMeasReportPerUE) XXX_DiscardUnknown() {
	xxx_messageInfo_RadioMeasReportPerUE.DiscardUnknown(m)
}

var xxx_messageInfo_RadioMeasReportPerUE proto.InternalMessageInfo

func (m *RadioMeasReportPerUE) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RadioMeasReportPerUE) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *RadioMeasReportPerUE) GetRadioReportServCells() []*RadioRepPerServCell {
	if m != nil {
		return m.RadioReportServCells
	}
	return nil
}

// RadioMeasReportPerCell message
type RadioMeasReportPerCell struct {
	Ecgi               *ECGI    `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	PuschIntfPwrHist   []uint32 `protobuf:"varint,2,rep,packed,name=puschIntfPwrHist,proto3" json:"puschIntfPwrHist,omitempty"`
	PucchIntfPowerHist []uint32 `protobuf:"varint,3,rep,packed,name=pucchIntfPowerHist,proto3" json:"pucchIntfPowerHist,omitempty"`
}

func (m *RadioMeasReportPerCell) Reset()         { *m = RadioMeasReportPerCell{} }
func (m *RadioMeasReportPerCell) String() string { return proto.CompactTextString(m) }
func (*RadioMeasReportPerCell) ProtoMessage()    {}
func (*RadioMeasReportPerCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{47}
}
func (m *RadioMeasReportPerCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RadioMeasReportPerCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RadioMeasReportPerCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RadioMeasReportPerCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadioMeasReportPerCell.Merge(m, src)
}
func (m *RadioMeasReportPerCell) XXX_Size() int {
	return m.Size()
}
func (m *RadioMeasReportPerCell) XXX_DiscardUnknown() {
	xxx_messageInfo_RadioMeasReportPerCell.DiscardUnknown(m)
}

var xxx_messageInfo_RadioMeasReportPerCell proto.InternalMessageInfo

func (m *RadioMeasReportPerCell) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RadioMeasReportPerCell) GetPuschIntfPwrHist() []uint32 {
	if m != nil {
		return m.PuschIntfPwrHist
	}
	return nil
}

func (m *RadioMeasReportPerCell) GetPucchIntfPowerHist() []uint32 {
	if m != nil {
		return m.PucchIntfPowerHist
	}
	return nil
}

type PRBUsage struct {
	PrbUsageDl []string `protobuf:"bytes,1,rep,name=prbUsageDl,proto3" json:"prbUsageDl,omitempty"`
	PrbUsageUl []string `protobuf:"bytes,2,rep,name=prbUsageUl,proto3" json:"prbUsageUl,omitempty"`
}

func (m *PRBUsage) Reset()         { *m = PRBUsage{} }
func (m *PRBUsage) String() string { return proto.CompactTextString(m) }
func (*PRBUsage) ProtoMessage()    {}
func (*PRBUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{48}
}
func (m *PRBUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PRBUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PRBUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PRBUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PRBUsage.Merge(m, src)
}
func (m *PRBUsage) XXX_Size() int {
	return m.Size()
}
func (m *PRBUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_PRBUsage.DiscardUnknown(m)
}

var xxx_messageInfo_PRBUsage proto.InternalMessageInfo

func (m *PRBUsage) GetPrbUsageDl() []string {
	if m != nil {
		return m.PrbUsageDl
	}
	return nil
}

func (m *PRBUsage) GetPrbUsageUl() []string {
	if m != nil {
		return m.PrbUsageUl
	}
	return nil
}

type SchedMeasRepPerServCell struct {
	Ecgi           *ECGI     `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	QciVals        []string  `protobuf:"bytes,2,rep,name=qciVals,proto3" json:"qciVals,omitempty"`
	PrbUsage       *PRBUsage `protobuf:"bytes,3,opt,name=prbUsage,proto3" json:"prbUsage,omitempty"`
	McsDl          []string  `protobuf:"bytes,4,rep,name=mcsDl,proto3" json:"mcsDl,omitempty"`
	NumSchedTtisDl []string  `protobuf:"bytes,5,rep,name=numSchedTtisDl,proto3" json:"numSchedTtisDl,omitempty"`
	McsUl          []string  `protobuf:"bytes,6,rep,name=mcsUl,proto3" json:"mcsUl,omitempty"`
	NumSchedTtisUl []string  `protobuf:"bytes,7,rep,name=numSchedTtisUl,proto3" json:"numSchedTtisUl,omitempty"`
	RankDl1        []string  `protobuf:"bytes,8,rep,name=rankDl1,proto3" json:"rankDl1,omitempty"`
	RankDl2        []string  `protobuf:"bytes,9,rep,name=rankDl2,proto3" json:"rankDl2,omitempty"`
}

func (m *SchedMeasRepPerServCell) Reset()         { *m = SchedMeasRepPerServCell{} }
func (m *SchedMeasRepPerServCell) String() string { return proto.CompactTextString(m) }
func (*SchedMeasRepPerServCell) ProtoMessage()    {}
func (*SchedMeasRepPerServCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{49}
}
func (m *SchedMeasRepPerServCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedMeasRepPerServCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedMeasRepPerServCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedMeasRepPerServCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedMeasRepPerServCell.Merge(m, src)
}
func (m *SchedMeasRepPerServCell) XXX_Size() int {
	return m.Size()
}
func (m *SchedMeasRepPerServCell) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedMeasRepPerServCell.DiscardUnknown(m)
}

var xxx_messageInfo_SchedMeasRepPerServCell proto.InternalMessageInfo

func (m *SchedMeasRepPerServCell) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetQciVals() []string {
	if m != nil {
		return m.QciVals
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetPrbUsage() *PRBUsage {
	if m != nil {
		return m.PrbUsage
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetMcsDl() []string {
	if m != nil {
		return m.McsDl
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetNumSchedTtisDl() []string {
	if m != nil {
		return m.NumSchedTtisDl
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetMcsUl() []string {
	if m != nil {
		return m.McsUl
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetNumSchedTtisUl() []string {
	if m != nil {
		return m.NumSchedTtisUl
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetRankDl1() []string {
	if m != nil {
		return m.RankDl1
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetRankDl2() []string {
	if m != nil {
		return m.RankDl2
	}
	return nil
}

// SchedMeasReportPerUE message
type SchedMeasReportPerUE struct {
	Ecgi                 *ECGI                      `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti                string                     `protobuf:"bytes,2,opt,name=crnti,proto3" json:"crnti,omitempty"`
	SchedReportServCells []*SchedMeasRepPerServCell `protobuf:"bytes,3,rep,name=schedReportServCells,proto3" json:"schedReportServCells,omitempty"`
}

func (m *SchedMeasReportPerUE) Reset()         { *m = SchedMeasReportPerUE{} }
func (m *SchedMeasReportPerUE) String() string { return proto.CompactTextString(m) }
func (*SchedMeasReportPerUE) ProtoMessage()    {}
func (*SchedMeasReportPerUE) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{50}
}
func (m *SchedMeasReportPerUE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedMeasReportPerUE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedMeasReportPerUE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedMeasReportPerUE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedMeasReportPerUE.Merge(m, src)
}
func (m *SchedMeasReportPerUE) XXX_Size() int {
	return m.Size()
}
func (m *SchedMeasReportPerUE) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedMeasReportPerUE.DiscardUnknown(m)
}

var xxx_messageInfo_SchedMeasReportPerUE proto.InternalMessageInfo

func (m *SchedMeasReportPerUE) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *SchedMeasReportPerUE) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *SchedMeasReportPerUE) GetSchedReportServCells() []*SchedMeasRepPerServCell {
	if m != nil {
		return m.SchedReportServCells
	}
	return nil
}

// SchedMeasReportPerCell message
type SchedMeasReportPerCell struct {
	Ecgi          *ECGI     `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	QciVals       []string  `protobuf:"bytes,2,rep,name=qciVals,proto3" json:"qciVals,omitempty"`
	PrbUsagePcell *PRBUsage `protobuf:"bytes,3,opt,name=prbUsagePcell,proto3" json:"prbUsagePcell,omitempty"`
	PrbUsageScell *PRBUsage `protobuf:"bytes,4,opt,name=prbUsageScell,proto3" json:"prbUsageScell,omitempty"`
}

func (m *SchedMeasReportPerCell) Reset()         { *m = SchedMeasReportPerCell{} }
func (m *SchedMeasReportPerCell) String() string { return proto.CompactTextString(m) }
func (*SchedMeasReportPerCell) ProtoMessage()    {}
func (*SchedMeasReportPerCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{51}
}
func (m *SchedMeasReportPerCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedMeasReportPerCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedMeasReportPerCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedMeasReportPerCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedMeasReportPerCell.Merge(m, src)
}
func (m *SchedMeasReportPerCell) XXX_Size() int {
	return m.Size()
}
func (m *SchedMeasReportPerCell) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedMeasReportPerCell.DiscardUnknown(m)
}

var xxx_messageInfo_SchedMeasReportPerCell proto.InternalMessageInfo

func (m *SchedMeasReportPerCell) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *SchedMeasReportPerCell) GetQciVals() []string {
	if m != nil {
		return m.QciVals
	}
	return nil
}

func (m *SchedMeasReportPerCell) GetPrbUsagePcell() *PRBUsage {
	if m != nil {
		return m.PrbUsagePcell
	}
	return nil
}

func (m *SchedMeasReportPerCell) GetPrbUsageScell() *PRBUsage {
	if m != nil {
		return m.PrbUsageScell
	}
	return nil
}

// PdcpMeasReportPerUE message
type PDCPMeasReportPerUe struct {
	Ecgi             *ECGI    `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti            string   `protobuf:"bytes,2,opt,name=crnti,proto3" json:"crnti,omitempty"`
	QciVals          []string `protobuf:"bytes,3,rep,name=qciVals,proto3" json:"qciVals,omitempty"`
	DataVolDl        []uint32 `protobuf:"varint,4,rep,packed,name=dataVolDl,proto3" json:"dataVolDl,omitempty"`
	DataVolUl        []uint32 `protobuf:"varint,5,rep,packed,name=dataVolUl,proto3" json:"dataVolUl,omitempty"`
	PktDelayDl       []uint32 `protobuf:"varint,6,rep,packed,name=pktDelayDl,proto3" json:"pktDelayDl,omitempty"`
	PktDiscardRateDl []uint32 `protobuf:"varint,7,rep,packed,name=pktDiscardRateDl,proto3" json:"pktDiscardRateDl,omitempty"`
	PktLossRateDl    []uint32 `protobuf:"varint,8,rep,packed,name=pktLossRateDl,proto3" json:"pktLossRateDl,omitempty"`
	PktLossRateUl    []uint32 `protobuf:"varint,9,rep,packed,name=pktLossRateUl,proto3" json:"pktLossRateUl,omitempty"`
	ThroughputDl     []uint32 `protobuf:"varint,10,rep,packed,name=throughputDl,proto3" json:"throughputDl,omitempty"`
	ThroughputUl     []uint32 `protobuf:"varint,11,rep,packed,name=throughputUl,proto3" json:"throughputUl,omitempty"`
}

func (m *PDCPMeasReportPerUe) Reset()         { *m = PDCPMeasReportPerUe{} }
func (m *PDCPMeasReportPerUe) String() string { return proto.CompactTextString(m) }
func (*PDCPMeasReportPerUe) ProtoMessage()    {}
func (*PDCPMeasReportPerUe) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{52}
}
func (m *PDCPMeasReportPerUe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PDCPMeasReportPerUe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PDCPMeasReportPerUe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PDCPMeasReportPerUe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PDCPMeasReportPerUe.Merge(m, src)
}
func (m *PDCPMeasReportPerUe) XXX_Size() int {
	return m.Size()
}
func (m *PDCPMeasReportPerUe) XXX_DiscardUnknown() {
	xxx_messageInfo_PDCPMeasReportPerUe.DiscardUnknown(m)
}

var xxx_messageInfo_PDCPMeasReportPerUe proto.InternalMessageInfo

func (m *PDCPMeasReportPerUe) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *PDCPMeasReportPerUe) GetQciVals() []string {
	if m != nil {
		return m.QciVals
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetDataVolDl() []uint32 {
	if m != nil {
		return m.DataVolDl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetDataVolUl() []uint32 {
	if m != nil {
		return m.DataVolUl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetPktDelayDl() []uint32 {
	if m != nil {
		return m.PktDelayDl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetPktDiscardRateDl() []uint32 {
	if m != nil {
		return m.PktDiscardRateDl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetPktLossRateDl() []uint32 {
	if m != nil {
		return m.PktLossRateDl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetPktLossRateUl() []uint32 {
	if m != nil {
		return m.PktLossRateUl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetThroughputDl() []uint32 {
	if m != nil {
		return m.ThroughputDl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetThroughputUl() []uint32 {
	if m != nil {
		return m.ThroughputUl
	}
	return nil
}

// RRMConfig message
type RRMConfig struct {
	Ecgi              *ECGI     `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti             []string  `protobuf:"bytes,2,rep,name=crnti,proto3" json:"crnti,omitempty"`
	PciArfcn          *PCIARFCN `protobuf:"bytes,3,opt,name=pciArfcn,proto3" json:"pciArfcn,omitempty"`
	PA                []XICICPA `protobuf:"varint,4,rep,packed,name=pA,proto3,enum=interface.e2.XICICPA" json:"pA,omitempty"`
	StartPrbDl        []uint32  `protobuf:"varint,5,rep,packed,name=startPrbDl,proto3" json:"startPrbDl,omitempty"`
	EndPrbDl          []uint32  `protobuf:"varint,6,rep,packed,name=endPrbDl,proto3" json:"endPrbDl,omitempty"`
	SubFrameBitmaskDl []string  `protobuf:"bytes,7,rep,name=subFrameBitmaskDl,proto3" json:"subFrameBitmaskDl,omitempty"`
	P0UePusch         []uint32  `protobuf:"varint,8,rep,packed,name=p0UePusch,proto3" json:"p0UePusch,omitempty"`
	StartPrbUl        []uint32  `protobuf:"varint,9,rep,packed,name=startPrbUl,proto3" json:"startPrbUl,omitempty"`
	EndPrbUl          []uint32  `protobuf:"varint,10,rep,packed,name=endPrbUl,proto3" json:"endPrbUl,omitempty"`
	SubFrameBitmaskUl []string  `protobuf:"bytes,11,rep,name=subFrameBitmaskUl,proto3" json:"subFrameBitmaskUl,omitempty"`
}

func (m *RRMConfig) Reset()         { *m = RRMConfig{} }
func (m *RRMConfig) String() string { return proto.CompactTextString(m) }
func (*RRMConfig) ProtoMessage()    {}
func (*RRMConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{53}
}
func (m *RRMConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RRMConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RRMConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RRMConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RRMConfig.Merge(m, src)
}
func (m *RRMConfig) XXX_Size() int {
	return m.Size()
}
func (m *RRMConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RRMConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RRMConfig proto.InternalMessageInfo

func (m *RRMConfig) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RRMConfig) GetCrnti() []string {
	if m != nil {
		return m.Crnti
	}
	return nil
}

func (m *RRMConfig) GetPciArfcn() *PCIARFCN {
	if m != nil {
		return m.PciArfcn
	}
	return nil
}

func (m *RRMConfig) GetPA() []XICICPA {
	if m != nil {
		return m.PA
	}
	return nil
}

func (m *RRMConfig) GetStartPrbDl() []uint32 {
	if m != nil {
		return m.StartPrbDl
	}
	return nil
}

func (m *RRMConfig) GetEndPrbDl() []uint32 {
	if m != nil {
		return m.EndPrbDl
	}
	return nil
}

func (m *RRMConfig) GetSubFrameBitmaskDl() []string {
	if m != nil {
		return m.SubFrameBitmaskDl
	}
	return nil
}

func (m *RRMConfig) GetP0UePusch() []uint32 {
	if m != nil {
		return m.P0UePusch
	}
	return nil
}

func (m *RRMConfig) GetStartPrbUl() []uint32 {
	if m != nil {
		return m.StartPrbUl
	}
	return nil
}

func (m *RRMConfig) GetEndPrbUl() []uint32 {
	if m != nil {
		return m.EndPrbUl
	}
	return nil
}

func (m *RRMConfig) GetSubFrameBitmaskUl() []string {
	if m != nil {
		return m.SubFrameBitmaskUl
	}
	return nil
}

// RRMConfigStatus message
type RRMConfigStatus struct {
	Ecgi   *ECGI              `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti  []string           `protobuf:"bytes,2,rep,name=crnti,proto3" json:"crnti,omitempty"`
	Status []SuccessOrFailure `protobuf:"varint,3,rep,packed,name=status,proto3,enum=interface.e2.SuccessOrFailure" json:"status,omitempty"`
}

func (m *RRMConfigStatus) Reset()         { *m = RRMConfigStatus{} }
func (m *RRMConfigStatus) String() string { return proto.CompactTextString(m) }
func (*RRMConfigStatus) ProtoMessage()    {}
func (*RRMConfigStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{54}
}
func (m *RRMConfigStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RRMConfigStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RRMConfigStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RRMConfigStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RRMConfigStatus.Merge(m, src)
}
func (m *RRMConfigStatus) XXX_Size() int {
	return m.Size()
}
func (m *RRMConfigStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RRMConfigStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RRMConfigStatus proto.InternalMessageInfo

func (m *RRMConfigStatus) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RRMConfigStatus) GetCrnti() []string {
	if m != nil {
		return m.Crnti
	}
	return nil
}

func (m *RRMConfigStatus) GetStatus() []SuccessOrFailure {
	if m != nil {
		return m.Status
	}
	return nil
}

type CACap struct {
	Band              string       `protobuf:"bytes,1,opt,name=band,proto3" json:"band,omitempty"`
	Caclassdl         CACapClassDl `protobuf:"varint,2,opt,name=caclassdl,proto3,enum=interface.e2.CACapClassDl" json:"caclassdl,omitempty"`
	Caclassul         CACapClassUl `protobuf:"varint,3,opt,name=caclassul,proto3,enum=interface.e2.CACapClassUl" json:"caclassul,omitempty"`
	CrossCarrierSched string       `protobuf:"bytes,4,opt,name=crossCarrierSched,proto3" json:"crossCarrierSched,omitempty"`
}

func (m *CACap) Reset()         { *m = CACap{} }
func (m *CACap) String() string { return proto.CompactTextString(m) }
func (*CACap) ProtoMessage()    {}
func (*CACap) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{55}
}
func (m *CACap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CACap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CACap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CACap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CACap.Merge(m, src)
}
func (m *CACap) XXX_Size() int {
	return m.Size()
}
func (m *CACap) XXX_DiscardUnknown() {
	xxx_messageInfo_CACap.DiscardUnknown(m)
}

var xxx_messageInfo_CACap proto.InternalMessageInfo

func (m *CACap) GetBand() string {
	if m != nil {
		return m.Band
	}
	return ""
}

func (m *CACap) GetCaclassdl() CACapClassDl {
	if m != nil {
		return m.Caclassdl
	}
	return CACapClassDl_CACAP_CLASSDL_A
}

func (m *CACap) GetCaclassul() CACapClassUl {
	if m != nil {
		return m.Caclassul
	}
	return CACapClassUl_CACAP_CLASSUL_A
}

func (m *CACap) GetCrossCarrierSched() string {
	if m != nil {
		return m.CrossCarrierSched
	}
	return ""
}

type DCCap struct {
	DrbTypeSplit DCCapDrbType `protobuf:"varint,1,opt,name=drbTypeSplit,proto3,enum=interface.e2.DCCapDrbType" json:"drbTypeSplit,omitempty"`
}

func (m *DCCap) Reset()         { *m = DCCap{} }
func (m *DCCap) String() string { return proto.CompactTextString(m) }
func (*DCCap) ProtoMessage()    {}
func (*DCCap) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{56}
}
func (m *DCCap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DCCap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DCCap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DCCap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DCCap.Merge(m, src)
}
func (m *DCCap) XXX_Size() int {
	return m.Size()
}
func (m *DCCap) XXX_DiscardUnknown() {
	xxx_messageInfo_DCCap.DiscardUnknown(m)
}

var xxx_messageInfo_DCCap proto.InternalMessageInfo

func (m *DCCap) GetDrbTypeSplit() DCCapDrbType {
	if m != nil {
		return m.DrbTypeSplit
	}
	return DCCapDrbType_DCCAP_DRBTYPE_SUPPORTED
}

// UECapabilityEnqyuiry message
type UECapabilityEnquiry struct {
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi  *ECGI  `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
}

func (m *UECapabilityEnquiry) Reset()         { *m = UECapabilityEnquiry{} }
func (m *UECapabilityEnquiry) String() string { return proto.CompactTextString(m) }
func (*UECapabilityEnquiry) ProtoMessage()    {}
func (*UECapabilityEnquiry) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{57}
}
func (m *UECapabilityEnquiry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UECapabilityEnquiry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UECapabilityEnquiry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UECapabilityEnquiry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UECapabilityEnquiry.Merge(m, src)
}
func (m *UECapabilityEnquiry) XXX_Size() int {
	return m.Size()
}
func (m *UECapabilityEnquiry) XXX_DiscardUnknown() {
	xxx_messageInfo_UECapabilityEnquiry.DiscardUnknown(m)
}

var xxx_messageInfo_UECapabilityEnquiry proto.InternalMessageInfo

func (m *UECapabilityEnquiry) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UECapabilityEnquiry) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

// UECapabilityInfo message
type UECapabilityInfo struct {
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi  *ECGI  `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	CaCap *CACap `protobuf:"bytes,3,opt,name=caCap,proto3" json:"caCap,omitempty"`
	DcCap *DCCap `protobuf:"bytes,4,opt,name=dcCap,proto3" json:"dcCap,omitempty"`
}

func (m *UECapabilityInfo) Reset()         { *m = UECapabilityInfo{} }
func (m *UECapabilityInfo) String() string { return proto.CompactTextString(m) }
func (*UECapabilityInfo) ProtoMessage()    {}
func (*UECapabilityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{58}
}
func (m *UECapabilityInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UECapabilityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UECapabilityInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UECapabilityInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UECapabilityInfo.Merge(m, src)
}
func (m *UECapabilityInfo) XXX_Size() int {
	return m.Size()
}
func (m *UECapabilityInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UECapabilityInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UECapabilityInfo proto.InternalMessageInfo

func (m *UECapabilityInfo) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UECapabilityInfo) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UECapabilityInfo) GetCaCap() *CACap {
	if m != nil {
		return m.CaCap
	}
	return nil
}

func (m *UECapabilityInfo) GetDcCap() *DCCap {
	if m != nil {
		return m.DcCap
	}
	return nil
}

type PropScell struct {
	PciArfcn                *PCIARFCN   `protobuf:"bytes,1,opt,name=pciArfcn,proto3" json:"pciArfcn,omitempty"`
	CrossCarrierSchedEnable string      `protobuf:"bytes,2,opt,name=crossCarrierSchedEnable,proto3" json:"crossCarrierSchedEnable,omitempty"`
	CaDirection             CADirection `protobuf:"varint,3,opt,name=caDirection,proto3,enum=interface.e2.CADirection" json:"caDirection,omitempty"`
	DeactTimer              string      `protobuf:"bytes,4,opt,name=deactTimer,proto3" json:"deactTimer,omitempty"`
}

func (m *PropScell) Reset()         { *m = PropScell{} }
func (m *PropScell) String() string { return proto.CompactTextString(m) }
func (*PropScell) ProtoMessage()    {}
func (*PropScell) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{59}
}
func (m *PropScell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropScell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropScell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropScell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropScell.Merge(m, src)
}
func (m *PropScell) XXX_Size() int {
	return m.Size()
}
func (m *PropScell) XXX_DiscardUnknown() {
	xxx_messageInfo_PropScell.DiscardUnknown(m)
}

var xxx_messageInfo_PropScell proto.InternalMessageInfo

func (m *PropScell) GetPciArfcn() *PCIARFCN {
	if m != nil {
		return m.PciArfcn
	}
	return nil
}

func (m *PropScell) GetCrossCarrierSchedEnable() string {
	if m != nil {
		return m.CrossCarrierSchedEnable
	}
	return ""
}

func (m *PropScell) GetCaDirection() CADirection {
	if m != nil {
		return m.CaDirection
	}
	return CADirection_CADIRECTION_DL
}

func (m *PropScell) GetDeactTimer() string {
	if m != nil {
		return m.DeactTimer
	}
	return ""
}

// ScellAdd message
type ScellAdd struct {
	Crnti      string       `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi       *ECGI        `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	ScellsProp []*PropScell `protobuf:"bytes,3,rep,name=scellsProp,proto3" json:"scellsProp,omitempty"`
}

func (m *ScellAdd) Reset()         { *m = ScellAdd{} }
func (m *ScellAdd) String() string { return proto.CompactTextString(m) }
func (*ScellAdd) ProtoMessage()    {}
func (*ScellAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{60}
}
func (m *ScellAdd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScellAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScellAdd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScellAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScellAdd.Merge(m, src)
}
func (m *ScellAdd) XXX_Size() int {
	return m.Size()
}
func (m *ScellAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_ScellAdd.DiscardUnknown(m)
}

var xxx_messageInfo_ScellAdd proto.InternalMessageInfo

func (m *ScellAdd) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *ScellAdd) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *ScellAdd) GetScellsProp() []*PropScell {
	if m != nil {
		return m.ScellsProp
	}
	return nil
}

// ScellAddStatus message
type ScellAddStatus struct {
	Crnti     string             `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi      *ECGI              `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	ScellsInd []*PCIARFCN        `protobuf:"bytes,3,rep,name=scellsInd,proto3" json:"scellsInd,omitempty"`
	Status    []SuccessOrFailure `protobuf:"varint,4,rep,packed,name=status,proto3,enum=interface.e2.SuccessOrFailure" json:"status,omitempty"`
}

func (m *ScellAddStatus) Reset()         { *m = ScellAddStatus{} }
func (m *ScellAddStatus) String() string { return proto.CompactTextString(m) }
func (*ScellAddStatus) ProtoMessage()    {}
func (*ScellAddStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{61}
}
func (m *ScellAddStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScellAddStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScellAddStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScellAddStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScellAddStatus.Merge(m, src)
}
func (m *ScellAddStatus) XXX_Size() int {
	return m.Size()
}
func (m *ScellAddStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ScellAddStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ScellAddStatus proto.InternalMessageInfo

func (m *ScellAddStatus) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *ScellAddStatus) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *ScellAddStatus) GetScellsInd() []*PCIARFCN {
	if m != nil {
		return m.ScellsInd
	}
	return nil
}

func (m *ScellAddStatus) GetStatus() []SuccessOrFailure {
	if m != nil {
		return m.Status
	}
	return nil
}

// ScellDelete message
type ScellDelete struct {
	Crnti     string      `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi      *ECGI       `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	ScellsInd []*PCIARFCN `protobuf:"bytes,3,rep,name=scellsInd,proto3" json:"scellsInd,omitempty"`
}

func (m *ScellDelete) Reset()         { *m = ScellDelete{} }
func (m *ScellDelete) String() string { return proto.CompactTextString(m) }
func (*ScellDelete) ProtoMessage()    {}
func (*ScellDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{62}
}
func (m *ScellDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScellDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScellDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScellDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScellDelete.Merge(m, src)
}
func (m *ScellDelete) XXX_Size() int {
	return m.Size()
}
func (m *ScellDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_ScellDelete.DiscardUnknown(m)
}

var xxx_messageInfo_ScellDelete proto.InternalMessageInfo

func (m *ScellDelete) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *ScellDelete) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *ScellDelete) GetScellsInd() []*PCIARFCN {
	if m != nil {
		return m.ScellsInd
	}
	return nil
}

// SeNBAdd message
type SeNBAdd struct {
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	MEcgi *ECGI  `protobuf:"bytes,2,opt,name=mEcgi,proto3" json:"mEcgi,omitempty"`
	SEcgi *ECGI  `protobuf:"bytes,3,opt,name=sEcgi,proto3" json:"sEcgi,omitempty"`
}

func (m *SeNBAdd) Reset()         { *m = SeNBAdd{} }
func (m *SeNBAdd) String() string { return proto.CompactTextString(m) }
func (*SeNBAdd) ProtoMessage()    {}
func (*SeNBAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{63}
}
func (m *SeNBAdd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeNBAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeNBAdd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeNBAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeNBAdd.Merge(m, src)
}
func (m *SeNBAdd) XXX_Size() int {
	return m.Size()
}
func (m *SeNBAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_SeNBAdd.DiscardUnknown(m)
}

var xxx_messageInfo_SeNBAdd proto.InternalMessageInfo

func (m *SeNBAdd) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *SeNBAdd) GetMEcgi() *ECGI {
	if m != nil {
		return m.MEcgi
	}
	return nil
}

func (m *SeNBAdd) GetSEcgi() *ECGI {
	if m != nil {
		return m.SEcgi
	}
	return nil
}

// SeNBAddStatus message
type SeNBAddStatus struct {
	Crnti  string           `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi   *ECGI            `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Status SuccessOrFailure `protobuf:"varint,3,opt,name=status,proto3,enum=interface.e2.SuccessOrFailure" json:"status,omitempty"`
}

func (m *SeNBAddStatus) Reset()         { *m = SeNBAddStatus{} }
func (m *SeNBAddStatus) String() string { return proto.CompactTextString(m) }
func (*SeNBAddStatus) ProtoMessage()    {}
func (*SeNBAddStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{64}
}
func (m *SeNBAddStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeNBAddStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeNBAddStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeNBAddStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeNBAddStatus.Merge(m, src)
}
func (m *SeNBAddStatus) XXX_Size() int {
	return m.Size()
}
func (m *SeNBAddStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SeNBAddStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SeNBAddStatus proto.InternalMessageInfo

func (m *SeNBAddStatus) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *SeNBAddStatus) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *SeNBAddStatus) GetStatus() SuccessOrFailure {
	if m != nil {
		return m.Status
	}
	return SuccessOrFailure_SUCCESS
}

// SeNBDelete message
type SeNBDelete struct {
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	MEcgi *ECGI  `protobuf:"bytes,2,opt,name=mEcgi,proto3" json:"mEcgi,omitempty"`
	SEcgi *ECGI  `protobuf:"bytes,3,opt,name=sEcgi,proto3" json:"sEcgi,omitempty"`
}

func (m *SeNBDelete) Reset()         { *m = SeNBDelete{} }
func (m *SeNBDelete) String() string { return proto.CompactTextString(m) }
func (*SeNBDelete) ProtoMessage()    {}
func (*SeNBDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{65}
}
func (m *SeNBDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeNBDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeNBDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeNBDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeNBDelete.Merge(m, src)
}
func (m *SeNBDelete) XXX_Size() int {
	return m.Size()
}
func (m *SeNBDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_SeNBDelete.DiscardUnknown(m)
}

var xxx_messageInfo_SeNBDelete proto.InternalMessageInfo

func (m *SeNBDelete) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *SeNBDelete) GetMEcgi() *ECGI {
	if m != nil {
		return m.MEcgi
	}
	return nil
}

func (m *SeNBDelete) GetSEcgi() *ECGI {
	if m != nil {
		return m.SEcgi
	}
	return nil
}

type TrafficSplitPercentage struct {
	Ecgi                *ECGI  `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	TrafficPercentageDl string `protobuf:"bytes,2,opt,name=trafficPercentageDl,proto3" json:"trafficPercentageDl,omitempty"`
	TrafficPercentageUl string `protobuf:"bytes,3,opt,name=trafficPercentageUl,proto3" json:"trafficPercentageUl,omitempty"`
}

func (m *TrafficSplitPercentage) Reset()         { *m = TrafficSplitPercentage{} }
func (m *TrafficSplitPercentage) String() string { return proto.CompactTextString(m) }
func (*TrafficSplitPercentage) ProtoMessage()    {}
func (*TrafficSplitPercentage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{66}
}
func (m *TrafficSplitPercentage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrafficSplitPercentage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrafficSplitPercentage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrafficSplitPercentage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficSplitPercentage.Merge(m, src)
}
func (m *TrafficSplitPercentage) XXX_Size() int {
	return m.Size()
}
func (m *TrafficSplitPercentage) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficSplitPercentage.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficSplitPercentage proto.InternalMessageInfo

func (m *TrafficSplitPercentage) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *TrafficSplitPercentage) GetTrafficPercentageDl() string {
	if m != nil {
		return m.TrafficPercentageDl
	}
	return ""
}

func (m *TrafficSplitPercentage) GetTrafficPercentageUl() string {
	if m != nil {
		return m.TrafficPercentageUl
	}
	return ""
}

// TrafficSplitConfig message
type TrafficSplitConfig struct {
	Crnti                  string                    `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi                   *ECGI                     `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	TrafficSplitPercentage []*TrafficSplitPercentage `protobuf:"bytes,3,rep,name=trafficSplitPercentage,proto3" json:"trafficSplitPercentage,omitempty"`
}

func (m *TrafficSplitConfig) Reset()         { *m = TrafficSplitConfig{} }
func (m *TrafficSplitConfig) String() string { return proto.CompactTextString(m) }
func (*TrafficSplitConfig) ProtoMessage()    {}
func (*TrafficSplitConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_f91e8a073559d503, []int{67}
}
func (m *TrafficSplitConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrafficSplitConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrafficSplitConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrafficSplitConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficSplitConfig.Merge(m, src)
}
func (m *TrafficSplitConfig) XXX_Size() int {
	return m.Size()
}
func (m *TrafficSplitConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficSplitConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficSplitConfig proto.InternalMessageInfo

func (m *TrafficSplitConfig) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *TrafficSplitConfig) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *TrafficSplitConfig) GetTrafficSplitPercentage() []*TrafficSplitPercentage {
	if m != nil {
		return m.TrafficSplitPercentage
	}
	return nil
}

func init() {
	proto.RegisterEnum("interface.e2.MessageType", MessageType_name, MessageType_value)
	proto.RegisterEnum("interface.e2.AdmEstCause", AdmEstCause_name, AdmEstCause_value)
	proto.RegisterEnum("interface.e2.SuccessOrFailure", SuccessOrFailure_name, SuccessOrFailure_value)
	proto.RegisterEnum("interface.e2.ReconfigCause", ReconfigCause_name, ReconfigCause_value)
	proto.RegisterEnum("interface.e2.ReleaseCause", ReleaseCause_name, ReleaseCause_value)
	proto.RegisterEnum("interface.e2.ERABDirection", ERABDirection_name, ERABDirection_value)
	proto.RegisterEnum("interface.e2.ERABType", ERABType_name, ERABType_value)
	proto.RegisterEnum("interface.e2.ReportParamPR", ReportParamPR_name, ReportParamPR_value)
	proto.RegisterEnum("interface.e2.PerParamReportIntervalMs", PerParamReportIntervalMs_name, PerParamReportIntervalMs_value)
	proto.RegisterEnum("interface.e2.ThresholdEUTRAPR", ThresholdEUTRAPR_name, ThresholdEUTRAPR_value)
	proto.RegisterEnum("interface.e2.TimeToTrigger", TimeToTrigger_name, TimeToTrigger_value)
	proto.RegisterEnum("interface.e2.TriggerQuantity", TriggerQuantity_name, TriggerQuantity_value)
	proto.RegisterEnum("interface.e2.ReportQuality", ReportQuality_name, ReportQuality_value)
	proto.RegisterEnum("interface.e2.MeasIdActionPR", MeasIdActionPR_name, MeasIdActionPR_value)
	proto.RegisterEnum("interface.e2.L2MeasReportInterval", L2MeasReportInterval_name, L2MeasReportInterval_value)
	proto.RegisterEnum("interface.e2.XICICPA", XICICPA_name, XICICPA_value)
	proto.RegisterEnum("interface.e2.CACapClassDl", CACapClassDl_name, CACapClassDl_value)
	proto.RegisterEnum("interface.e2.CACapClassUl", CACapClassUl_name, CACapClassUl_value)
	proto.RegisterEnum("interface.e2.DCCapDrbType", DCCapDrbType_name, DCCapDrbType_value)
	proto.RegisterEnum("interface.e2.CADirection", CADirection_name, CADirection_value)
	proto.RegisterType((*ECGI)(nil), "interface.e2.ECGI")
	proto.RegisterType((*CandScell)(nil), "interface.e2.CandScell")
	proto.RegisterType((*CellConfigRequest)(nil), "interface.e2.CellConfigRequest")
	proto.RegisterType((*CellConfigReport)(nil), "interface.e2.CellConfigReport")
	proto.RegisterType((*UEAdmissionRequest)(nil), "interface.e2.UEAdmissionRequest")
	proto.RegisterType((*UEAdmissionResponse)(nil), "interface.e2.UEAdmissionResponse")
	proto.RegisterType((*UEAdmissionStatus)(nil), "interface.e2.UEAdmissionStatus")
	proto.RegisterType((*UEContextUpdate)(nil), "interface.e2.UEContextUpdate")
	proto.RegisterType((*UEReconfigInd)(nil), "interface.e2.UEReconfigInd")
	proto.RegisterType((*UEReleaseInd)(nil), "interface.e2.UEReleaseInd")
	proto.RegisterType((*UEAMBR)(nil), "interface.e2.UEAMBR")
	proto.RegisterType((*ERABParamsItem)(nil), "interface.e2.ERABParamsItem")
	proto.RegisterType((*ERABResponseItem)(nil), "interface.e2.ERABResponseItem")
	proto.RegisterType((*BearerAdmissionRequest)(nil), "interface.e2.BearerAdmissionRequest")
	proto.RegisterType((*BearerAdmissionResponse)(nil), "interface.e2.BearerAdmissionResponse")
	proto.RegisterType((*BearerAdmissionStatus)(nil), "interface.e2.BearerAdmissionStatus")
	proto.RegisterType((*BearerReleaseInd)(nil), "interface.e2.BearerReleaseInd")
	proto.RegisterType((*HORequest)(nil), "interface.e2.HORequest")
	proto.RegisterType((*HOFailure)(nil), "interface.e2.HOFailure")
	proto.RegisterType((*HOComplete)(nil), "interface.e2.HOComplete")
	proto.RegisterType((*HOCause)(nil), "interface.e2.HOCause")
	proto.RegisterType((*MeasCell)(nil), "interface.e2.MeasCell")
	proto.RegisterType((*MeasObject)(nil), "interface.e2.MeasObject")
	proto.RegisterType((*ReportParamChoice)(nil), "interface.e2.ReportParamChoice")
	proto.RegisterType((*ThresholdEUTRAChoice)(nil), "interface.e2.ThresholdEUTRAChoice")
	proto.RegisterType((*ThreasholdEUTRA)(nil), "interface.e2.ThreasholdEUTRA")
	proto.RegisterType((*PerParam)(nil), "interface.e2.PerParam")
	proto.RegisterType((*A1Param)(nil), "interface.e2.A1Param")
	proto.RegisterType((*A2Param)(nil), "interface.e2.A2Param")
	proto.RegisterType((*A3Param)(nil), "interface.e2.A3Param")
	proto.RegisterType((*A4Param)(nil), "interface.e2.A4Param")
	proto.RegisterType((*A5Param)(nil), "interface.e2.A5Param")
	proto.RegisterType((*A6Param)(nil), "interface.e2.A6Param")
	proto.RegisterType((*ReportParam)(nil), "interface.e2.ReportParam")
	proto.RegisterType((*ReportConfig)(nil), "interface.e2.ReportConfig")
	proto.RegisterType((*AddMeasId)(nil), "interface.e2.AddMeasId")
	proto.RegisterType((*DelMeasId)(nil), "interface.e2.DelMeasId")
	proto.RegisterType((*MeasIdActionChoice)(nil), "interface.e2.MeasIdActionChoice")
	proto.RegisterType((*MeasIdAction)(nil), "interface.e2.MeasIdAction")
	proto.RegisterType((*MeasID)(nil), "interface.e2.MeasID")
	proto.RegisterType((*RRCMeasConfig)(nil), "interface.e2.RRCMeasConfig")
	proto.RegisterType((*PCIARFCN)(nil), "interface.e2.PCIARFCN")
	proto.RegisterType((*RXSigReport)(nil), "interface.e2.RXSigReport")
	proto.RegisterType((*RxSigMeasReport)(nil), "interface.e2.RxSigMeasReport")
	proto.RegisterType((*L2MeasConfig)(nil), "interface.e2.L2MeasConfig")
	proto.RegisterType((*RadioRepPerServCell)(nil), "interface.e2.RadioRepPerServCell")
	proto.RegisterType((*RadioMeasReportPerUE)(nil), "interface.e2.RadioMeasReportPerUE")
	proto.RegisterType((*RadioMeasReportPerCell)(nil), "interface.e2.RadioMeasReportPerCell")
	proto.RegisterType((*PRBUsage)(nil), "interface.e2.PRBUsage")
	proto.RegisterType((*SchedMeasRepPerServCell)(nil), "interface.e2.SchedMeasRepPerServCell")
	proto.RegisterType((*SchedMeasReportPerUE)(nil), "interface.e2.SchedMeasReportPerUE")
	proto.RegisterType((*SchedMeasReportPerCell)(nil), "interface.e2.SchedMeasReportPerCell")
	proto.RegisterType((*PDCPMeasReportPerUe)(nil), "interface.e2.PDCPMeasReportPerUe")
	proto.RegisterType((*RRMConfig)(nil), "interface.e2.RRMConfig")
	proto.RegisterType((*RRMConfigStatus)(nil), "interface.e2.RRMConfigStatus")
	proto.RegisterType((*CACap)(nil), "interface.e2.CACap")
	proto.RegisterType((*DCCap)(nil), "interface.e2.DCCap")
	proto.RegisterType((*UECapabilityEnquiry)(nil), "interface.e2.UECapabilityEnquiry")
	proto.RegisterType((*UECapabilityInfo)(nil), "interface.e2.UECapabilityInfo")
	proto.RegisterType((*PropScell)(nil), "interface.e2.PropScell")
	proto.RegisterType((*ScellAdd)(nil), "interface.e2.ScellAdd")
	proto.RegisterType((*ScellAddStatus)(nil), "interface.e2.ScellAddStatus")
	proto.RegisterType((*ScellDelete)(nil), "interface.e2.ScellDelete")
	proto.RegisterType((*SeNBAdd)(nil), "interface.e2.SeNBAdd")
	proto.RegisterType((*SeNBAddStatus)(nil), "interface.e2.SeNBAddStatus")
	proto.RegisterType((*SeNBDelete)(nil), "interface.e2.SeNBDelete")
	proto.RegisterType((*TrafficSplitPercentage)(nil), "interface.e2.TrafficSplitPercentage")
	proto.RegisterType((*TrafficSplitConfig)(nil), "interface.e2.TrafficSplitConfig")
}

func init() { proto.RegisterFile("api/sb/e2-interface.proto", fileDescriptor_f91e8a073559d503) }

var fileDescriptor_f91e8a073559d503 = []byte{
	// 4326 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x7b, 0xcb, 0x6f, 0x24, 0x59,
	0x56, 0xb7, 0x23, 0xd3, 0xce, 0xc7, 0x49, 0xa7, 0x1d, 0x15, 0x76, 0xbb, 0xb2, 0xaa, 0xab, 0xdd,
	0x35, 0xf1, 0x4d, 0xb7, 0xaa, 0x3d, 0xfd, 0xd5, 0xd8, 0xe9, 0x47, 0x15, 0x3d, 0xd0, 0x10, 0x8e,
	0x08, 0x3b, 0x73, 0x3a, 0x9d, 0x99, 0xbe, 0x11, 0xd1, 0x74, 0x8d, 0x50, 0xa7, 0xc2, 0x99, 0xe1,
	0x72, 0x50, 0x91, 0x8f, 0x8a, 0x88, 0xec, 0xae, 0x92, 0x58, 0x30, 0x42, 0x23, 0x40, 0x1a, 0xde,
	0x12, 0x6c, 0xd8, 0x20, 0x21, 0x58, 0xb0, 0x18, 0xc4, 0x0e, 0x0d, 0xa8, 0x77, 0x80, 0x10, 0x8b,
	0x59, 0x21, 0xd8, 0x8d, 0xba, 0x37, 0xfc, 0x0b, 0x08, 0x09, 0xa1, 0xfb, 0x88, 0x77, 0xb8, 0xca,
	0xd5, 0xae, 0x81, 0x95, 0xe3, 0x3c, 0x7e, 0xe7, 0x9e, 0x7b, 0xce, 0x89, 0x73, 0x1f, 0x91, 0x86,
	0x5b, 0xe6, 0xcc, 0xfe, 0xb6, 0x77, 0xf6, 0x6d, 0xab, 0xf9, 0xff, 0xed, 0x89, 0x6f, 0xb9, 0xe7,
	0xe6, 0xd0, 0xba, 0x3f, 0x73, 0xa7, 0xfe, 0x54, 0x58, 0x8e, 0x18, 0x56, 0x53, 0x6c, 0xc2, 0xa2,
	0x2a, 0x1f, 0xb7, 0x85, 0x0d, 0x28, 0xcd, 0x9c, 0xf1, 0xa4, 0x3d, 0x6a, 0x70, 0x77, 0xb9, 0x7b,
	0x55, 0xc4, 0x28, 0x41, 0x80, 0x45, 0x6b, 0x68, 0x8f, 0x1a, 0x05, 0xc2, 0x25, 0xcf, 0xa2, 0x09,
	0x55, 0xd9, 0x9c, 0x8c, 0xb4, 0xa1, 0xe5, 0x38, 0x02, 0x0f, 0xc5, 0xd9, 0xd0, 0x26, 0xa8, 0x3a,
	0xc2, 0x8f, 0xc2, 0x6d, 0xa8, 0x58, 0xa6, 0x7b, 0x3e, 0x9c, 0x28, 0x0e, 0x83, 0x85, 0xb4, 0xf0,
	0x2e, 0x36, 0xf7, 0xd8, 0x6e, 0x14, 0xef, 0x72, 0xf7, 0x6a, 0x4d, 0xe1, 0x7e, 0xdc, 0x97, 0xfb,
	0xd8, 0x11, 0x44, 0xe4, 0xe2, 0x77, 0xe0, 0x86, 0x6c, 0x39, 0x8e, 0x3c, 0x9d, 0x9c, 0xdb, 0x8f,
	0x91, 0xf5, 0x74, 0x6e, 0x79, 0x7e, 0x08, 0xe6, 0x5e, 0x02, 0xfe, 0xc7, 0x45, 0xe0, 0xe3, 0xe8,
	0xd9, 0xd4, 0xbd, 0x32, 0x38, 0x98, 0x4f, 0x21, 0x9a, 0xcf, 0x03, 0x80, 0x61, 0x30, 0x5d, 0xaf,
	0x51, 0xbc, 0x5b, 0xbc, 0x57, 0x6b, 0xde, 0x4c, 0xe2, 0xc3, 0x70, 0xa0, 0x98, 0x6a, 0x22, 0x10,
	0x8b, 0xa9, 0x40, 0x84, 0x32, 0xc3, 0x69, 0x2c, 0xc5, 0x65, 0x86, 0x23, 0xdc, 0x85, 0x9a, 0x7b,
	0xe6, 0xf5, 0x2d, 0x57, 0xf7, 0x6d, 0xc5, 0x69, 0x94, 0x88, 0x2b, 0x71, 0x56, 0x42, 0xc3, 0x70,
	0x1a, 0xe5, 0x94, 0x86, 0xe1, 0x08, 0x22, 0x2c, 0x4f, 0xe6, 0x63, 0xfd, 0x99, 0x34, 0xf1, 0xad,
	0xc9, 0xc4, 0x6c, 0x54, 0x88, 0x4a, 0x82, 0x27, 0x6c, 0x02, 0x8c, 0xe6, 0x33, 0xc7, 0x7a, 0x76,
	0x32, 0x1d, 0x59, 0x8d, 0x2a, 0xf1, 0x22, 0xc6, 0x11, 0xee, 0x83, 0x30, 0x36, 0x9f, 0x75, 0xe7,
	0x63, 0x79, 0x3a, 0x99, 0x58, 0x43, 0xdf, 0x1a, 0x19, 0x96, 0xd7, 0x00, 0x62, 0x29, 0x47, 0x22,
	0x1c, 0xc0, 0x46, 0x8a, 0x7b, 0x68, 0x99, 0xae, 0xe5, 0x7a, 0x8d, 0x1a, 0xc1, 0x5c, 0x22, 0x8d,
	0x70, 0x86, 0xe5, 0x69, 0xc3, 0x0b, 0x6b, 0x14, 0x4e, 0x7d, 0x39, 0x8e, 0x4b, 0x4b, 0x2f, 0xc3,
	0x19, 0x4e, 0xa3, 0x7e, 0x39, 0xce, 0x70, 0x84, 0x7b, 0xb0, 0x3a, 0x72, 0xce, 0x29, 0x53, 0x9d,
	0x98, 0x67, 0x8e, 0xd5, 0x58, 0x21, 0x93, 0x4f, 0xb3, 0xc5, 0x1f, 0x71, 0x20, 0x18, 0xaa, 0x34,
	0x1a, 0xdb, 0x9e, 0x67, 0x4f, 0x27, 0x41, 0x21, 0xae, 0xc3, 0xd2, 0xd0, 0x9d, 0xf8, 0x36, 0x7b,
	0x57, 0x28, 0x11, 0x56, 0x58, 0xe1, 0x25, 0x15, 0x76, 0x0c, 0x37, 0xcc, 0xc0, 0xa2, 0xea, 0xf9,
	0xb2, 0x39, 0xf7, 0x2c, 0xf2, 0x42, 0xac, 0x34, 0x6f, 0x25, 0x41, 0xd2, 0x68, 0x1c, 0x28, 0xa0,
	0x2c, 0x06, 0xbf, 0x9b, 0xf6, 0xd8, 0xb3, 0x49, 0x6d, 0x2d, 0x22, 0xf2, 0x2c, 0xfe, 0x25, 0x07,
	0x6b, 0x09, 0x8f, 0xbd, 0xd9, 0x74, 0xe2, 0x59, 0xd7, 0x74, 0x19, 0xc1, 0x7a, 0x7c, 0xf8, 0xc0,
	0x2a, 0xf3, 0x7a, 0x33, 0x89, 0xd3, 0xe6, 0xc3, 0xa1, 0xe5, 0x79, 0x3d, 0xf7, 0xc8, 0xb4, 0x9d,
	0xb9, 0x6b, 0xa1, 0x5c, 0xac, 0xf8, 0x67, 0x1c, 0xdc, 0x88, 0x79, 0xaa, 0xf9, 0xa6, 0x3f, 0xf7,
	0xae, 0xe9, 0x67, 0x17, 0x84, 0xf8, 0x58, 0xd4, 0xe6, 0x15, 0xbd, 0xcc, 0x41, 0xe2, 0x68, 0xae,
	0x1a, 0xaa, 0x3c, 0x9d, 0xf8, 0xd6, 0x33, 0xdf, 0x98, 0x8d, 0x4c, 0xff, 0xba, 0x91, 0xbc, 0x0b,
	0xb5, 0xf1, 0xd8, 0x32, 0x2c, 0x6d, 0xc7, 0x9c, 0xb5, 0x47, 0xc4, 0xb5, 0x2a, 0x8a, 0xb3, 0xb0,
	0x86, 0x35, 0x39, 0x0b, 0x35, 0x68, 0xe3, 0x88, 0xb3, 0xc2, 0xbc, 0xd3, 0xbe, 0x41, 0xf3, 0xfe,
	0x37, 0x1c, 0xd4, 0x0d, 0x15, 0x59, 0x43, 0xd2, 0xf3, 0xda, 0x93, 0x11, 0xee, 0x30, 0xc4, 0xb5,
	0x9e, 0x13, 0xf4, 0xf4, 0x90, 0xbe, 0xb2, 0xb7, 0x81, 0x8d, 0xae, 0xf5, 0x39, 0x73, 0x35, 0xa4,
	0x05, 0x09, 0xea, 0x2e, 0x1b, 0x8e, 0x96, 0xf0, 0x22, 0x09, 0xf3, 0x9b, 0x49, 0x63, 0x28, 0xae,
	0x82, 0x92, 0x08, 0xf1, 0x87, 0x1c, 0x2c, 0x63, 0xa7, 0x1d, 0xcb, 0xf4, 0x2c, 0xec, 0xf3, 0xf5,
	0x62, 0xfb, 0x21, 0x2c, 0xbb, 0xd4, 0x56, 0xfc, 0x9d, 0xba, 0x9d, 0x76, 0x28, 0xd2, 0x40, 0x09,
	0x7d, 0xf1, 0x21, 0x94, 0x0c, 0x55, 0x3a, 0x39, 0x44, 0x78, 0x35, 0x34, 0xc7, 0x67, 0xae, 0xe2,
	0x04, 0xab, 0x21, 0xa5, 0x02, 0xbe, 0x11, 0x2c, 0x6c, 0x8c, 0x12, 0x7f, 0xa3, 0x00, 0x2b, 0x2a,
	0x92, 0x0e, 0xfb, 0xa6, 0x6b, 0x8e, 0xbd, 0xb6, 0x6f, 0x8d, 0x85, 0x15, 0x28, 0xd8, 0x41, 0xe0,
	0x0b, 0xf6, 0x48, 0xf8, 0x39, 0xa8, 0x8e, 0x6c, 0xd7, 0x1a, 0xfa, 0xf6, 0x74, 0x42, 0xd0, 0x99,
	0x50, 0x61, 0x03, 0x4a, 0xa0, 0x82, 0x22, 0x6d, 0x61, 0x0b, 0x16, 0xfd, 0xe7, 0xb3, 0x60, 0x3e,
	0x1b, 0x59, 0x94, 0xfe, 0x7c, 0x66, 0x21, 0xa2, 0x83, 0x97, 0xaf, 0xa7, 0x43, 0x9b, 0x55, 0x0d,
	0x7e, 0xc4, 0x1c, 0xd3, 0x9d, 0x91, 0x62, 0xa9, 0x23, 0xfc, 0x88, 0xa3, 0xfc, 0x98, 0x4c, 0xae,
	0x44, 0xa3, 0x4c, 0x08, 0xc6, 0x65, 0xab, 0x09, 0xe5, 0x1a, 0x84, 0x4b, 0x03, 0x51, 0xa1, 0xdc,
	0x71, 0xa0, 0x4b, 0xc3, 0x50, 0x0d, 0xb9, 0x86, 0x23, 0x7e, 0x0a, 0x3c, 0xf6, 0x26, 0x78, 0xc3,
	0x73, 0xc3, 0xf0, 0x01, 0x54, 0x46, 0xd6, 0xd0, 0xf6, 0xa2, 0x28, 0xbc, 0xec, 0xbd, 0x0c, 0xf5,
	0xc5, 0xff, 0xe0, 0x60, 0x83, 0xae, 0x19, 0xaf, 0xb9, 0x23, 0xbf, 0x0f, 0xa5, 0xb9, 0x25, 0x8d,
	0xcf, 0x5c, 0xb6, 0x2f, 0x59, 0x4f, 0x6a, 0xd2, 0xa2, 0x40, 0x4c, 0x87, 0x2d, 0xad, 0xaa, 0x6b,
	0x9e, 0x79, 0x1d, 0xdb, 0xf3, 0x49, 0xac, 0xe9, 0xd2, 0x1a, 0xf2, 0x84, 0x0f, 0xa1, 0x66, 0x61,
	0x82, 0x16, 0x44, 0x63, 0x89, 0x6c, 0x1a, 0xee, 0x64, 0x33, 0x17, 0x15, 0x0c, 0x8a, 0x03, 0xc4,
	0x2f, 0x38, 0xb8, 0x99, 0x99, 0xea, 0x6b, 0x69, 0xe5, 0x69, 0xef, 0x8b, 0x39, 0xde, 0x1f, 0xc2,
	0x32, 0x76, 0x26, 0x6c, 0xf3, 0x8b, 0xc4, 0xfd, 0xcd, 0xac, 0xfb, 0xf1, 0x54, 0xa3, 0x04, 0x46,
	0xfc, 0x5b, 0x0e, 0xde, 0x48, 0xcd, 0xe0, 0xb5, 0xb4, 0xf8, 0xab, 0xf8, 0xff, 0x21, 0x00, 0xf6,
	0x85, 0xb5, 0xff, 0xab, 0x79, 0x1f, 0x43, 0x88, 0xbf, 0xcb, 0x01, 0x4f, 0x7d, 0x7f, 0x6d, 0xbd,
	0xe9, 0x2a, 0x6e, 0x37, 0xa0, 0x8c, 0x9d, 0x68, 0x8f, 0xa8, 0xcf, 0x55, 0x14, 0x90, 0xe2, 0xef,
	0x70, 0x50, 0x6d, 0xf5, 0x5e, 0x5c, 0xec, 0xf7, 0x60, 0x09, 0x8f, 0xa4, 0xbd, 0xc0, 0x15, 0xaa,
	0x10, 0x68, 0xea, 0x2f, 0xd8, 0x85, 0x53, 0x05, 0xdc, 0xef, 0x88, 0xf1, 0xc0, 0x21, 0x46, 0x89,
	0x1e, 0x76, 0x87, 0xbd, 0xa0, 0xd7, 0x76, 0xe7, 0x5d, 0x58, 0xb9, 0x98, 0x32, 0x63, 0x51, 0xe3,
	0xae, 0xa2, 0x14, 0x57, 0xfc, 0x35, 0x80, 0x56, 0x4f, 0x9e, 0x8e, 0x67, 0x8e, 0xe5, 0x5b, 0x89,
	0xa5, 0x89, 0x4b, 0x2d, 0x4d, 0x3f, 0x83, 0x50, 0x88, 0xff, 0xc0, 0x41, 0xb9, 0xd5, 0xa3, 0x1b,
	0xaf, 0xff, 0xbd, 0x04, 0x34, 0xa0, 0x7c, 0x31, 0x8d, 0x96, 0xd7, 0x2a, 0x0a, 0x48, 0xe1, 0x01,
	0x54, 0x2f, 0xa6, 0xba, 0x6b, 0x3f, 0x7e, 0x6c, 0xb9, 0xac, 0xbf, 0xa4, 0x76, 0x8f, 0xe8, 0x13,
	0x2d, 0x38, 0xfd, 0xa0, 0x48, 0x57, 0xec, 0x43, 0xe5, 0xc4, 0x32, 0x3d, 0x39, 0xff, 0xf0, 0xd6,
	0x84, 0x75, 0x7c, 0x78, 0x69, 0x4f, 0x46, 0xf6, 0x67, 0xf6, 0x68, 0x6e, 0x3a, 0xbd, 0xf3, 0x73,
	0xcf, 0xf2, 0xd9, 0x7a, 0x97, 0x2b, 0x13, 0xbf, 0x07, 0x80, 0x2d, 0xf6, 0xce, 0x7e, 0xd5, 0x1a,
	0xfa, 0xb8, 0x66, 0x46, 0xce, 0x91, 0x6b, 0x3d, 0x0d, 0xd6, 0x4e, 0x4a, 0x09, 0x7b, 0x50, 0x1d,
	0xb3, 0x71, 0xbd, 0x46, 0x81, 0x38, 0x9c, 0x5a, 0xca, 0x02, 0xb7, 0x50, 0xa4, 0x28, 0xfe, 0xa0,
	0x08, 0x37, 0xe8, 0x1c, 0x48, 0x67, 0x94, 0x2f, 0xa6, 0xf6, 0xd0, 0x12, 0xf6, 0xa0, 0x32, 0xb3,
	0x5c, 0xc2, 0x61, 0x07, 0xba, 0x94, 0xa9, 0x3e, 0x93, 0xb6, 0x16, 0x50, 0xa8, 0x29, 0xec, 0x40,
	0xd9, 0xdc, 0xa1, 0x20, 0x9a, 0xa2, 0x37, 0x52, 0xdb, 0xed, 0x9d, 0x00, 0x13, 0xe8, 0x11, 0x48,
	0x93, 0x42, 0x8a, 0xb9, 0x90, 0x66, 0x04, 0x69, 0x46, 0x90, 0x5d, 0x0a, 0x59, 0xcc, 0x85, 0xec,
	0x46, 0x90, 0xdd, 0x08, 0xb2, 0x47, 0x21, 0x4b, 0xb9, 0x90, 0xbd, 0x08, 0xb2, 0x17, 0x41, 0xf6,
	0x29, 0xa4, 0x94, 0x0b, 0xd9, 0x8f, 0x20, 0xfb, 0x11, 0xe4, 0x80, 0x42, 0xca, 0xb9, 0x90, 0x83,
	0x08, 0x42, 0x1f, 0x0f, 0x2b, 0x50, 0x1a, 0x92, 0x88, 0x8b, 0x33, 0x58, 0xd7, 0x2f, 0x5c, 0xcb,
	0xbb, 0x98, 0x3a, 0x23, 0xd5, 0xd0, 0x91, 0xc4, 0x32, 0xf1, 0x2e, 0xd4, 0xfd, 0x80, 0x8f, 0x34,
	0xd4, 0xa7, 0x49, 0x6f, 0x2d, 0xa0, 0x24, 0x3b, 0xad, 0x77, 0x4a, 0x0b, 0x2a, 0xad, 0x77, 0x1a,
	0x1b, 0xf1, 0x37, 0x39, 0x58, 0xc5, 0x43, 0x9a, 0xd1, 0x98, 0xc2, 0x43, 0x28, 0xcf, 0x5c, 0xcb,
	0xb3, 0x26, 0x3e, 0x19, 0x27, 0xb3, 0x79, 0x48, 0xba, 0xd8, 0x47, 0x28, 0x50, 0x17, 0x3e, 0x08,
	0xec, 0xb2, 0xd4, 0x8b, 0x2f, 0x02, 0xd2, 0xb9, 0xa1, 0xc0, 0x93, 0x4f, 0xa1, 0x12, 0xd4, 0x93,
	0x80, 0x80, 0x77, 0x49, 0x39, 0xb6, 0x31, 0xfc, 0x33, 0xd3, 0x39, 0xf1, 0x98, 0x2b, 0xef, 0xe6,
	0x57, 0x20, 0x4a, 0x69, 0xa3, 0x0c, 0x5e, 0xfc, 0x2e, 0x94, 0x59, 0xe9, 0x09, 0xbf, 0x08, 0x35,
	0x73, 0x27, 0x74, 0x86, 0xd5, 0xf6, 0x5b, 0x59, 0x5f, 0x63, 0x41, 0x41, 0x71, 0x04, 0xb1, 0xd5,
	0x8c, 0x6c, 0x35, 0x5f, 0xd9, 0x56, 0x84, 0x10, 0xdf, 0x81, 0x32, 0x2b, 0x56, 0xdc, 0x6d, 0xcd,
	0x5d, 0xd6, 0x0a, 0x58, 0xb7, 0x0d, 0x68, 0x32, 0xe4, 0x5e, 0x34, 0xe4, 0xde, 0x2b, 0x0f, 0x19,
	0x21, 0xc4, 0xdf, 0xe3, 0xa0, 0xcc, 0x4a, 0x57, 0x90, 0x60, 0xd9, 0xdc, 0x0f, 0x45, 0x3b, 0x57,
	0xb3, 0x96, 0x80, 0xa4, 0x4c, 0x34, 0x59, 0xee, 0x5f, 0xc1, 0x44, 0x93, 0x04, 0xe1, 0x20, 0x0a,
	0xc2, 0x41, 0x2a, 0x08, 0x8c, 0x16, 0x7f, 0xca, 0x41, 0x2d, 0xd6, 0xa7, 0x84, 0xfd, 0x74, 0xa5,
	0x66, 0xce, 0x45, 0xa1, 0x6e, 0xbc, 0x4c, 0x1f, 0xa4, 0xca, 0xf4, 0xed, 0x4b, 0x51, 0xc9, 0x1a,
	0x15, 0x36, 0x01, 0x2e, 0x9e, 0x7b, 0xbe, 0xe5, 0x5a, 0x9e, 0xed, 0xb1, 0x05, 0x34, 0xc6, 0xc1,
	0xa7, 0x35, 0xdf, 0x1e, 0x5b, 0xfe, 0xd4, 0x67, 0x4b, 0x46, 0xee, 0x69, 0x4d, 0xb7, 0xc7, 0x96,
	0x1e, 0xac, 0x14, 0x28, 0x89, 0x10, 0xff, 0x9d, 0x83, 0x65, 0xea, 0x00, 0xbd, 0x58, 0x13, 0x7e,
	0x01, 0x9f, 0xb7, 0x42, 0x87, 0x3c, 0x96, 0xa0, 0x5b, 0x97, 0xba, 0x8c, 0x12, 0xea, 0xc2, 0x31,
	0xac, 0x32, 0xd3, 0xa7, 0x73, 0x73, 0xe2, 0xdb, 0xfe, 0x73, 0x76, 0x22, 0x48, 0xe7, 0x27, 0xa9,
	0x84, 0xd2, 0x28, 0x7a, 0x12, 0xc5, 0x86, 0x4f, 0xe7, 0xa6, 0x83, 0xcd, 0x14, 0x2f, 0x8f, 0x38,
	0x53, 0x41, 0x49, 0x84, 0xf8, 0x1e, 0x54, 0xa5, 0xd1, 0x08, 0x2f, 0x40, 0xed, 0x91, 0x70, 0x07,
	0xaa, 0x66, 0x40, 0x34, 0x38, 0xb2, 0xf1, 0x89, 0x18, 0x58, 0x55, 0xb1, 0x9c, 0x48, 0x75, 0x14,
	0x10, 0x81, 0x6a, 0xc8, 0xc0, 0x87, 0x72, 0x81, 0x3e, 0x4a, 0xe4, 0x24, 0xc7, 0x7a, 0xe6, 0x83,
	0xa4, 0x7d, 0x2e, 0x7b, 0x9f, 0x18, 0xfa, 0xd2, 0x5a, 0x88, 0x0d, 0x8d, 0x81, 0xd1, 0x68, 0x85,
	0x3c, 0x60, 0xe8, 0x19, 0x06, 0x86, 0xba, 0xc2, 0x5d, 0x80, 0x8b, 0xa9, 0x3f, 0xf5, 0x4d, 0xf7,
	0xb1, 0x45, 0xf7, 0x9e, 0xb8, 0xf5, 0xc6, 0x78, 0xb1, 0xbe, 0xfb, 0xeb, 0x1c, 0x2c, 0xc7, 0x9d,
	0x16, 0x0e, 0xd2, 0xa5, 0x7c, 0x27, 0xbb, 0x6c, 0x07, 0xca, 0xf1, 0x5a, 0x7e, 0x98, 0xaa, 0xe5,
	0xbb, 0x97, 0xc3, 0x52, 0x0d, 0xf7, 0xb7, 0x38, 0x28, 0x11, 0xb1, 0x82, 0xf7, 0xcd, 0xe3, 0x70,
	0x6f, 0x11, 0xde, 0x4e, 0x27, 0x78, 0x78, 0x03, 0xe9, 0xc6, 0xea, 0xb2, 0x1d, 0xdc, 0x56, 0xa7,
	0xb8, 0x42, 0x13, 0x4a, 0x26, 0x3d, 0x7f, 0xd3, 0xb5, 0xfc, 0xf6, 0xe5, 0x0e, 0x21, 0xa6, 0x29,
	0xfe, 0x17, 0x07, 0x75, 0x84, 0x64, 0xb2, 0x35, 0xa1, 0x55, 0x7f, 0xd5, 0x8b, 0xe4, 0x70, 0x93,
	0x58, 0x20, 0x65, 0xc1, 0x36, 0x89, 0x1f, 0x40, 0x2d, 0xf2, 0x3d, 0xb8, 0x4d, 0x6e, 0x64, 0x1d,
	0xa1, 0x0a, 0x28, 0xae, 0x2c, 0xfc, 0x52, 0x50, 0xe7, 0xd4, 0x93, 0xe0, 0x64, 0x73, 0x3b, 0xaf,
	0xce, 0xd9, 0xdd, 0x77, 0x12, 0x20, 0xdc, 0x87, 0xf2, 0x98, 0xcc, 0x32, 0x38, 0x92, 0xae, 0xe7,
	0x84, 0x40, 0x41, 0x81, 0x92, 0xf8, 0x10, 0x2a, 0x7d, 0xb9, 0x2d, 0xa1, 0x23, 0xb9, 0xfb, 0x6a,
	0x17, 0xfd, 0xe2, 0x1f, 0xe0, 0x7e, 0x18, 0x6d, 0x40, 0x85, 0x26, 0x54, 0x66, 0x43, 0x5b, 0xc2,
	0xd2, 0x4b, 0x76, 0x6c, 0x6c, 0x1c, 0x14, 0xea, 0x5d, 0xf9, 0x6c, 0x25, 0xc0, 0xa2, 0xeb, 0xb9,
	0x33, 0xd6, 0xf5, 0xc8, 0x33, 0xe3, 0x3d, 0x65, 0xbb, 0x66, 0xf2, 0x2c, 0xfe, 0x21, 0x07, 0xab,
	0xe8, 0x99, 0x66, 0x3f, 0xc6, 0xd3, 0x64, 0x7e, 0xc5, 0xb6, 0xf2, 0xc5, 0x57, 0x3f, 0xd5, 0x49,
	0xb0, 0x82, 0x77, 0xc4, 0x91, 0x3d, 0x96, 0xd0, 0x17, 0xec, 0xc4, 0x53, 0x00, 0xf1, 0x5f, 0x8a,
	0xb0, 0xdc, 0x69, 0xc6, 0xea, 0xeb, 0x63, 0x58, 0x77, 0xcd, 0x91, 0x3d, 0x8d, 0x74, 0xfa, 0x96,
	0x6b, 0x58, 0xec, 0xdd, 0x4b, 0xed, 0x5b, 0x28, 0x32, 0xb9, 0xc7, 0x40, 0xb9, 0x78, 0xe1, 0x7b,
	0xb0, 0x91, 0xe5, 0xe3, 0x4d, 0x36, 0xeb, 0xba, 0x57, 0xb1, 0x7c, 0x89, 0x05, 0xec, 0xb3, 0x37,
	0xbc, 0xb0, 0x46, 0x69, 0x9f, 0x8b, 0x57, 0xf7, 0x39, 0x0f, 0x8f, 0x7d, 0xce, 0xf2, 0x89, 0xcf,
	0x8b, 0x57, 0xf7, 0x39, 0xdf, 0x82, 0xa0, 0xc3, 0xda, 0x6c, 0x34, 0x9c, 0xa5, 0x5d, 0x5e, 0xba,
	0xb2, 0xe1, 0x3c, 0xb8, 0xf8, 0x63, 0x0e, 0xd6, 0x10, 0x0e, 0x12, 0xb2, 0x66, 0x7d, 0xcb, 0xd5,
	0x2c, 0xf7, 0x33, 0x32, 0xda, 0x55, 0xbb, 0x46, 0x03, 0xca, 0xc3, 0xa7, 0x76, 0xcb, 0xf6, 0x7c,
	0xd2, 0x37, 0xea, 0x28, 0x20, 0xf1, 0xb9, 0xca, 0xa5, 0x82, 0x22, 0x3d, 0x8b, 0x53, 0x4a, 0xf8,
	0x26, 0xd4, 0x67, 0x73, 0x6f, 0x78, 0xa1, 0xd9, 0x13, 0xb7, 0x45, 0xef, 0xa3, 0xb0, 0x38, 0xc9,
	0xa4, 0x5a, 0xc3, 0x98, 0xd6, 0x52, 0xa0, 0x15, 0x63, 0x8a, 0x7f, 0xc5, 0xc1, 0x3a, 0xca, 0x16,
	0x8f, 0xfa, 0x75, 0x9a, 0x5e, 0xec, 0x64, 0x6c, 0xb0, 0x92, 0xa6, 0x16, 0x83, 0x98, 0x04, 0xdd,
	0xef, 0x1b, 0xa9, 0x97, 0x25, 0x1b, 0x3d, 0x94, 0x0b, 0x17, 0xff, 0x94, 0x83, 0x0d, 0x94, 0x5f,
	0x90, 0x57, 0xf5, 0x77, 0x0b, 0x78, 0x12, 0xa7, 0xf6, 0xc4, 0x3f, 0xef, 0x7f, 0xee, 0xc6, 0xe2,
	0x9e, 0xe1, 0x0b, 0xf7, 0x41, 0x20, 0xd1, 0x22, 0xbc, 0xe9, 0xe7, 0x96, 0x1b, 0x26, 0xa3, 0x8e,
	0x72, 0x24, 0xe2, 0x77, 0xa1, 0xd2, 0x47, 0x87, 0x86, 0x67, 0x3e, 0x26, 0xdb, 0xb3, 0x99, 0x7b,
	0x46, 0x9e, 0xc9, 0xa5, 0x32, 0x8e, 0x7d, 0x8c, 0x13, 0x97, 0x93, 0xcb, 0xe5, 0x84, 0xdc, 0x70,
	0xc4, 0x2f, 0x0a, 0x70, 0x53, 0x8b, 0xd5, 0xf1, 0xd7, 0x2c, 0xad, 0xa7, 0x43, 0xfb, 0x63, 0x93,
	0x1d, 0xbf, 0xab, 0x28, 0x20, 0x49, 0x73, 0x66, 0x63, 0xb1, 0xa5, 0x31, 0xdd, 0x9c, 0xd9, 0x3c,
	0x50, 0xa8, 0x47, 0xae, 0x80, 0x87, 0x1e, 0xf9, 0xb2, 0x49, 0x1a, 0x27, 0x21, 0xf0, 0x52, 0x3c,
	0x99, 0x8f, 0x89, 0xa7, 0xba, 0x6f, 0x63, 0x31, 0xad, 0xb3, 0x14, 0x97, 0xa1, 0x0d, 0xa7, 0x51,
	0x0a, 0xd1, 0x46, 0x06, 0x4d, 0xee, 0xa2, 0x33, 0x68, 0xc3, 0xc1, 0x33, 0x71, 0xcd, 0xc9, 0x13,
	0xc5, 0xd9, 0x69, 0x54, 0xe8, 0x4c, 0x18, 0x19, 0x49, 0x9a, 0x8d, 0x6a, 0x5c, 0xd2, 0x14, 0x7f,
	0xc4, 0xc1, 0xba, 0x96, 0xed, 0x31, 0xd7, 0x2d, 0xed, 0x47, 0xac, 0xf3, 0xe5, 0x97, 0xf6, 0x3b,
	0xa9, 0xbb, 0xed, 0xfc, 0x0c, 0xa2, 0x5c, 0x13, 0xe2, 0xbf, 0x72, 0xb0, 0xa1, 0xe5, 0xf7, 0xae,
	0xeb, 0xa7, 0xfc, 0xe7, 0xa1, 0x1e, 0xa4, 0xb2, 0x8f, 0x57, 0xa4, 0x97, 0xe4, 0x3d, 0xa9, 0x1c,
	0x47, 0x93, 0x6f, 0xdd, 0xec, 0xa6, 0xe3, 0xa5, 0x68, 0xa2, 0x2c, 0xfe, 0x76, 0x11, 0xd6, 0xfa,
	0x8a, 0xdc, 0x4f, 0x77, 0xfb, 0xeb, 0x65, 0x22, 0x36, 0xd7, 0x62, 0x72, 0xae, 0x78, 0x93, 0x6e,
	0xfa, 0xe6, 0xc7, 0x53, 0x87, 0x95, 0x6b, 0x1d, 0x45, 0x8c, 0x98, 0xd4, 0xa0, 0xd5, 0x1a, 0x49,
	0x0d, 0xfa, 0x62, 0x3e, 0xf1, 0x15, 0xcb, 0x31, 0x9f, 0x2b, 0xb4, 0x5a, 0xeb, 0x28, 0xc6, 0x21,
	0x0d, 0xe4, 0x89, 0xaf, 0xd8, 0xde, 0xd0, 0x74, 0x47, 0xc8, 0xf4, 0xf1, 0xeb, 0x5d, 0x66, 0x0d,
	0x24, 0xc5, 0x27, 0x3d, 0xf8, 0x89, 0xdf, 0x99, 0x7a, 0x1e, 0x53, 0xac, 0x10, 0xc5, 0x24, 0x33,
	0xa5, 0x45, 0xbe, 0xb1, 0xa4, 0xb5, 0xe8, 0xf7, 0x7d, 0xff, 0xc2, 0x9d, 0xce, 0x1f, 0x5f, 0xcc,
	0xe6, 0xbe, 0xe2, 0x34, 0x80, 0x28, 0x25, 0x78, 0x49, 0x1d, 0xc3, 0x69, 0xd4, 0xd2, 0x3a, 0x86,
	0x23, 0xfe, 0x71, 0x11, 0xaa, 0x08, 0x9d, 0xbc, 0x96, 0xbd, 0x6d, 0x7c, 0x8f, 0x57, 0xbc, 0xe2,
	0x1e, 0xef, 0x1d, 0x28, 0xcc, 0x24, 0x92, 0x94, 0x95, 0xf4, 0x7d, 0xd4, 0x27, 0x6d, 0xb9, 0x2d,
	0xf7, 0x25, 0x54, 0x98, 0x49, 0x38, 0x0d, 0x9e, 0x6f, 0xba, 0x7e, 0xdf, 0x3d, 0x53, 0x82, 0x2c,
	0xc5, 0x38, 0x64, 0x2b, 0x3a, 0x19, 0x51, 0x29, 0x4d, 0x52, 0x48, 0x0b, 0xef, 0xc3, 0x0d, 0x6f,
	0x7e, 0x76, 0xe4, 0x9a, 0x63, 0xeb, 0xd0, 0xf6, 0xc7, 0xa6, 0xf7, 0x44, 0x09, 0x1a, 0x4b, 0x56,
	0x80, 0xcb, 0x61, 0xb6, 0x6d, 0x58, 0x7d, 0xdc, 0xfd, 0x59, 0x82, 0x22, 0x46, 0xdc, 0x8f, 0x30,
	0x33, 0x31, 0x4e, 0xe4, 0x87, 0x11, 0xa4, 0x24, 0xa4, 0x73, 0xfc, 0x60, 0x39, 0xc9, 0xfa, 0x61,
	0x38, 0xe4, 0xfa, 0x2b, 0x4c, 0x0c, 0xfb, 0x72, 0x72, 0xbd, 0xf4, 0x1c, 0x40, 0xc9, 0x0b, 0x3e,
	0x88, 0x17, 0xaf, 0xf0, 0xe1, 0x8d, 0x69, 0x8b, 0x7f, 0xcf, 0xc1, 0x92, 0x2c, 0xc9, 0x26, 0xd9,
	0x54, 0x9f, 0x99, 0x93, 0xe0, 0x10, 0x46, 0x9e, 0x85, 0x87, 0x50, 0x1d, 0x9a, 0x43, 0xc7, 0xf4,
	0xbc, 0x51, 0xb0, 0x93, 0x4c, 0x1d, 0x48, 0x08, 0x56, 0xc6, 0x1a, 0x8a, 0x83, 0x22, 0xe5, 0x18,
	0x72, 0xee, 0xe4, 0x7f, 0xab, 0x8d, 0x90, 0x46, 0x84, 0x9c, 0x93, 0x48, 0x0e, 0xdd, 0xa9, 0xe7,
	0xc9, 0xa6, 0xeb, 0xda, 0x96, 0x4b, 0x9a, 0x24, 0xdb, 0xe9, 0x67, 0x05, 0xe2, 0x31, 0x2c, 0x29,
	0x32, 0x76, 0xff, 0x43, 0x58, 0x1e, 0xb9, 0x67, 0xfa, 0xf3, 0x99, 0xa5, 0xcd, 0x1c, 0x3b, 0x38,
	0xcd, 0xa6, 0xc6, 0x24, 0xaa, 0x0a, 0x55, 0x43, 0x09, 0x7d, 0x51, 0x83, 0x35, 0x43, 0x95, 0xcd,
	0x99, 0x79, 0x66, 0x3b, 0xb6, 0xff, 0x5c, 0x9d, 0x3c, 0x9d, 0xdb, 0xee, 0xf3, 0xeb, 0x7d, 0x18,
	0x12, 0xff, 0x82, 0x03, 0x3e, 0x6e, 0xb5, 0x3d, 0x39, 0x9f, 0x5e, 0xf3, 0x5b, 0xd3, 0x7b, 0xb0,
	0x34, 0x34, 0x65, 0x73, 0xc6, 0x5e, 0xc2, 0xb5, 0x9c, 0xa0, 0x22, 0xaa, 0x81, 0x55, 0x47, 0x43,
	0xac, 0xba, 0x98, 0xa7, 0x4a, 0x62, 0x81, 0xa8, 0x06, 0x5e, 0x8e, 0xaa, 0x7d, 0x77, 0x3a, 0xa3,
	0x3f, 0xfb, 0xfa, 0x3a, 0xe7, 0xb9, 0x87, 0x70, 0x33, 0x93, 0x1d, 0xf6, 0xfb, 0x1b, 0xda, 0xc9,
	0x2f, 0x13, 0x0b, 0xdf, 0x81, 0xda, 0xd0, 0x0c, 0xbf, 0x8d, 0xe7, 0xff, 0x58, 0x46, 0x96, 0xa2,
	0x8f, 0xe7, 0x71, 0x6d, 0xf2, 0x33, 0x27, 0xcb, 0x1c, 0xfa, 0xba, 0x3d, 0x66, 0xf7, 0x5e, 0x55,
	0x14, 0xe3, 0x88, 0xdf, 0xe7, 0xa0, 0x42, 0x26, 0x25, 0x8d, 0xae, 0xfb, 0x95, 0xef, 0x01, 0x80,
	0x47, 0x7e, 0xfb, 0x85, 0x03, 0x95, 0xff, 0x53, 0xb1, 0x30, 0x84, 0x28, 0xa6, 0x2a, 0xfe, 0x1d,
	0x07, 0x2b, 0x81, 0x0f, 0xaf, 0xe5, 0x33, 0xe9, 0x1e, 0x54, 0xa9, 0xf9, 0xf6, 0x64, 0xc4, 0x1c,
	0xb9, 0x2c, 0x41, 0x91, 0x62, 0xac, 0x45, 0x2c, 0xbe, 0x52, 0x8b, 0xf8, 0x3e, 0x07, 0x35, 0xe2,
	0xbe, 0x62, 0x91, 0x8f, 0x73, 0xff, 0x07, 0xbe, 0x8b, 0x1e, 0x94, 0x35, 0xab, 0x7b, 0x78, 0x79,
	0x12, 0xef, 0xc1, 0xd2, 0x58, 0x7d, 0xf1, 0xf8, 0x54, 0x01, 0x6b, 0x7a, 0xea, 0x8b, 0x7f, 0xa6,
	0x48, 0x15, 0xc4, 0x1f, 0x70, 0x50, 0x67, 0xa3, 0xbe, 0x96, 0xb4, 0xc5, 0x7b, 0x34, 0xf7, 0x0a,
	0x09, 0xf8, 0x0c, 0x00, 0xbb, 0xf1, 0xc2, 0xf0, 0xff, 0x2c, 0xe6, 0xff, 0xe7, 0x1c, 0x6c, 0xe8,
	0xae, 0x79, 0x7e, 0x6e, 0x0f, 0x49, 0x8f, 0xec, 0x5b, 0xee, 0xd0, 0x9a, 0xf8, 0xf8, 0x80, 0x70,
	0xd5, 0xc5, 0x6a, 0x1b, 0xd6, 0x7c, 0x6a, 0x21, 0x02, 0x87, 0x17, 0x4a, 0x79, 0xa2, 0x5c, 0x84,
	0xe1, 0xb0, 0xeb, 0x9f, 0x3c, 0x91, 0xf8, 0xd7, 0x1c, 0x08, 0x71, 0x37, 0xd9, 0x76, 0xe7, 0x7a,
	0xb9, 0xfa, 0x15, 0xd8, 0xf0, 0x73, 0xa7, 0xce, 0x6a, 0xf6, 0x9b, 0xe9, 0x6b, 0xec, 0x3c, 0x5d,
	0x74, 0x89, 0x8d, 0xad, 0x7f, 0x2e, 0x41, 0xed, 0xc4, 0xf2, 0xf0, 0xae, 0x19, 0xaf, 0x40, 0xc2,
	0x1a, 0xac, 0x1a, 0xdd, 0x8f, 0xba, 0xbd, 0x5f, 0xee, 0x0e, 0x4e, 0x54, 0x4d, 0x93, 0x8e, 0x55,
	0x7e, 0x41, 0xb8, 0x09, 0x6b, 0xb2, 0xda, 0xe9, 0x0c, 0xe4, 0x5e, 0xf7, 0xa8, 0x7d, 0x3c, 0x40,
	0xea, 0xa9, 0xa1, 0x6a, 0x3a, 0xcf, 0x09, 0x1b, 0x20, 0x24, 0x05, 0xfd, 0x1e, 0xd2, 0xf9, 0x82,
	0xd0, 0x80, 0x75, 0x43, 0x1d, 0x48, 0xca, 0x49, 0x5b, 0xd3, 0xda, 0xbd, 0x6e, 0x88, 0x28, 0x0a,
	0xb7, 0xe0, 0x8d, 0x94, 0x44, 0xeb, 0xf7, 0xba, 0x9a, 0xca, 0x2f, 0xe2, 0x51, 0x12, 0x22, 0x4d,
	0x97, 0x74, 0x43, 0xe3, 0x97, 0x84, 0x37, 0xe0, 0x86, 0xa1, 0xe2, 0x31, 0x74, 0xf5, 0x13, 0x7d,
	0x60, 0xf4, 0x15, 0x49, 0x57, 0xf9, 0x12, 0x71, 0x55, 0x1d, 0x20, 0x95, 0x0d, 0xde, 0xee, 0x2a,
	0x7c, 0x59, 0x10, 0x60, 0x85, 0x30, 0x3b, 0xaa, 0xa4, 0xa9, 0x84, 0x57, 0x11, 0xee, 0x40, 0xe3,
	0x50, 0x95, 0x90, 0x8a, 0x72, 0x3c, 0xaa, 0x0a, 0x6f, 0xc1, 0xad, 0x1c, 0x29, 0xf3, 0x0a, 0x84,
	0x37, 0xe1, 0x66, 0x46, 0xcc, 0x3c, 0xab, 0xe1, 0xf9, 0x33, 0x61, 0x7c, 0xc4, 0x65, 0x61, 0x05,
	0xa0, 0xd5, 0x0b, 0xc7, 0xa8, 0x33, 0xfa, 0x48, 0x6a, 0x77, 0x0c, 0xa4, 0xf2, 0x2b, 0xc2, 0x2a,
	0xd4, 0x5a, 0xbd, 0x81, 0xdc, 0x3b, 0xe9, 0x77, 0x54, 0x5d, 0xe5, 0x57, 0xf1, 0x14, 0xd1, 0x27,
	0x5a, 0xfb, 0x78, 0x70, 0xa2, 0x4a, 0x5a, 0x10, 0x47, 0x1e, 0xcf, 0xa6, 0xd3, 0xa4, 0x3c, 0x3a,
	0x4b, 0xfe, 0x06, 0x9e, 0x0d, 0x92, 0x94, 0x76, 0x2f, 0xae, 0x3a, 0xe8, 0xab, 0x68, 0x60, 0xa8,
	0xbc, 0x20, 0x6c, 0xc2, 0xed, 0x7c, 0x29, 0xce, 0x13, 0xbf, 0x86, 0xd1, 0x9a, 0xdc, 0x52, 0x95,
	0x3c, 0xf4, 0x3a, 0x46, 0xe7, 0x4b, 0x09, 0xfa, 0x0d, 0x1c, 0x0c, 0x7c, 0xa2, 0xca, 0x03, 0x6f,
	0xe0, 0x60, 0xe0, 0x34, 0x49, 0x7d, 0xe9, 0xb0, 0xdd, 0x69, 0xeb, 0x8f, 0x06, 0xed, 0xee, 0x51,
	0x8f, 0xbf, 0xc9, 0x52, 0x1e, 0xe3, 0xab, 0xdd, 0x53, 0xa3, 0x8d, 0x1e, 0xf1, 0x0d, 0xa1, 0x0e,
	0x55, 0x8d, 0x14, 0x90, 0xa4, 0x28, 0xfc, 0x2d, 0x61, 0x1d, 0xf8, 0x90, 0x0c, 0x82, 0x7c, 0x5b,
	0xe0, 0x61, 0x99, 0x72, 0x15, 0x95, 0x44, 0xeb, 0x4d, 0x1c, 0x4e, 0x84, 0x4e, 0x82, 0x90, 0xdc,
	0x21, 0xd1, 0x0b, 0xe9, 0x00, 0xf8, 0x96, 0xb0, 0x0c, 0x15, 0x4d, 0xed, 0x1e, 0x12, 0xe3, 0x9b,
	0xb8, 0x5c, 0x02, 0x2a, 0x50, 0x79, 0x1b, 0x27, 0x82, 0x30, 0x99, 0xe9, 0xbb, 0xb8, 0x72, 0x75,
	0x24, 0x1d, 0x1d, 0xb5, 0xe5, 0x81, 0xd6, 0xef, 0xb4, 0xf5, 0x60, 0x90, 0x6f, 0x60, 0x6b, 0x38,
	0x67, 0x92, 0xa1, 0xa9, 0xbc, 0x88, 0xad, 0x21, 0x24, 0x27, 0x52, 0xf3, 0xff, 0xb6, 0x3e, 0x85,
	0x5a, 0xec, 0xb7, 0xb4, 0x78, 0x76, 0xea, 0x89, 0x8a, 0x8e, 0xd5, 0xae, 0xfc, 0x88, 0x5f, 0x10,
	0x6e, 0x40, 0xbd, 0xd5, 0x3e, 0x6e, 0xb5, 0xfa, 0x03, 0x49, 0x96, 0x55, 0x4d, 0xe3, 0x39, 0xac,
	0x71, 0xa2, 0x07, 0x64, 0x01, 0x6b, 0x9c, 0xf4, 0x06, 0x5a, 0xfb, 0xb8, 0x2b, 0x75, 0x3a, 0xed,
	0xee, 0x31, 0x5f, 0x14, 0x6a, 0x50, 0x3e, 0xe9, 0x0d, 0x14, 0x49, 0x97, 0xf8, 0xc5, 0xad, 0xf7,
	0x81, 0x4f, 0xb7, 0x66, 0xac, 0xa0, 0x19, 0xd4, 0xc0, 0x02, 0x26, 0x82, 0x22, 0xe3, 0xb6, 0x3a,
	0x50, 0x4f, 0xfc, 0x2c, 0x12, 0x07, 0x32, 0x7c, 0x5b, 0x50, 0xe7, 0x88, 0x5f, 0xc0, 0x01, 0x0f,
	0x39, 0xac, 0x40, 0x79, 0x8e, 0xcc, 0x2d, 0xe0, 0xf6, 0xf4, 0x96, 0x8a, 0x34, 0xbe, 0xb0, 0xf5,
	0x11, 0x2c, 0xc7, 0x7f, 0xd3, 0x88, 0xb3, 0x1d, 0xd5, 0xbc, 0x24, 0xeb, 0xed, 0x8f, 0xdb, 0x3a,
	0x9e, 0xe5, 0x2a, 0xd4, 0x02, 0x3e, 0x1e, 0x83, 0xc3, 0x35, 0x1c, 0x30, 0x42, 0x63, 0xef, 0x41,
	0x3d, 0xf1, 0x33, 0x44, 0xa1, 0x04, 0x05, 0xa5, 0xc3, 0x2f, 0xe0, 0xbf, 0x06, 0x76, 0xa1, 0x02,
	0x8b, 0x87, 0x3d, 0xbd, 0xc5, 0x17, 0xb6, 0xb6, 0xa1, 0x12, 0xfc, 0xf6, 0x10, 0x4f, 0x00, 0x3f,
	0x0f, 0x14, 0xf5, 0x48, 0x32, 0x3a, 0x3a, 0xbf, 0x80, 0x8d, 0x33, 0x8e, 0xd2, 0x96, 0x25, 0x5d,
	0x55, 0x78, 0x6e, 0xeb, 0x3f, 0x39, 0x3c, 0xf1, 0xd8, 0x77, 0x4f, 0x5c, 0xb6, 0x41, 0xb1, 0x4a,
	0x48, 0x3a, 0x19, 0xf4, 0xd1, 0xa0, 0xdb, 0xd3, 0x5b, 0x38, 0xc2, 0x0b, 0xf8, 0xfd, 0x4f, 0x0b,
	0x71, 0x49, 0x13, 0x82, 0xe7, 0xf2, 0xb0, 0xd2, 0x0e, 0x15, 0x16, 0x72, 0x85, 0x4d, 0x2a, 0x2c,
	0xe6, 0x0a, 0x77, 0xa9, 0x70, 0x31, 0x57, 0xb8, 0x47, 0x85, 0x4b, 0xb9, 0xc2, 0x7d, 0x2a, 0x2c,
	0xe5, 0x0a, 0x0f, 0xa8, 0xb0, 0xbc, 0xf5, 0xe3, 0x02, 0x34, 0x2e, 0xfb, 0x49, 0x00, 0xce, 0x76,
	0x38, 0xb3, 0xc1, 0x89, 0x36, 0xd8, 0x69, 0x6e, 0xd3, 0x1a, 0x48, 0x70, 0x9b, 0x7b, 0xdb, 0x3c,
	0x97, 0xe1, 0xee, 0x3d, 0xdc, 0xe6, 0x0b, 0x19, 0xee, 0xc1, 0xde, 0x36, 0x5f, 0xc4, 0xaf, 0x5f,
	0xd2, 0xee, 0x76, 0x73, 0x8f, 0x5f, 0xcc, 0xb0, 0x9b, 0xdb, 0x7b, 0x0f, 0x69, 0x37, 0x4f, 0xb0,
	0xf7, 0xb1, 0x1b, 0x25, 0x5c, 0x4f, 0x19, 0x23, 0xdb, 0x7c, 0x19, 0x17, 0x63, 0x8c, 0xdf, 0xee,
	0x0e, 0x76, 0xf8, 0x4a, 0x96, 0x79, 0xc0, 0x57, 0x53, 0xce, 0x61, 0xcd, 0x26, 0x0f, 0x59, 0xee,
	0xee, 0x36, 0x5f, 0xcb, 0x72, 0x0f, 0xb6, 0xf9, 0xe5, 0x2d, 0x07, 0xf8, 0xf4, 0x4f, 0x3b, 0x70,
	0x4b, 0xd4, 0x5b, 0x48, 0xd5, 0x5a, 0xbd, 0x8e, 0x32, 0x20, 0xcc, 0x64, 0xf9, 0xbc, 0x09, 0x37,
	0x73, 0xe4, 0x48, 0x43, 0x7d, 0x5a, 0x3c, 0xf9, 0xc2, 0x53, 0xbe, 0xb0, 0xf5, 0xdf, 0x1c, 0xd4,
	0x13, 0x5f, 0xc2, 0xf1, 0xeb, 0xab, 0xeb, 0xfa, 0xe0, 0x44, 0xc3, 0x79, 0x59, 0x86, 0x0a, 0x25,
	0x48, 0x3e, 0x42, 0xea, 0x60, 0x8f, 0x2f, 0x44, 0xd4, 0x43, 0x1c, 0xff, 0x3a, 0x54, 0x29, 0xb5,
	0xb3, 0xbd, 0xcd, 0x2f, 0xc6, 0xc8, 0x26, 0x8e, 0x77, 0x44, 0x1e, 0xe0, 0x38, 0x87, 0x64, 0x73,
	0xff, 0x80, 0x2f, 0x47, 0xe4, 0x6e, 0x73, 0x9b, 0xaf, 0x44, 0x24, 0xce, 0x77, 0x35, 0x22, 0xf7,
	0x49, 0x2c, 0x43, 0x12, 0xe7, 0xbd, 0x86, 0xdb, 0x70, 0x30, 0x6e, 0x73, 0x8f, 0xae, 0x7a, 0xe1,
	0xc0, 0xdb, 0x74, 0xd5, 0x0b, 0x87, 0xda, 0xe6, 0x57, 0x22, 0x9a, 0xa4, 0x7c, 0x75, 0xeb, 0x5b,
	0xb0, 0x9a, 0xfa, 0xe8, 0x4e, 0x22, 0x70, 0x4a, 0xa3, 0xb7, 0x10, 0x11, 0xa7, 0x3c, 0x87, 0x5b,
	0x46, 0xe2, 0xd3, 0x3a, 0x96, 0xa2, 0xd3, 0x81, 0x26, 0x9d, 0xa8, 0x54, 0x15, 0x9d, 0x0e, 0x48,
	0xcb, 0xe0, 0xb6, 0xfe, 0x88, 0x83, 0x95, 0xe4, 0xd7, 0x62, 0xfc, 0x92, 0x93, 0x56, 0xdd, 0x56,
	0x06, 0xb8, 0x57, 0xf5, 0xba, 0xc9, 0x24, 0xbe, 0x0d, 0x6f, 0x66, 0xc5, 0x92, 0xa2, 0x60, 0x66,
	0x5b, 0xe1, 0xb9, 0x7c, 0x05, 0x45, 0xed, 0x30, 0x85, 0x82, 0x70, 0x17, 0xee, 0x64, 0x15, 0x5a,
	0x3d, 0xbd, 0xa7, 0x4b, 0xe8, 0x58, 0xd5, 0xf9, 0xe2, 0xd6, 0x9f, 0x70, 0xb0, 0x9e, 0xf7, 0x81,
	0x07, 0x47, 0xb5, 0xdb, 0x0b, 0xd6, 0xfc, 0x05, 0xa1, 0x0a, 0x4b, 0xa4, 0xfc, 0x79, 0x8e, 0x3d,
	0xee, 0xe3, 0x37, 0x0f, 0xa0, 0x44, 0xb8, 0x38, 0xdf, 0xf4, 0xb9, 0x49, 0x92, 0x4d, 0x9f, 0xf7,
	0xb7, 0xb7, 0xf9, 0x25, 0xb2, 0x56, 0xb0, 0xb7, 0xaf, 0x84, 0x3b, 0x28, 0xb1, 0x52, 0x26, 0x56,
	0xd8, 0x7b, 0xc3, 0x1e, 0x9b, 0x7c, 0x35, 0x78, 0xdc, 0xe7, 0x61, 0xeb, 0x0b, 0x0e, 0xca, 0xec,
	0x16, 0x0c, 0xbf, 0x86, 0xe4, 0x71, 0xd0, 0x97, 0x06, 0xca, 0x21, 0x7e, 0x35, 0x0c, 0xed, 0x80,
	0x96, 0x79, 0x9a, 0xff, 0xc9, 0x9e, 0xd2, 0xd3, 0x1f, 0x3c, 0xa0, 0xdb, 0xc0, 0x0c, 0x68, 0x97,
	0xb6, 0xc7, 0x0c, 0x7f, 0x87, 0x82, 0x8a, 0x78, 0xb1, 0x8b, 0x0b, 0xf1, 0x64, 0x52, 0xac, 0x1d,
	0x7e, 0x29, 0xcd, 0x6a, 0xf2, 0xa5, 0x34, 0x6b, 0x97, 0x2f, 0x6f, 0xfd, 0x90, 0x83, 0xe5, 0xf8,
	0xfd, 0x0f, 0x6e, 0x10, 0xb2, 0x24, 0x4b, 0xfd, 0x81, 0xdc, 0x91, 0x34, 0x4d, 0xe9, 0x0c, 0x24,
	0x7e, 0x21, 0xcb, 0x3c, 0xa4, 0x8b, 0x5d, 0x92, 0x29, 0xf3, 0x85, 0x2c, 0x53, 0xe1, 0x8b, 0x59,
	0x26, 0xde, 0xb4, 0x66, 0x98, 0x47, 0xfc, 0x52, 0xca, 0x1d, 0x23, 0xed, 0x8e, 0x91, 0xe7, 0x8e,
	0x91, 0xe7, 0x8e, 0x91, 0xe7, 0x8e, 0x91, 0xe7, 0x8e, 0x91, 0xe7, 0x8e, 0x41, 0xdd, 0xf9, 0x16,
	0x2c, 0xc7, 0xaf, 0x9b, 0x70, 0x5a, 0x14, 0x19, 0x2b, 0x29, 0xe8, 0x50, 0x7f, 0xd4, 0x57, 0x07,
	0x9a, 0xd1, 0xc7, 0xc5, 0xa7, 0x2a, 0xfc, 0xc2, 0xd6, 0x47, 0x50, 0x8b, 0x5d, 0x71, 0xe0, 0x05,
	0x56, 0x96, 0x94, 0x36, 0x52, 0x69, 0x51, 0x93, 0x45, 0x3a, 0xc5, 0x23, 0x0b, 0xf6, 0x3a, 0xf0,
	0x71, 0x1e, 0x5d, 0xbc, 0x0f, 0x1b, 0xff, 0xf4, 0xe5, 0x26, 0xf7, 0x93, 0x2f, 0x37, 0xb9, 0x9f,
	0x7e, 0xb9, 0xc9, 0xfd, 0xfe, 0x57, 0x9b, 0x0b, 0x3f, 0xf9, 0x6a, 0x73, 0xe1, 0xdf, 0xbe, 0xda,
	0x5c, 0x38, 0x2b, 0x91, 0xff, 0x12, 0xdc, 0xfd, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xb3, 0xe9,
	0x6f, 0xd3, 0x42, 0x38, 0x00, 0x00,
}

func (m *ECGI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ECGI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ECGI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ecid) > 0 {
		i -= len(m.Ecid)
		copy(dAtA[i:], m.Ecid)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Ecid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PlmnId) > 0 {
		i -= len(m.PlmnId)
		copy(dAtA[i:], m.PlmnId)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.PlmnId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CandScell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CandScell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CandScell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EarfcnDl) > 0 {
		i -= len(m.EarfcnDl)
		copy(dAtA[i:], m.EarfcnDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.EarfcnDl)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pci != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CellConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CellConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CellConfigReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellConfigReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CellConfigReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DlfsSchedEnable) > 0 {
		i -= len(m.DlfsSchedEnable)
		copy(dAtA[i:], m.DlfsSchedEnable)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.DlfsSchedEnable)))
		i--
		dAtA[i] = 0x72
	}
	if m.MaxNumUesSchedPerTtiUl != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MaxNumUesSchedPerTtiUl))
		i--
		dAtA[i] = 0x68
	}
	if m.MaxNumUesSchedPerTtiDl != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MaxNumUesSchedPerTtiDl))
		i--
		dAtA[i] = 0x60
	}
	if m.MaxNumConnectedBearers != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MaxNumConnectedBearers))
		i--
		dAtA[i] = 0x58
	}
	if m.MaxNumConnectedUes != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MaxNumConnectedUes))
		i--
		dAtA[i] = 0x50
	}
	if len(m.DuplexMode) > 0 {
		i -= len(m.DuplexMode)
		copy(dAtA[i:], m.DuplexMode)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.DuplexMode)))
		i--
		dAtA[i] = 0x4a
	}
	if m.NumTxAntenna != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.NumTxAntenna))
		i--
		dAtA[i] = 0x40
	}
	if m.RbsPerTtiUl != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.RbsPerTtiUl))
		i--
		dAtA[i] = 0x38
	}
	if m.RbsPerTtiDl != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.RbsPerTtiDl))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EarfcnUl) > 0 {
		i -= len(m.EarfcnUl)
		copy(dAtA[i:], m.EarfcnUl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.EarfcnUl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.EarfcnDl) > 0 {
		i -= len(m.EarfcnDl)
		copy(dAtA[i:], m.EarfcnDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.EarfcnDl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CandScells) > 0 {
		for iNdEx := len(m.CandScells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CandScells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Pci != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x10
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEAdmissionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEAdmissionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEAdmissionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Imsi != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Imsi))
		i--
		dAtA[i] = 0x20
	}
	if m.AdmissionEstCause != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.AdmissionEstCause))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEAdmissionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEAdmissionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEAdmissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdmissionEstResponse != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.AdmissionEstResponse))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEAdmissionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEAdmissionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEAdmissionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdmissionEstStatus != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.AdmissionEstStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEContextUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEContextUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEContextUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Imsi) > 0 {
		i -= len(m.Imsi)
		copy(dAtA[i:], m.Imsi)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Imsi)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.EnbUeS1ApId) > 0 {
		i -= len(m.EnbUeS1ApId)
		copy(dAtA[i:], m.EnbUeS1ApId)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.EnbUeS1ApId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MmeUeS1ApId) > 0 {
		i -= len(m.MmeUeS1ApId)
		copy(dAtA[i:], m.MmeUeS1ApId)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.MmeUeS1ApId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEReconfigInd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEReconfigInd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEReconfigInd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReconfigCause != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.ReconfigCause))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CrntiNew) > 0 {
		i -= len(m.CrntiNew)
		copy(dAtA[i:], m.CrntiNew)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CrntiNew)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CrntiOld) > 0 {
		i -= len(m.CrntiOld)
		copy(dAtA[i:], m.CrntiOld)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CrntiOld)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEReleaseInd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEReleaseInd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEReleaseInd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReleaseCause != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.ReleaseCause))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEAMBR) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEAMBR) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEAMBR) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AmbrUl) > 0 {
		i -= len(m.AmbrUl)
		copy(dAtA[i:], m.AmbrUl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.AmbrUl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AmbrDl) > 0 {
		i -= len(m.AmbrDl)
		copy(dAtA[i:], m.AmbrDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.AmbrDl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ERABParamsItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ERABParamsItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ERABParamsItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MbrUl) > 0 {
		i -= len(m.MbrUl)
		copy(dAtA[i:], m.MbrUl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.MbrUl)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.MbrDl) > 0 {
		i -= len(m.MbrDl)
		copy(dAtA[i:], m.MbrDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.MbrDl)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.GbrUl) > 0 {
		i -= len(m.GbrUl)
		copy(dAtA[i:], m.GbrUl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.GbrUl)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.GbrDl) > 0 {
		i -= len(m.GbrDl)
		copy(dAtA[i:], m.GbrDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.GbrDl)))
		i--
		dAtA[i] = 0x32
	}
	if m.Arp != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Arp))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Qci) > 0 {
		i -= len(m.Qci)
		copy(dAtA[i:], m.Qci)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Qci)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Direction != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ERABResponseItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ERABResponseItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ERABResponseItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Decision != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Decision))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerAdmissionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerAdmissionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerAdmissionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErabsParams) > 0 {
		for iNdEx := len(m.ErabsParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ErabsParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.NumErabsList != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.NumErabsList))
		i--
		dAtA[i] = 0x20
	}
	if m.UeAmbr != nil {
		{
			size, err := m.UeAmbr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerAdmissionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerAdmissionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerAdmissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErabResponse) > 0 {
		for iNdEx := len(m.ErabResponse) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ErabResponse[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NumErabsList != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.NumErabsList))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerAdmissionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerAdmissionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerAdmissionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErabStatus) > 0 {
		for iNdEx := len(m.ErabStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ErabStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NumErabsList != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.NumErabsList))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerReleaseInd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerReleaseInd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerReleaseInd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErabIds) > 0 {
		for iNdEx := len(m.ErabIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ErabIds[iNdEx])
			copy(dAtA[i:], m.ErabIds[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.ErabIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NumErabsList != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.NumErabsList))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HORequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HORequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HORequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Crntis) > 0 {
		for iNdEx := len(m.Crntis) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Crntis[iNdEx])
			copy(dAtA[i:], m.Crntis[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crntis[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.EcgiT != nil {
		{
			size, err := m.EcgiT.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.EcgiS != nil {
		{
			size, err := m.EcgiS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HOFailure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HOFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HOFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HoFailureCause) > 0 {
		i -= len(m.HoFailureCause)
		copy(dAtA[i:], m.HoFailureCause)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.HoFailureCause)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EcgiS != nil {
		{
			size, err := m.EcgiS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HOComplete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HOComplete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HOComplete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EcgiT != nil {
		{
			size, err := m.EcgiT.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.EcgiS != nil {
		{
			size, err := m.EcgiS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CrntiNew) > 0 {
		i -= len(m.CrntiNew)
		copy(dAtA[i:], m.CrntiNew)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CrntiNew)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HOCause) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HOCause) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HOCause) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HoTrigger) > 0 {
		for iNdEx := len(m.HoTrigger) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HoTrigger[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.HoCause) > 0 {
		i -= len(m.HoCause)
		copy(dAtA[i:], m.HoCause)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.HoCause)))
		i--
		dAtA[i] = 0x22
	}
	if m.EcgiT != nil {
		{
			size, err := m.EcgiT.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.EcgiS != nil {
		{
			size, err := m.EcgiS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MeasCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CellIndividualOffset) > 0 {
		i -= len(m.CellIndividualOffset)
		copy(dAtA[i:], m.CellIndividualOffset)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CellIndividualOffset)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pci != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MeasObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MeasCells) > 0 {
		for iNdEx := len(m.MeasCells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MeasCells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DlFreq) > 0 {
		i -= len(m.DlFreq)
		copy(dAtA[i:], m.DlFreq)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.DlFreq)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportParamChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportParamChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReportParamChoice_PerParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_PerParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PerParam != nil {
		{
			size, err := m.PerParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A1Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A1Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A1Param != nil {
		{
			size, err := m.A1Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A2Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A2Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A2Param != nil {
		{
			size, err := m.A2Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A3Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A3Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A3Param != nil {
		{
			size, err := m.A3Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A4Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A4Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A4Param != nil {
		{
			size, err := m.A4Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A5Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A5Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A5Param != nil {
		{
			size, err := m.A5Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A6Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A6Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A6Param != nil {
		{
			size, err := m.A6Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ThresholdEUTRAChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdEUTRAChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdEUTRAChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdEUTRAChoice_ThresholdRSRP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdEUTRAChoice_ThresholdRSRP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ThresholdRSRP)
	copy(dAtA[i:], m.ThresholdRSRP)
	i = encodeVarintE2Interface(dAtA, i, uint64(len(m.ThresholdRSRP)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *ThresholdEUTRAChoice_ThresholdRSRQ) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdEUTRAChoice_ThresholdRSRQ) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ThresholdRSRQ)
	copy(dAtA[i:], m.ThresholdRSRQ)
	i = encodeVarintE2Interface(dAtA, i, uint64(len(m.ThresholdRSRQ)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *ThreasholdEUTRA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThreasholdEUTRA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThreasholdEUTRA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size, err := m.Choice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Present != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Present))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PerParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReportIntervalMs != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.ReportIntervalMs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *A1Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A1Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A1Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.A1Threshold != nil {
		{
			size, err := m.A1Threshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *A2Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A2Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A2Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.A2Threshold != nil {
		{
			size, err := m.A2Threshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *A3Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A3Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A3Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.A3Offset) > 0 {
		i -= len(m.A3Offset)
		copy(dAtA[i:], m.A3Offset)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.A3Offset)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *A4Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A4Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A4Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.A4Threshold != nil {
		{
			size, err := m.A4Threshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *A5Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A5Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A5Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.A5Threshold2 != nil {
		{
			size, err := m.A5Threshold2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.A5Threshold1 != nil {
		{
			size, err := m.A5Threshold1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *A6Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A6Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A6Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.A6Offset) > 0 {
		i -= len(m.A6Offset)
		copy(dAtA[i:], m.A6Offset)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.A6Offset)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timetotrigger != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Timetotrigger))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Hysteresis) > 0 {
		i -= len(m.Hysteresis)
		copy(dAtA[i:], m.Hysteresis)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Hysteresis)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Choice != nil {
		{
			size, err := m.Choice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Present != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Present))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReportConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReportQuality != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.ReportQuality))
		i--
		dAtA[i] = 0x18
	}
	if m.TriggerQuantity != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.TriggerQuantity))
		i--
		dAtA[i] = 0x10
	}
	if m.ReportParams != nil {
		{
			size, err := m.ReportParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMeasId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMeasId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMeasId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddMeasId) > 0 {
		for iNdEx := len(m.AddMeasId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddMeasId[iNdEx])
			copy(dAtA[i:], m.AddMeasId[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.AddMeasId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DelMeasId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelMeasId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelMeasId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelMeasId) > 0 {
		for iNdEx := len(m.DelMeasId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DelMeasId[iNdEx])
			copy(dAtA[i:], m.DelMeasId[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.DelMeasId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MeasIdActionChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasIdActionChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasIdActionChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MeasIdActionChoice_AddMeasId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasIdActionChoice_AddMeasId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddMeasId != nil {
		{
			size, err := m.AddMeasId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MeasIdActionChoice_DelMeasId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasIdActionChoice_DelMeasId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DelMeasId != nil {
		{
			size, err := m.DelMeasId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MeasIdActionChoice_Hototarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasIdActionChoice_Hototarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Hototarget)
	copy(dAtA[i:], m.Hototarget)
	i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Hototarget)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *MeasIdAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasIdAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasIdAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size, err := m.Choice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Present != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Present))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MeasID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size, err := m.Action.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ReportConfigId) > 0 {
		i -= len(m.ReportConfigId)
		copy(dAtA[i:], m.ReportConfigId)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.ReportConfigId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MeasObjectId) > 0 {
		i -= len(m.MeasObjectId)
		copy(dAtA[i:], m.MeasObjectId)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.MeasObjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RRCMeasConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RRCMeasConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RRCMeasConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MeasIds) > 0 {
		for iNdEx := len(m.MeasIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MeasIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ReportConfigs) > 0 {
		for iNdEx := len(m.ReportConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReportConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MeasObjects) > 0 {
		for iNdEx := len(m.MeasObjects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MeasObjects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Crnti) > 0 {
		for iNdEx := len(m.Crnti) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Crnti[iNdEx])
			copy(dAtA[i:], m.Crnti[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PCIARFCN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PCIARFCN) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PCIARFCN) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EarfcnDl) > 0 {
		i -= len(m.EarfcnDl)
		copy(dAtA[i:], m.EarfcnDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.EarfcnDl)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pci != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RXSigReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RXSigReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RXSigReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rsrq) > 0 {
		i -= len(m.Rsrq)
		copy(dAtA[i:], m.Rsrq)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Rsrq)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Rsrp) > 0 {
		i -= len(m.Rsrp)
		copy(dAtA[i:], m.Rsrp)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Rsrp)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PciArfcn != nil {
		{
			size, err := m.PciArfcn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RxSigMeasReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RxSigMeasReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RxSigMeasReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CellMeasReport) > 0 {
		for iNdEx := len(m.CellMeasReport) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CellMeasReport[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		for iNdEx := len(m.Crnti) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Crnti[iNdEx])
			copy(dAtA[i:], m.Crnti[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *L2MeasConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2MeasConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2MeasConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PdcpMeasReportPerUe != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.PdcpMeasReportPerUe))
		i--
		dAtA[i] = 0x28
	}
	if m.SchedMeasReportPerCell != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.SchedMeasReportPerCell))
		i--
		dAtA[i] = 0x20
	}
	if m.SchedMeasReportPerUe != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.SchedMeasReportPerUe))
		i--
		dAtA[i] = 0x18
	}
	if m.RadioMeasReportPerCell != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.RadioMeasReportPerCell))
		i--
		dAtA[i] = 0x10
	}
	if m.RadioMeasReportPerUe != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.RadioMeasReportPerUe))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RadioRepPerServCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadioRepPerServCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RadioRepPerServCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PucchSinrHist) > 0 {
		for iNdEx := len(m.PucchSinrHist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PucchSinrHist[iNdEx])
			copy(dAtA[i:], m.PucchSinrHist[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.PucchSinrHist[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PuschSinrHist) > 0 {
		for iNdEx := len(m.PuschSinrHist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PuschSinrHist[iNdEx])
			copy(dAtA[i:], m.PuschSinrHist[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.PuschSinrHist[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RiHist) > 0 {
		for iNdEx := len(m.RiHist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RiHist[iNdEx])
			copy(dAtA[i:], m.RiHist[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.RiHist[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CqiHist) > 0 {
		dAtA46 := make([]byte, len(m.CqiHist)*10)
		var j45 int
		for _, num := range m.CqiHist {
			for num >= 1<<7 {
				dAtA46[j45] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j45++
			}
			dAtA46[j45] = uint8(num)
			j45++
		}
		i -= j45
		copy(dAtA[i:], dAtA46[:j45])
		i = encodeVarintE2Interface(dAtA, i, uint64(j45))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RadioMeasReportPerUE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadioMeasReportPerUE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RadioMeasReportPerUE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RadioReportServCells) > 0 {
		for iNdEx := len(m.RadioReportServCells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RadioReportServCells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RadioMeasReportPerCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadioMeasReportPerCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RadioMeasReportPerCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PucchIntfPowerHist) > 0 {
		dAtA50 := make([]byte, len(m.PucchIntfPowerHist)*10)
		var j49 int
		for _, num := range m.PucchIntfPowerHist {
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		i -= j49
		copy(dAtA[i:], dAtA50[:j49])
		i = encodeVarintE2Interface(dAtA, i, uint64(j49))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PuschIntfPwrHist) > 0 {
		dAtA52 := make([]byte, len(m.PuschIntfPwrHist)*10)
		var j51 int
		for _, num := range m.PuschIntfPwrHist {
			for num >= 1<<7 {
				dAtA52[j51] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j51++
			}
			dAtA52[j51] = uint8(num)
			j51++
		}
		i -= j51
		copy(dAtA[i:], dAtA52[:j51])
		i = encodeVarintE2Interface(dAtA, i, uint64(j51))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PRBUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PRBUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PRBUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrbUsageUl) > 0 {
		for iNdEx := len(m.PrbUsageUl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PrbUsageUl[iNdEx])
			copy(dAtA[i:], m.PrbUsageUl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.PrbUsageUl[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PrbUsageDl) > 0 {
		for iNdEx := len(m.PrbUsageDl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PrbUsageDl[iNdEx])
			copy(dAtA[i:], m.PrbUsageDl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.PrbUsageDl[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SchedMeasRepPerServCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedMeasRepPerServCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedMeasRepPerServCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RankDl2) > 0 {
		for iNdEx := len(m.RankDl2) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RankDl2[iNdEx])
			copy(dAtA[i:], m.RankDl2[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.RankDl2[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.RankDl1) > 0 {
		for iNdEx := len(m.RankDl1) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RankDl1[iNdEx])
			copy(dAtA[i:], m.RankDl1[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.RankDl1[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.NumSchedTtisUl) > 0 {
		for iNdEx := len(m.NumSchedTtisUl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NumSchedTtisUl[iNdEx])
			copy(dAtA[i:], m.NumSchedTtisUl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.NumSchedTtisUl[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.McsUl) > 0 {
		for iNdEx := len(m.McsUl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.McsUl[iNdEx])
			copy(dAtA[i:], m.McsUl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.McsUl[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.NumSchedTtisDl) > 0 {
		for iNdEx := len(m.NumSchedTtisDl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NumSchedTtisDl[iNdEx])
			copy(dAtA[i:], m.NumSchedTtisDl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.NumSchedTtisDl[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.McsDl) > 0 {
		for iNdEx := len(m.McsDl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.McsDl[iNdEx])
			copy(dAtA[i:], m.McsDl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.McsDl[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.PrbUsage != nil {
		{
			size, err := m.PrbUsage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.QciVals) > 0 {
		for iNdEx := len(m.QciVals) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.QciVals[iNdEx])
			copy(dAtA[i:], m.QciVals[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.QciVals[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchedMeasReportPerUE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedMeasReportPerUE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedMeasReportPerUE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SchedReportServCells) > 0 {
		for iNdEx := len(m.SchedReportServCells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SchedReportServCells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchedMeasReportPerCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedMeasReportPerCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedMeasReportPerCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrbUsageScell != nil {
		{
			size, err := m.PrbUsageScell.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PrbUsagePcell != nil {
		{
			size, err := m.PrbUsagePcell.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.QciVals) > 0 {
		for iNdEx := len(m.QciVals) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.QciVals[iNdEx])
			copy(dAtA[i:], m.QciVals[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.QciVals[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PDCPMeasReportPerUe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PDCPMeasReportPerUe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PDCPMeasReportPerUe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ThroughputUl) > 0 {
		dAtA61 := make([]byte, len(m.ThroughputUl)*10)
		var j60 int
		for _, num := range m.ThroughputUl {
			for num >= 1<<7 {
				dAtA61[j60] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j60++
			}
			dAtA61[j60] = uint8(num)
			j60++
		}
		i -= j60
		copy(dAtA[i:], dAtA61[:j60])
		i = encodeVarintE2Interface(dAtA, i, uint64(j60))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ThroughputDl) > 0 {
		dAtA63 := make([]byte, len(m.ThroughputDl)*10)
		var j62 int
		for _, num := range m.ThroughputDl {
			for num >= 1<<7 {
				dAtA63[j62] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j62++
			}
			dAtA63[j62] = uint8(num)
			j62++
		}
		i -= j62
		copy(dAtA[i:], dAtA63[:j62])
		i = encodeVarintE2Interface(dAtA, i, uint64(j62))
		i--
		dAtA[i] = 0x52
	}
	if len(m.PktLossRateUl) > 0 {
		dAtA65 := make([]byte, len(m.PktLossRateUl)*10)
		var j64 int
		for _, num := range m.PktLossRateUl {
			for num >= 1<<7 {
				dAtA65[j64] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j64++
			}
			dAtA65[j64] = uint8(num)
			j64++
		}
		i -= j64
		copy(dAtA[i:], dAtA65[:j64])
		i = encodeVarintE2Interface(dAtA, i, uint64(j64))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PktLossRateDl) > 0 {
		dAtA67 := make([]byte, len(m.PktLossRateDl)*10)
		var j66 int
		for _, num := range m.PktLossRateDl {
			for num >= 1<<7 {
				dAtA67[j66] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j66++
			}
			dAtA67[j66] = uint8(num)
			j66++
		}
		i -= j66
		copy(dAtA[i:], dAtA67[:j66])
		i = encodeVarintE2Interface(dAtA, i, uint64(j66))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PktDiscardRateDl) > 0 {
		dAtA69 := make([]byte, len(m.PktDiscardRateDl)*10)
		var j68 int
		for _, num := range m.PktDiscardRateDl {
			for num >= 1<<7 {
				dAtA69[j68] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j68++
			}
			dAtA69[j68] = uint8(num)
			j68++
		}
		i -= j68
		copy(dAtA[i:], dAtA69[:j68])
		i = encodeVarintE2Interface(dAtA, i, uint64(j68))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PktDelayDl) > 0 {
		dAtA71 := make([]byte, len(m.PktDelayDl)*10)
		var j70 int
		for _, num := range m.PktDelayDl {
			for num >= 1<<7 {
				dAtA71[j70] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j70++
			}
			dAtA71[j70] = uint8(num)
			j70++
		}
		i -= j70
		copy(dAtA[i:], dAtA71[:j70])
		i = encodeVarintE2Interface(dAtA, i, uint64(j70))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DataVolUl) > 0 {
		dAtA73 := make([]byte, len(m.DataVolUl)*10)
		var j72 int
		for _, num := range m.DataVolUl {
			for num >= 1<<7 {
				dAtA73[j72] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j72++
			}
			dAtA73[j72] = uint8(num)
			j72++
		}
		i -= j72
		copy(dAtA[i:], dAtA73[:j72])
		i = encodeVarintE2Interface(dAtA, i, uint64(j72))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DataVolDl) > 0 {
		dAtA75 := make([]byte, len(m.DataVolDl)*10)
		var j74 int
		for _, num := range m.DataVolDl {
			for num >= 1<<7 {
				dAtA75[j74] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j74++
			}
			dAtA75[j74] = uint8(num)
			j74++
		}
		i -= j74
		copy(dAtA[i:], dAtA75[:j74])
		i = encodeVarintE2Interface(dAtA, i, uint64(j74))
		i--
		dAtA[i] = 0x22
	}
	if len(m.QciVals) > 0 {
		for iNdEx := len(m.QciVals) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.QciVals[iNdEx])
			copy(dAtA[i:], m.QciVals[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.QciVals[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RRMConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RRMConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RRMConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubFrameBitmaskUl) > 0 {
		for iNdEx := len(m.SubFrameBitmaskUl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubFrameBitmaskUl[iNdEx])
			copy(dAtA[i:], m.SubFrameBitmaskUl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.SubFrameBitmaskUl[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.EndPrbUl) > 0 {
		dAtA78 := make([]byte, len(m.EndPrbUl)*10)
		var j77 int
		for _, num := range m.EndPrbUl {
			for num >= 1<<7 {
				dAtA78[j77] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j77++
			}
			dAtA78[j77] = uint8(num)
			j77++
		}
		i -= j77
		copy(dAtA[i:], dAtA78[:j77])
		i = encodeVarintE2Interface(dAtA, i, uint64(j77))
		i--
		dAtA[i] = 0x52
	}
	if len(m.StartPrbUl) > 0 {
		dAtA80 := make([]byte, len(m.StartPrbUl)*10)
		var j79 int
		for _, num := range m.StartPrbUl {
			for num >= 1<<7 {
				dAtA80[j79] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j79++
			}
			dAtA80[j79] = uint8(num)
			j79++
		}
		i -= j79
		copy(dAtA[i:], dAtA80[:j79])
		i = encodeVarintE2Interface(dAtA, i, uint64(j79))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.P0UePusch) > 0 {
		dAtA82 := make([]byte, len(m.P0UePusch)*10)
		var j81 int
		for _, num := range m.P0UePusch {
			for num >= 1<<7 {
				dAtA82[j81] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j81++
			}
			dAtA82[j81] = uint8(num)
			j81++
		}
		i -= j81
		copy(dAtA[i:], dAtA82[:j81])
		i = encodeVarintE2Interface(dAtA, i, uint64(j81))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SubFrameBitmaskDl) > 0 {
		for iNdEx := len(m.SubFrameBitmaskDl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubFrameBitmaskDl[iNdEx])
			copy(dAtA[i:], m.SubFrameBitmaskDl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.SubFrameBitmaskDl[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.EndPrbDl) > 0 {
		dAtA84 := make([]byte, len(m.EndPrbDl)*10)
		var j83 int
		for _, num := range m.EndPrbDl {
			for num >= 1<<7 {
				dAtA84[j83] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j83++
			}
			dAtA84[j83] = uint8(num)
			j83++
		}
		i -= j83
		copy(dAtA[i:], dAtA84[:j83])
		i = encodeVarintE2Interface(dAtA, i, uint64(j83))
		i--
		dAtA[i] = 0x32
	}
	if len(m.StartPrbDl) > 0 {
		dAtA86 := make([]byte, len(m.StartPrbDl)*10)
		var j85 int
		for _, num := range m.StartPrbDl {
			for num >= 1<<7 {
				dAtA86[j85] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j85++
			}
			dAtA86[j85] = uint8(num)
			j85++
		}
		i -= j85
		copy(dAtA[i:], dAtA86[:j85])
		i = encodeVarintE2Interface(dAtA, i, uint64(j85))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PA) > 0 {
		dAtA88 := make([]byte, len(m.PA)*10)
		var j87 int
		for _, num := range m.PA {
			for num >= 1<<7 {
				dAtA88[j87] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j87++
			}
			dAtA88[j87] = uint8(num)
			j87++
		}
		i -= j87
		copy(dAtA[i:], dAtA88[:j87])
		i = encodeVarintE2Interface(dAtA, i, uint64(j87))
		i--
		dAtA[i] = 0x22
	}
	if m.PciArfcn != nil {
		{
			size, err := m.PciArfcn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Crnti) > 0 {
		for iNdEx := len(m.Crnti) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Crnti[iNdEx])
			copy(dAtA[i:], m.Crnti[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RRMConfigStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RRMConfigStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RRMConfigStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA92 := make([]byte, len(m.Status)*10)
		var j91 int
		for _, num := range m.Status {
			for num >= 1<<7 {
				dAtA92[j91] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j91++
			}
			dAtA92[j91] = uint8(num)
			j91++
		}
		i -= j91
		copy(dAtA[i:], dAtA92[:j91])
		i = encodeVarintE2Interface(dAtA, i, uint64(j91))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Crnti) > 0 {
		for iNdEx := len(m.Crnti) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Crnti[iNdEx])
			copy(dAtA[i:], m.Crnti[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CACap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CACap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CACap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CrossCarrierSched) > 0 {
		i -= len(m.CrossCarrierSched)
		copy(dAtA[i:], m.CrossCarrierSched)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CrossCarrierSched)))
		i--
		dAtA[i] = 0x22
	}
	if m.Caclassul != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Caclassul))
		i--
		dAtA[i] = 0x18
	}
	if m.Caclassdl != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Caclassdl))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Band) > 0 {
		i -= len(m.Band)
		copy(dAtA[i:], m.Band)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Band)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DCCap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DCCap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DCCap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DrbTypeSplit != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.DrbTypeSplit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UECapabilityEnquiry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UECapabilityEnquiry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UECapabilityEnquiry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UECapabilityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UECapabilityInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UECapabilityInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DcCap != nil {
		{
			size, err := m.DcCap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CaCap != nil {
		{
			size, err := m.CaCap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PropScell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropScell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropScell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeactTimer) > 0 {
		i -= len(m.DeactTimer)
		copy(dAtA[i:], m.DeactTimer)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.DeactTimer)))
		i--
		dAtA[i] = 0x22
	}
	if m.CaDirection != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.CaDirection))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CrossCarrierSchedEnable) > 0 {
		i -= len(m.CrossCarrierSchedEnable)
		copy(dAtA[i:], m.CrossCarrierSchedEnable)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CrossCarrierSchedEnable)))
		i--
		dAtA[i] = 0x12
	}
	if m.PciArfcn != nil {
		{
			size, err := m.PciArfcn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScellAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScellAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScellAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScellsProp) > 0 {
		for iNdEx := len(m.ScellsProp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ScellsProp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScellAddStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScellAddStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScellAddStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA101 := make([]byte, len(m.Status)*10)
		var j100 int
		for _, num := range m.Status {
			for num >= 1<<7 {
				dAtA101[j100] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j100++
			}
			dAtA101[j100] = uint8(num)
			j100++
		}
		i -= j100
		copy(dAtA[i:], dAtA101[:j100])
		i = encodeVarintE2Interface(dAtA, i, uint64(j100))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ScellsInd) > 0 {
		for iNdEx := len(m.ScellsInd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ScellsInd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScellDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScellDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScellDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScellsInd) > 0 {
		for iNdEx := len(m.ScellsInd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ScellsInd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SeNBAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeNBAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeNBAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SEcgi != nil {
		{
			size, err := m.SEcgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MEcgi != nil {
		{
			size, err := m.MEcgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SeNBAddStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeNBAddStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeNBAddStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SeNBDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeNBDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeNBDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SEcgi != nil {
		{
			size, err := m.SEcgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MEcgi != nil {
		{
			size, err := m.MEcgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrafficSplitPercentage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficSplitPercentage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrafficSplitPercentage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrafficPercentageUl) > 0 {
		i -= len(m.TrafficPercentageUl)
		copy(dAtA[i:], m.TrafficPercentageUl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.TrafficPercentageUl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TrafficPercentageDl) > 0 {
		i -= len(m.TrafficPercentageDl)
		copy(dAtA[i:], m.TrafficPercentageDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.TrafficPercentageDl)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrafficSplitConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficSplitConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrafficSplitConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrafficSplitPercentage) > 0 {
		for iNdEx := len(m.TrafficSplitPercentage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrafficSplitPercentage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintE2Interface(dAtA []byte, offset int, v uint64) int {
	offset -= sovE2Interface(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ECGI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PlmnId)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Ecid)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *CandScell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pci != 0 {
		n += 1 + sovE2Interface(uint64(m.Pci))
	}
	l = len(m.EarfcnDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *CellConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *CellConfigReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Pci != 0 {
		n += 1 + sovE2Interface(uint64(m.Pci))
	}
	if len(m.CandScells) > 0 {
		for _, e := range m.CandScells {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	l = len(m.EarfcnDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.EarfcnUl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.RbsPerTtiDl != 0 {
		n += 1 + sovE2Interface(uint64(m.RbsPerTtiDl))
	}
	if m.RbsPerTtiUl != 0 {
		n += 1 + sovE2Interface(uint64(m.RbsPerTtiUl))
	}
	if m.NumTxAntenna != 0 {
		n += 1 + sovE2Interface(uint64(m.NumTxAntenna))
	}
	l = len(m.DuplexMode)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.MaxNumConnectedUes != 0 {
		n += 1 + sovE2Interface(uint64(m.MaxNumConnectedUes))
	}
	if m.MaxNumConnectedBearers != 0 {
		n += 1 + sovE2Interface(uint64(m.MaxNumConnectedBearers))
	}
	if m.MaxNumUesSchedPerTtiDl != 0 {
		n += 1 + sovE2Interface(uint64(m.MaxNumUesSchedPerTtiDl))
	}
	if m.MaxNumUesSchedPerTtiUl != 0 {
		n += 1 + sovE2Interface(uint64(m.MaxNumUesSchedPerTtiUl))
	}
	l = len(m.DlfsSchedEnable)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *UEAdmissionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.AdmissionEstCause != 0 {
		n += 1 + sovE2Interface(uint64(m.AdmissionEstCause))
	}
	if m.Imsi != 0 {
		n += 1 + sovE2Interface(uint64(m.Imsi))
	}
	return n
}

func (m *UEAdmissionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.AdmissionEstResponse != 0 {
		n += 1 + sovE2Interface(uint64(m.AdmissionEstResponse))
	}
	return n
}

func (m *UEAdmissionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.AdmissionEstStatus != 0 {
		n += 1 + sovE2Interface(uint64(m.AdmissionEstStatus))
	}
	return n
}

func (m *UEContextUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.MmeUeS1ApId)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.EnbUeS1ApId)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Imsi)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *UEReconfigInd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CrntiOld)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.CrntiNew)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.ReconfigCause != 0 {
		n += 1 + sovE2Interface(uint64(m.ReconfigCause))
	}
	return n
}

func (m *UEReleaseInd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.ReleaseCause != 0 {
		n += 1 + sovE2Interface(uint64(m.ReleaseCause))
	}
	return n
}

func (m *UEAMBR) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AmbrDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.AmbrUl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *ERABParamsItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovE2Interface(uint64(m.Direction))
	}
	if m.Type != 0 {
		n += 1 + sovE2Interface(uint64(m.Type))
	}
	l = len(m.Qci)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Arp != 0 {
		n += 1 + sovE2Interface(uint64(m.Arp))
	}
	l = len(m.GbrDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.GbrUl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.MbrDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.MbrUl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *ERABResponseItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Decision != 0 {
		n += 1 + sovE2Interface(uint64(m.Decision))
	}
	return n
}

func (m *BearerAdmissionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.UeAmbr != nil {
		l = m.UeAmbr.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.NumErabsList != 0 {
		n += 1 + sovE2Interface(uint64(m.NumErabsList))
	}
	if len(m.ErabsParams) > 0 {
		for _, e := range m.ErabsParams {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *BearerAdmissionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.NumErabsList != 0 {
		n += 1 + sovE2Interface(uint64(m.NumErabsList))
	}
	if len(m.ErabResponse) > 0 {
		for _, e := range m.ErabResponse {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *BearerAdmissionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.NumErabsList != 0 {
		n += 1 + sovE2Interface(uint64(m.NumErabsList))
	}
	if len(m.ErabStatus) > 0 {
		for _, e := range m.ErabStatus {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *BearerReleaseInd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.NumErabsList != 0 {
		n += 1 + sovE2Interface(uint64(m.NumErabsList))
	}
	if len(m.ErabIds) > 0 {
		for _, s := range m.ErabIds {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *HORequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiS != nil {
		l = m.EcgiS.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiT != nil {
		l = m.EcgiT.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.Crntis) > 0 {
		for _, s := range m.Crntis {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *HOFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiS != nil {
		l = m.EcgiS.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.HoFailureCause)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *HOComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CrntiNew)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiS != nil {
		l = m.EcgiS.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiT != nil {
		l = m.EcgiT.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *HOCause) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiS != nil {
		l = m.EcgiS.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiT != nil {
		l = m.EcgiT.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.HoCause)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.HoTrigger) > 0 {
		for _, e := range m.HoTrigger {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *MeasCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pci != 0 {
		n += 1 + sovE2Interface(uint64(m.Pci))
	}
	l = len(m.CellIndividualOffset)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *MeasObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DlFreq)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.MeasCells) > 0 {
		for _, e := range m.MeasCells {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *ReportParamChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *ReportParamChoice_PerParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerParam != nil {
		l = m.PerParam.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A1Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A1Param != nil {
		l = m.A1Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A2Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A2Param != nil {
		l = m.A2Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A3Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A3Param != nil {
		l = m.A3Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A4Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A4Param != nil {
		l = m.A4Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A5Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A5Param != nil {
		l = m.A5Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A6Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A6Param != nil {
		l = m.A6Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ThresholdEUTRAChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *ThresholdEUTRAChoice_ThresholdRSRP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ThresholdRSRP)
	n += 1 + l + sovE2Interface(uint64(l))
	return n
}
func (m *ThresholdEUTRAChoice_ThresholdRSRQ) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ThresholdRSRQ)
	n += 1 + l + sovE2Interface(uint64(l))
	return n
}
func (m *ThreasholdEUTRA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Present != 0 {
		n += 1 + sovE2Interface(uint64(m.Present))
	}
	if m.Choice != nil {
		l = m.Choice.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *PerParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReportIntervalMs != 0 {
		n += 1 + sovE2Interface(uint64(m.ReportIntervalMs))
	}
	return n
}

func (m *A1Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A1Threshold != nil {
		l = m.A1Threshold.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *A2Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A2Threshold != nil {
		l = m.A2Threshold.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *A3Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.A3Offset)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *A4Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A4Threshold != nil {
		l = m.A4Threshold.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *A5Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A5Threshold1 != nil {
		l = m.A5Threshold1.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.A5Threshold2 != nil {
		l = m.A5Threshold2.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *A6Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.A6Offset)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *ReportParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Present != 0 {
		n += 1 + sovE2Interface(uint64(m.Present))
	}
	if m.Choice != nil {
		l = m.Choice.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Hysteresis)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Timetotrigger != 0 {
		n += 1 + sovE2Interface(uint64(m.Timetotrigger))
	}
	return n
}

func (m *ReportConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReportParams != nil {
		l = m.ReportParams.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.TriggerQuantity != 0 {
		n += 1 + sovE2Interface(uint64(m.TriggerQuantity))
	}
	if m.ReportQuality != 0 {
		n += 1 + sovE2Interface(uint64(m.ReportQuality))
	}
	return n
}

func (m *AddMeasId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AddMeasId) > 0 {
		for _, s := range m.AddMeasId {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *DelMeasId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DelMeasId) > 0 {
		for _, s := range m.DelMeasId {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *MeasIdActionChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *MeasIdActionChoice_AddMeasId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddMeasId != nil {
		l = m.AddMeasId.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MeasIdActionChoice_DelMeasId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelMeasId != nil {
		l = m.DelMeasId.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MeasIdActionChoice_Hototarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hototarget)
	n += 1 + l + sovE2Interface(uint64(l))
	return n
}
func (m *MeasIdAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Present != 0 {
		n += 1 + sovE2Interface(uint64(m.Present))
	}
	if m.Choice != nil {
		l = m.Choice.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *MeasID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MeasObjectId)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.ReportConfigId)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *RRCMeasConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.Crnti) > 0 {
		for _, s := range m.Crnti {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.MeasObjects) > 0 {
		for _, e := range m.MeasObjects {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.ReportConfigs) > 0 {
		for _, e := range m.ReportConfigs {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.MeasIds) > 0 {
		for _, e := range m.MeasIds {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *PCIARFCN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pci != 0 {
		n += 1 + sovE2Interface(uint64(m.Pci))
	}
	l = len(m.EarfcnDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *RXSigReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PciArfcn != nil {
		l = m.PciArfcn.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Rsrp)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Rsrq)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *RxSigMeasReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Crnti) > 0 {
		for _, s := range m.Crnti {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.CellMeasReport) > 0 {
		for _, e := range m.CellMeasReport {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *L2MeasConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RadioMeasReportPerUe != 0 {
		n += 1 + sovE2Interface(uint64(m.RadioMeasReportPerUe))
	}
	if m.RadioMeasReportPerCell != 0 {
		n += 1 + sovE2Interface(uint64(m.RadioMeasReportPerCell))
	}
	if m.SchedMeasReportPerUe != 0 {
		n += 1 + sovE2Interface(uint64(m.SchedMeasReportPerUe))
	}
	if m.SchedMeasReportPerCell != 0 {
		n += 1 + sovE2Interface(uint64(m.SchedMeasReportPerCell))
	}
	if m.PdcpMeasReportPerUe != 0 {
		n += 1 + sovE2Interface(uint64(m.PdcpMeasReportPerUe))
	}
	return n
}

func (m *RadioRepPerServCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.CqiHist) > 0 {
		l = 0
		for _, e := range m.CqiHist {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.RiHist) > 0 {
		for _, s := range m.RiHist {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.PuschSinrHist) > 0 {
		for _, s := range m.PuschSinrHist {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.PucchSinrHist) > 0 {
		for _, s := range m.PucchSinrHist {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *RadioMeasReportPerUE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.RadioReportServCells) > 0 {
		for _, e := range m.RadioReportServCells {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *RadioMeasReportPerCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.PuschIntfPwrHist) > 0 {
		l = 0
		for _, e := range m.PuschIntfPwrHist {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.PucchIntfPowerHist) > 0 {
		l = 0
		for _, e := range m.PucchIntfPowerHist {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	return n
}

func (m *PRBUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PrbUsageDl) > 0 {
		for _, s := range m.PrbUsageDl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.PrbUsageUl) > 0 {
		for _, s := range m.PrbUsageUl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *SchedMeasRepPerServCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.QciVals) > 0 {
		for _, s := range m.QciVals {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if m.PrbUsage != nil {
		l = m.PrbUsage.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.McsDl) > 0 {
		for _, s := range m.McsDl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.NumSchedTtisDl) > 0 {
		for _, s := range m.NumSchedTtisDl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.McsUl) > 0 {
		for _, s := range m.McsUl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.NumSchedTtisUl) > 0 {
		for _, s := range m.NumSchedTtisUl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.RankDl1) > 0 {
		for _, s := range m.RankDl1 {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.RankDl2) > 0 {
		for _, s := range m.RankDl2 {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *SchedMeasReportPerUE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.SchedReportServCells) > 0 {
		for _, e := range m.SchedReportServCells {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *SchedMeasReportPerCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.QciVals) > 0 {
		for _, s := range m.QciVals {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if m.PrbUsagePcell != nil {
		l = m.PrbUsagePcell.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.PrbUsageScell != nil {
		l = m.PrbUsageScell.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *PDCPMeasReportPerUe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.QciVals) > 0 {
		for _, s := range m.QciVals {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.DataVolDl) > 0 {
		l = 0
		for _, e := range m.DataVolDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.DataVolUl) > 0 {
		l = 0
		for _, e := range m.DataVolUl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.PktDelayDl) > 0 {
		l = 0
		for _, e := range m.PktDelayDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.PktDiscardRateDl) > 0 {
		l = 0
		for _, e := range m.PktDiscardRateDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.PktLossRateDl) > 0 {
		l = 0
		for _, e := range m.PktLossRateDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.PktLossRateUl) > 0 {
		l = 0
		for _, e := range m.PktLossRateUl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.ThroughputDl) > 0 {
		l = 0
		for _, e := range m.ThroughputDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.ThroughputUl) > 0 {
		l = 0
		for _, e := range m.ThroughputUl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	return n
}

func (m *RRMConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.Crnti) > 0 {
		for _, s := range m.Crnti {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if m.PciArfcn != nil {
		l = m.PciArfcn.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.PA) > 0 {
		l = 0
		for _, e := range m.PA {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.StartPrbDl) > 0 {
		l = 0
		for _, e := range m.StartPrbDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.EndPrbDl) > 0 {
		l = 0
		for _, e := range m.EndPrbDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.SubFrameBitmaskDl) > 0 {
		for _, s := range m.SubFrameBitmaskDl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.P0UePusch) > 0 {
		l = 0
		for _, e := range m.P0UePusch {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.StartPrbUl) > 0 {
		l = 0
		for _, e := range m.StartPrbUl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.EndPrbUl) > 0 {
		l = 0
		for _, e := range m.EndPrbUl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.SubFrameBitmaskUl) > 0 {
		for _, s := range m.SubFrameBitmaskUl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *RRMConfigStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.Crnti) > 0 {
		for _, s := range m.Crnti {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	return n
}

func (m *CACap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Band)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Caclassdl != 0 {
		n += 1 + sovE2Interface(uint64(m.Caclassdl))
	}
	if m.Caclassul != 0 {
		n += 1 + sovE2Interface(uint64(m.Caclassul))
	}
	l = len(m.CrossCarrierSched)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *DCCap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DrbTypeSplit != 0 {
		n += 1 + sovE2Interface(uint64(m.DrbTypeSplit))
	}
	return n
}

func (m *UECapabilityEnquiry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *UECapabilityInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.CaCap != nil {
		l = m.CaCap.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.DcCap != nil {
		l = m.DcCap.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *PropScell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PciArfcn != nil {
		l = m.PciArfcn.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.CrossCarrierSchedEnable)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.CaDirection != 0 {
		n += 1 + sovE2Interface(uint64(m.CaDirection))
	}
	l = len(m.DeactTimer)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *ScellAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.ScellsProp) > 0 {
		for _, e := range m.ScellsProp {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *ScellAddStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.ScellsInd) > 0 {
		for _, e := range m.ScellsInd {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	return n
}

func (m *ScellDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.ScellsInd) > 0 {
		for _, e := range m.ScellsInd {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *SeNBAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.MEcgi != nil {
		l = m.MEcgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.SEcgi != nil {
		l = m.SEcgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *SeNBAddStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovE2Interface(uint64(m.Status))
	}
	return n
}

func (m *SeNBDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.MEcgi != nil {
		l = m.MEcgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.SEcgi != nil {
		l = m.SEcgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *TrafficSplitPercentage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.TrafficPercentageDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.TrafficPercentageUl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *TrafficSplitConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.TrafficSplitPercentage) > 0 {
		for _, e := range m.TrafficSplitPercentage {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func sovE2Interface(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozE2Interface(x uint64) (n int) {
	return sovE2Interface(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ECGI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ECGI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ECGI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlmnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlmnId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ecid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CandScell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CandScell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CandScell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellConfigReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellConfigReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellConfigReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CandScells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CandScells = append(m.CandScells, &CandScell{})
			if err := m.CandScells[len(m.CandScells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RbsPerTtiDl", wireType)
			}
			m.RbsPerTtiDl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RbsPerTtiDl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RbsPerTtiUl", wireType)
			}
			m.RbsPerTtiUl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RbsPerTtiUl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTxAntenna", wireType)
			}
			m.NumTxAntenna = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTxAntenna |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DuplexMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DuplexMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumConnectedUes", wireType)
			}
			m.MaxNumConnectedUes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumConnectedUes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumConnectedBearers", wireType)
			}
			m.MaxNumConnectedBearers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumConnectedBearers |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumUesSchedPerTtiDl", wireType)
			}
			m.MaxNumUesSchedPerTtiDl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumUesSchedPerTtiDl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumUesSchedPerTtiUl", wireType)
			}
			m.MaxNumUesSchedPerTtiUl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumUesSchedPerTtiUl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DlfsSchedEnable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DlfsSchedEnable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEAdmissionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEAdmissionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEAdmissionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionEstCause", wireType)
			}
			m.AdmissionEstCause = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdmissionEstCause |= AdmEstCause(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imsi", wireType)
			}
			m.Imsi = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Imsi |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEAdmissionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEAdmissionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEAdmissionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionEstResponse", wireType)
			}
			m.AdmissionEstResponse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdmissionEstResponse |= SuccessOrFailure(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEAdmissionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEAdmissionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEAdmissionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionEstStatus", wireType)
			}
			m.AdmissionEstStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdmissionEstStatus |= SuccessOrFailure(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEContextUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEContextUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEContextUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmeUeS1ApId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmeUeS1ApId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnbUeS1ApId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnbUeS1ApId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imsi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imsi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEReconfigInd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEReconfigInd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEReconfigInd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrntiOld", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrntiOld = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrntiNew", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrntiNew = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReconfigCause", wireType)
			}
			m.ReconfigCause = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReconfigCause |= ReconfigCause(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEReleaseInd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEReleaseInd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEReleaseInd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseCause", wireType)
			}
			m.ReleaseCause = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReleaseCause |= ReleaseCause(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEAMBR) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEAMBR: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEAMBR: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmbrDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmbrDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmbrUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmbrUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ERABParamsItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ERABParamsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ERABParamsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= ERABDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ERABType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qci", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qci = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arp", wireType)
			}
			m.Arp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Arp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GbrDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GbrDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GbrUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GbrUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MbrDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MbrDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MbrUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MbrUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ERABResponseItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ERABResponseItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ERABResponseItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decision", wireType)
			}
			m.Decision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decision |= SuccessOrFailure(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerAdmissionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerAdmissionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerAdmissionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UeAmbr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UeAmbr == nil {
				m.UeAmbr = &UEAMBR{}
			}
			if err := m.UeAmbr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumErabsList", wireType)
			}
			m.NumErabsList = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumErabsList |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErabsParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErabsParams = append(m.ErabsParams, &ERABParamsItem{})
			if err := m.ErabsParams[len(m.ErabsParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerAdmissionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerAdmissionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerAdmissionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumErabsList", wireType)
			}
			m.NumErabsList = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumErabsList |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErabResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErabResponse = append(m.ErabResponse, &ERABResponseItem{})
			if err := m.ErabResponse[len(m.ErabResponse)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerAdmissionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerAdmissionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerAdmissionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumErabsList", wireType)
			}
			m.NumErabsList = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumErabsList |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErabStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErabStatus = append(m.ErabStatus, &ERABResponseItem{})
			if err := m.ErabStatus[len(m.ErabStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerReleaseInd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerReleaseInd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerReleaseInd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumErabsList", wireType)
			}
			m.NumErabsList = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumErabsList |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErabIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErabIds = append(m.ErabIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HORequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HORequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HORequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiS == nil {
				m.EcgiS = &ECGI{}
			}
			if err := m.EcgiS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiT == nil {
				m.EcgiT = &ECGI{}
			}
			if err := m.EcgiT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crntis", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crntis = append(m.Crntis, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HOFailure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HOFailure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HOFailure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiS == nil {
				m.EcgiS = &ECGI{}
			}
			if err := m.EcgiS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoFailureCause", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HoFailureCause = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HOComplete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HOComplete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HOComplete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrntiNew", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrntiNew = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiS == nil {
				m.EcgiS = &ECGI{}
			}
			if err := m.EcgiS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiT == nil {
				m.EcgiT = &ECGI{}
			}
			if err := m.EcgiT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HOCause) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HOCause: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HOCause: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiS == nil {
				m.EcgiS = &ECGI{}
			}
			if err := m.EcgiS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiT == nil {
				m.EcgiT = &ECGI{}
			}
			if err := m.EcgiT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoCause", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HoCause = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HoTrigger = append(m.HoTrigger, &RXSigReport{})
			if err := m.HoTrigger[len(m.HoTrigger)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellIndividualOffset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CellIndividualOffset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DlFreq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DlFreq = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasCells = append(m.MeasCells, &MeasCell{})
			if err := m.MeasCells[len(m.MeasCells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportParamChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportParamChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportParamChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PerParam{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_PerParam{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A1Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A1Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A1Param{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A2Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A2Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A2Param{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A3Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A3Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A3Param{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A4Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A4Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A4Param{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A5Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A5Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A5Param{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A6Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A6Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A6Param{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdEUTRAChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdEUTRAChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdEUTRAChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdRSRP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &ThresholdEUTRAChoice_ThresholdRSRP{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdRSRQ", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &ThresholdEUTRAChoice_ThresholdRSRQ{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThreasholdEUTRA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThreasholdEUTRA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThreasholdEUTRA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Present", wireType)
			}
			m.Present = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Present |= ThresholdEUTRAPR(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Choice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Choice == nil {
				m.Choice = &ThresholdEUTRAChoice{}
			}
			if err := m.Choice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportIntervalMs", wireType)
			}
			m.ReportIntervalMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportIntervalMs |= PerParamReportIntervalMs(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A1Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A1Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A1Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A1Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A1Threshold == nil {
				m.A1Threshold = &ThreasholdEUTRA{}
			}
			if err := m.A1Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A2Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A2Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A2Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A2Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A2Threshold == nil {
				m.A2Threshold = &ThreasholdEUTRA{}
			}
			if err := m.A2Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A3Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A3Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A3Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A3Offset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A3Offset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A4Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A4Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A4Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A4Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A4Threshold == nil {
				m.A4Threshold = &ThreasholdEUTRA{}
			}
			if err := m.A4Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A5Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A5Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A5Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A5Threshold1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A5Threshold1 == nil {
				m.A5Threshold1 = &ThreasholdEUTRA{}
			}
			if err := m.A5Threshold1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A5Threshold2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A5Threshold2 == nil {
				m.A5Threshold2 = &ThreasholdEUTRA{}
			}
			if err := m.A5Threshold2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A6Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A6Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A6Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A6Offset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A6Offset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Present", wireType)
			}
			m.Present = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Present |= ReportParamPR(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Choice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Choice == nil {
				m.Choice = &ReportParamChoice{}
			}
			if err := m.Choice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hysteresis", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hysteresis = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timetotrigger", wireType)
			}
			m.Timetotrigger = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timetotrigger |= TimeToTrigger(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportParams == nil {
				m.ReportParams = &ReportParam{}
			}
			if err := m.ReportParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerQuantity", wireType)
			}
			m.TriggerQuantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerQuantity |= TriggerQuantity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportQuality", wireType)
			}
			m.ReportQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportQuality |= ReportQuality(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMeasId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMeasId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMeasId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddMeasId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddMeasId = append(m.AddMeasId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelMeasId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelMeasId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelMeasId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelMeasId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelMeasId = append(m.DelMeasId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasIdActionChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasIdActionChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasIdActionChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddMeasId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddMeasId{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &MeasIdActionChoice_AddMeasId{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelMeasId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DelMeasId{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &MeasIdActionChoice_DelMeasId{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hototarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &MeasIdActionChoice_Hototarget{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasIdAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasIdAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasIdAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Present", wireType)
			}
			m.Present = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Present |= MeasIdActionPR(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Choice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Choice == nil {
				m.Choice = &MeasIdActionChoice{}
			}
			if err := m.Choice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasObjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasObjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportConfigId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportConfigId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &MeasIdAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RRCMeasConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RRCMeasConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RRCMeasConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = append(m.Crnti, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasObjects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasObjects = append(m.MeasObjects, &MeasObject{})
			if err := m.MeasObjects[len(m.MeasObjects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportConfigs = append(m.ReportConfigs, &ReportConfig{})
			if err := m.ReportConfigs[len(m.ReportConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasIds = append(m.MeasIds, &MeasID{})
			if err := m.MeasIds[len(m.MeasIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PCIARFCN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PCIARFCN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PCIARFCN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RXSigReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RXSigReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RXSigReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PciArfcn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PciArfcn == nil {
				m.PciArfcn = &PCIARFCN{}
			}
			if err := m.PciArfcn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rsrp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rsrq = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RxSigMeasReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RxSigMeasReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RxSigMeasReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = append(m.Crnti, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellMeasReport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CellMeasReport = append(m.CellMeasReport, &RXSigReport{})
			if err := m.CellMeasReport[len(m.CellMeasReport)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2MeasConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2MeasConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2MeasConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadioMeasReportPerUe", wireType)
			}
			m.RadioMeasReportPerUe = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RadioMeasReportPerUe |= L2MeasReportInterval(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadioMeasReportPerCell", wireType)
			}
			m.RadioMeasReportPerCell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RadioMeasReportPerCell |= L2MeasReportInterval(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedMeasReportPerUe", wireType)
			}
			m.SchedMeasReportPerUe = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchedMeasReportPerUe |= L2MeasReportInterval(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedMeasReportPerCell", wireType)
			}
			m.SchedMeasReportPerCell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SchedMeasReportPerCell |= L2MeasReportInterval(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PdcpMeasReportPerUe", wireType)
			}
			m.PdcpMeasReportPerUe = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PdcpMeasReportPerUe |= L2MeasReportInterval(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadioRepPerServCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadioRepPerServCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadioRepPerServCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CqiHist = append(m.CqiHist, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CqiHist) == 0 {
					m.CqiHist = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CqiHist = append(m.CqiHist, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CqiHist", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiHist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiHist = append(m.RiHist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PuschSinrHist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PuschSinrHist = append(m.PuschSinrHist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PucchSinrHist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PucchSinrHist = append(m.PucchSinrHist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadioMeasReportPerUE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadioMeasReportPerUE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadioMeasReportPerUE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadioReportServCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RadioReportServCells = append(m.RadioReportServCells, &RadioRepPerServCell{})
			if err := m.RadioReportServCells[len(m.RadioReportServCells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadioMeasReportPerCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadioMeasReportPerCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadioMeasReportPerCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PuschIntfPwrHist = append(m.PuschIntfPwrHist, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PuschIntfPwrHist) == 0 {
					m.PuschIntfPwrHist = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PuschIntfPwrHist = append(m.PuschIntfPwrHist, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PuschIntfPwrHist", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PucchIntfPowerHist = append(m.PucchIntfPowerHist, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PucchIntfPowerHist) == 0 {
					m.PucchIntfPowerHist = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PucchIntfPowerHist = append(m.PucchIntfPowerHist, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PucchIntfPowerHist", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PRBUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PRBUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PRBUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrbUsageDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrbUsageDl = append(m.PrbUsageDl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrbUsageUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrbUsageUl = append(m.PrbUsageUl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedMeasRepPerServCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedMeasRepPerServCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedMeasRepPerServCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QciVals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QciVals = append(m.QciVals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrbUsage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrbUsage == nil {
				m.PrbUsage = &PRBUsage{}
			}
			if err := m.PrbUsage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McsDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McsDl = append(m.McsDl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSchedTtisDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumSchedTtisDl = append(m.NumSchedTtisDl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McsUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McsUl = append(m.McsUl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSchedTtisUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumSchedTtisUl = append(m.NumSchedTtisUl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankDl1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankDl1 = append(m.RankDl1, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankDl2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankDl2 = append(m.RankDl2, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedMeasReportPerUE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedMeasReportPerUE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedMeasReportPerUE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedReportServCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchedReportServCells = append(m.SchedReportServCells, &SchedMeasRepPerServCell{})
			if err := m.SchedReportServCells[len(m.SchedReportServCells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedMeasReportPerCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedMeasReportPerCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedMeasReportPerCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QciVals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QciVals = append(m.QciVals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrbUsagePcell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrbUsagePcell == nil {
				m.PrbUsagePcell = &PRBUsage{}
			}
			if err := m.PrbUsagePcell.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrbUsageScell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrbUsageScell == nil {
				m.PrbUsageScell = &PRBUsage{}
			}
			if err := m.PrbUsageScell.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PDCPMeasReportPerUe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PDCPMeasReportPerUe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PDCPMeasReportPerUe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QciVals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QciVals = append(m.QciVals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DataVolDl = append(m.DataVolDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DataVolDl) == 0 {
					m.DataVolDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DataVolDl = append(m.DataVolDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DataVolDl", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DataVolUl = append(m.DataVolUl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DataVolUl) == 0 {
					m.DataVolUl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DataVolUl = append(m.DataVolUl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DataVolUl", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PktDelayDl = append(m.PktDelayDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PktDelayDl) == 0 {
					m.PktDelayDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PktDelayDl = append(m.PktDelayDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PktDelayDl", wireType)
			}
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PktDiscardRateDl = append(m.PktDiscardRateDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PktDiscardRateDl) == 0 {
					m.PktDiscardRateDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PktDiscardRateDl = append(m.PktDiscardRateDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PktDiscardRateDl", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PktLossRateDl = append(m.PktLossRateDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PktLossRateDl) == 0 {
					m.PktLossRateDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PktLossRateDl = append(m.PktLossRateDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PktLossRateDl", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PktLossRateUl = append(m.PktLossRateUl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PktLossRateUl) == 0 {
					m.PktLossRateUl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PktLossRateUl = append(m.PktLossRateUl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PktLossRateUl", wireType)
			}
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ThroughputDl = append(m.ThroughputDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ThroughputDl) == 0 {
					m.ThroughputDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ThroughputDl = append(m.ThroughputDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ThroughputDl", wireType)
			}
		case 11:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ThroughputUl = append(m.ThroughputUl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ThroughputUl) == 0 {
					m.ThroughputUl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ThroughputUl = append(m.ThroughputUl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ThroughputUl", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RRMConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RRMConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RRMConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = append(m.Crnti, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PciArfcn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PciArfcn == nil {
				m.PciArfcn = &PCIARFCN{}
			}
			if err := m.PciArfcn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v XICICPA
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= XICICPA(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PA = append(m.PA, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.PA) == 0 {
					m.PA = make([]XICICPA, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v XICICPA
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= XICICPA(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PA = append(m.PA, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PA", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StartPrbDl = append(m.StartPrbDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StartPrbDl) == 0 {
					m.StartPrbDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StartPrbDl = append(m.StartPrbDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPrbDl", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EndPrbDl = append(m.EndPrbDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EndPrbDl) == 0 {
					m.EndPrbDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EndPrbDl = append(m.EndPrbDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPrbDl", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubFrameBitmaskDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubFrameBitmaskDl = append(m.SubFrameBitmaskDl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.P0UePusch = append(m.P0UePusch, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.P0UePusch) == 0 {
					m.P0UePusch = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.P0UePusch = append(m.P0UePusch, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P0UePusch", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StartPrbUl = append(m.StartPrbUl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StartPrbUl) == 0 {
					m.StartPrbUl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StartPrbUl = append(m.StartPrbUl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPrbUl", wireType)
			}
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EndPrbUl = append(m.EndPrbUl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EndPrbUl) == 0 {
					m.EndPrbUl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EndPrbUl = append(m.EndPrbUl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPrbUl", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubFrameBitmaskUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubFrameBitmaskUl = append(m.SubFrameBitmaskUl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RRMConfigStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RRMConfigStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RRMConfigStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = append(m.Crnti, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v SuccessOrFailure
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= SuccessOrFailure(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]SuccessOrFailure, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v SuccessOrFailure
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= SuccessOrFailure(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CACap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CACap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CACap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Band", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Band = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caclassdl", wireType)
			}
			m.Caclassdl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Caclassdl |= CACapClassDl(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caclassul", wireType)
			}
			m.Caclassul = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Caclassul |= CACapClassUl(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossCarrierSched", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossCarrierSched = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DCCap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DCCap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DCCap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrbTypeSplit", wireType)
			}
			m.DrbTypeSplit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrbTypeSplit |= DCCapDrbType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UECapabilityEnquiry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UECapabilityEnquiry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UECapabilityEnquiry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UECapabilityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UECapabilityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UECapabilityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaCap == nil {
				m.CaCap = &CACap{}
			}
			if err := m.CaCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcCap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DcCap == nil {
				m.DcCap = &DCCap{}
			}
			if err := m.DcCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropScell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropScell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropScell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PciArfcn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PciArfcn == nil {
				m.PciArfcn = &PCIARFCN{}
			}
			if err := m.PciArfcn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossCarrierSchedEnable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossCarrierSchedEnable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaDirection", wireType)
			}
			m.CaDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaDirection |= CADirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeactTimer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeactTimer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScellAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScellAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScellAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScellsProp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScellsProp = append(m.ScellsProp, &PropScell{})
			if err := m.ScellsProp[len(m.ScellsProp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScellAddStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScellAddStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScellAddStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScellsInd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScellsInd = append(m.ScellsInd, &PCIARFCN{})
			if err := m.ScellsInd[len(m.ScellsInd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v SuccessOrFailure
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= SuccessOrFailure(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]SuccessOrFailure, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v SuccessOrFailure
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= SuccessOrFailure(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScellDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScellDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScellDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScellsInd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScellsInd = append(m.ScellsInd, &PCIARFCN{})
			if err := m.ScellsInd[len(m.ScellsInd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeNBAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeNBAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeNBAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MEcgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MEcgi == nil {
				m.MEcgi = &ECGI{}
			}
			if err := m.MEcgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SEcgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SEcgi == nil {
				m.SEcgi = &ECGI{}
			}
			if err := m.SEcgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeNBAddStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeNBAddStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeNBAddStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SuccessOrFailure(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeNBDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeNBDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeNBDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MEcgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MEcgi == nil {
				m.MEcgi = &ECGI{}
			}
			if err := m.MEcgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SEcgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SEcgi == nil {
				m.SEcgi = &ECGI{}
			}
			if err := m.SEcgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficSplitPercentage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficSplitPercentage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficSplitPercentage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPercentageDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrafficPercentageDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPercentageUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrafficPercentageUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficSplitConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficSplitConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficSplitConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficSplitPercentage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrafficSplitPercentage = append(m.TrafficSplitPercentage, &TrafficSplitPercentage{})
			if err := m.TrafficSplitPercentage[len(m.TrafficSplitPercentage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipE2Interface(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthE2Interface
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupE2Interface
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthE2Interface
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthE2Interface        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowE2Interface          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupE2Interface = fmt.Errorf("proto: unexpected end of group")
)
