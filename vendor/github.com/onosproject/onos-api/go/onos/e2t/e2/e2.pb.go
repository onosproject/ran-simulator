// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: onos/e2t/e2/e2.proto

// Package onos.e2t defines the interior gRPC interfaces for xApps to interact with E2T.

package e2

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EncodingType determines encoding type for the response messages
type EncodingType int32

const (
	EncodingType_PROTO    EncodingType = 0
	EncodingType_ASN1_PER EncodingType = 1
	EncodingType_ASN1_XER EncodingType = 2
)

var EncodingType_name = map[int32]string{
	0: "PROTO",
	1: "ASN1_PER",
	2: "ASN1_XER",
}

var EncodingType_value = map[string]int32{
	"PROTO":    0,
	"ASN1_PER": 1,
	"ASN1_XER": 2,
}

func (x EncodingType) String() string {
	return proto.EnumName(EncodingType_name, int32(x))
}

func (EncodingType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_706d69473e8d707d, []int{0}
}

// ResponseStatus
type ResponseStatus int32

const (
	ResponseStatus_FAILED    ResponseStatus = 0
	ResponseStatus_SUCCEEDED ResponseStatus = 1
)

var ResponseStatus_name = map[int32]string{
	0: "FAILED",
	1: "SUCCEEDED",
}

var ResponseStatus_value = map[string]int32{
	"FAILED":    0,
	"SUCCEEDED": 1,
}

func (x ResponseStatus) String() string {
	return proto.EnumName(ResponseStatus_name, int32(x))
}

func (ResponseStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_706d69473e8d707d, []int{1}
}

// ServiceModelInfo E2 service model information
type ServiceModelInfo struct {
	ServiceModelId string `protobuf:"bytes,1,opt,name=service_model_id,json=serviceModelId,proto3" json:"service_model_id,omitempty"`
}

func (m *ServiceModelInfo) Reset()         { *m = ServiceModelInfo{} }
func (m *ServiceModelInfo) String() string { return proto.CompactTextString(m) }
func (*ServiceModelInfo) ProtoMessage()    {}
func (*ServiceModelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_706d69473e8d707d, []int{0}
}
func (m *ServiceModelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceModelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceModelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceModelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceModelInfo.Merge(m, src)
}
func (m *ServiceModelInfo) XXX_Size() int {
	return m.Size()
}
func (m *ServiceModelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceModelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceModelInfo proto.InternalMessageInfo

func (m *ServiceModelInfo) GetServiceModelId() string {
	if m != nil {
		return m.ServiceModelId
	}
	return ""
}

// RequestHeader a common request header for all requests including encoding type, client/xApp/session info, ordering info, etc
type RequestHeader struct {
	EncodingType     EncodingType      `protobuf:"varint,1,opt,name=encoding_type,json=encodingType,proto3,enum=onos.e2t.e2.EncodingType" json:"encoding_type,omitempty"`
	ServiceModelInfo *ServiceModelInfo `protobuf:"bytes,2,opt,name=service_model_info,json=serviceModelInfo,proto3" json:"service_model_info,omitempty"`
}

func (m *RequestHeader) Reset()         { *m = RequestHeader{} }
func (m *RequestHeader) String() string { return proto.CompactTextString(m) }
func (*RequestHeader) ProtoMessage()    {}
func (*RequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_706d69473e8d707d, []int{1}
}
func (m *RequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestHeader.Merge(m, src)
}
func (m *RequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *RequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestHeader proto.InternalMessageInfo

func (m *RequestHeader) GetEncodingType() EncodingType {
	if m != nil {
		return m.EncodingType
	}
	return EncodingType_PROTO
}

func (m *RequestHeader) GetServiceModelInfo() *ServiceModelInfo {
	if m != nil {
		return m.ServiceModelInfo
	}
	return nil
}

// ResponseHeader a common response header for all responses including encoding type, client/xApp/session info, ordering info, etc
type ResponseHeader struct {
	EncodingType     EncodingType      `protobuf:"varint,1,opt,name=encoding_type,json=encodingType,proto3,enum=onos.e2t.e2.EncodingType" json:"encoding_type,omitempty"`
	ServiceModelInfo *ServiceModelInfo `protobuf:"bytes,2,opt,name=service_model_info,json=serviceModelInfo,proto3" json:"service_model_info,omitempty"`
	ResponseStatus   ResponseStatus    `protobuf:"varint,3,opt,name=response_status,json=responseStatus,proto3,enum=onos.e2t.e2.ResponseStatus" json:"response_status,omitempty"`
	IndicationHeader []byte            `protobuf:"bytes,4,opt,name=indication_header,json=indicationHeader,proto3" json:"indication_header,omitempty"`
}

func (m *ResponseHeader) Reset()         { *m = ResponseHeader{} }
func (m *ResponseHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseHeader) ProtoMessage()    {}
func (*ResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_706d69473e8d707d, []int{2}
}
func (m *ResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseHeader.Merge(m, src)
}
func (m *ResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseHeader proto.InternalMessageInfo

func (m *ResponseHeader) GetEncodingType() EncodingType {
	if m != nil {
		return m.EncodingType
	}
	return EncodingType_PROTO
}

func (m *ResponseHeader) GetServiceModelInfo() *ServiceModelInfo {
	if m != nil {
		return m.ServiceModelInfo
	}
	return nil
}

func (m *ResponseHeader) GetResponseStatus() ResponseStatus {
	if m != nil {
		return m.ResponseStatus
	}
	return ResponseStatus_FAILED
}

func (m *ResponseHeader) GetIndicationHeader() []byte {
	if m != nil {
		return m.IndicationHeader
	}
	return nil
}

// StreamRequest
type StreamRequest struct {
	Header         *RequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	AppID          AppID          `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3,casttype=AppID" json:"app_id,omitempty"`
	InstanceID     InstanceID     `protobuf:"bytes,3,opt,name=instance_id,json=instanceId,proto3,casttype=InstanceID" json:"instance_id,omitempty"`
	SubscriptionID SubscriptionID `protobuf:"bytes,4,opt,name=subscription_id,json=subscriptionId,proto3,casttype=SubscriptionID" json:"subscription_id,omitempty"`
}

func (m *StreamRequest) Reset()         { *m = StreamRequest{} }
func (m *StreamRequest) String() string { return proto.CompactTextString(m) }
func (*StreamRequest) ProtoMessage()    {}
func (*StreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_706d69473e8d707d, []int{3}
}
func (m *StreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamRequest.Merge(m, src)
}
func (m *StreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *StreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_StreamRequest proto.InternalMessageInfo

func (m *StreamRequest) GetHeader() *RequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *StreamRequest) GetAppID() AppID {
	if m != nil {
		return m.AppID
	}
	return ""
}

func (m *StreamRequest) GetInstanceID() InstanceID {
	if m != nil {
		return m.InstanceID
	}
	return ""
}

func (m *StreamRequest) GetSubscriptionID() SubscriptionID {
	if m != nil {
		return m.SubscriptionID
	}
	return ""
}

// StreamResponse
type StreamResponse struct {
	Header            *ResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	IndicationMessage []byte          `protobuf:"bytes,2,opt,name=indication_message,json=indicationMessage,proto3" json:"indication_message,omitempty"`
}

func (m *StreamResponse) Reset()         { *m = StreamResponse{} }
func (m *StreamResponse) String() string { return proto.CompactTextString(m) }
func (*StreamResponse) ProtoMessage()    {}
func (*StreamResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_706d69473e8d707d, []int{4}
}
func (m *StreamResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamResponse.Merge(m, src)
}
func (m *StreamResponse) XXX_Size() int {
	return m.Size()
}
func (m *StreamResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StreamResponse proto.InternalMessageInfo

func (m *StreamResponse) GetHeader() *ResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *StreamResponse) GetIndicationMessage() []byte {
	if m != nil {
		return m.IndicationMessage
	}
	return nil
}

func init() {
	proto.RegisterEnum("onos.e2t.e2.EncodingType", EncodingType_name, EncodingType_value)
	proto.RegisterEnum("onos.e2t.e2.ResponseStatus", ResponseStatus_name, ResponseStatus_value)
	proto.RegisterType((*ServiceModelInfo)(nil), "onos.e2t.e2.ServiceModelInfo")
	proto.RegisterType((*RequestHeader)(nil), "onos.e2t.e2.RequestHeader")
	proto.RegisterType((*ResponseHeader)(nil), "onos.e2t.e2.ResponseHeader")
	proto.RegisterType((*StreamRequest)(nil), "onos.e2t.e2.StreamRequest")
	proto.RegisterType((*StreamResponse)(nil), "onos.e2t.e2.StreamResponse")
}

func init() { proto.RegisterFile("onos/e2t/e2/e2.proto", fileDescriptor_706d69473e8d707d) }

var fileDescriptor_706d69473e8d707d = []byte{
	// 556 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x54, 0xc1, 0x6e, 0xd3, 0x4c,
	0x10, 0xce, 0xa6, 0x7f, 0xa2, 0x3f, 0x93, 0xc4, 0x35, 0xab, 0x1e, 0x42, 0x0a, 0x4e, 0x14, 0x71,
	0x08, 0xad, 0x48, 0xc0, 0x15, 0x37, 0x40, 0x4a, 0x1a, 0x23, 0x2c, 0x08, 0xad, 0xd6, 0x41, 0xe2,
	0x66, 0xb9, 0xf1, 0x34, 0x58, 0x22, 0x5e, 0xe3, 0x75, 0x90, 0xfa, 0x16, 0x7d, 0x00, 0x1e, 0x88,
	0x63, 0x8f, 0x9c, 0x22, 0xe4, 0xbc, 0x05, 0xe2, 0x80, 0xbc, 0x76, 0xa8, 0x63, 0xf5, 0x01, 0xb8,
	0x79, 0xbe, 0xf9, 0x66, 0x67, 0xbe, 0xf9, 0x46, 0x86, 0x03, 0xee, 0x73, 0x31, 0x44, 0x3d, 0x1a,
	0xa2, 0x3e, 0x44, 0x7d, 0x10, 0x84, 0x3c, 0xe2, 0xb4, 0x9e, 0xa0, 0x03, 0xd4, 0xa3, 0x01, 0xea,
	0xed, 0x83, 0x05, 0x5f, 0x70, 0x89, 0x0f, 0x93, 0xaf, 0x94, 0xd2, 0x7b, 0x01, 0xaa, 0x85, 0xe1,
	0x57, 0x6f, 0x8e, 0x53, 0xee, 0xe2, 0x67, 0xd3, 0xbf, 0xe4, 0xb4, 0x0f, 0xaa, 0x48, 0x31, 0x7b,
	0x99, 0x80, 0xb6, 0xe7, 0xb6, 0x48, 0x97, 0xf4, 0x6b, 0x4c, 0x11, 0x79, 0xae, 0xdb, 0xfb, 0x46,
	0xa0, 0xc9, 0xf0, 0xcb, 0x0a, 0x45, 0xf4, 0x06, 0x1d, 0x17, 0x43, 0xfa, 0x0a, 0x9a, 0xe8, 0xcf,
	0xb9, 0xeb, 0xf9, 0x0b, 0x3b, 0xba, 0x0a, 0x50, 0x16, 0x2a, 0xfa, 0xfd, 0x41, 0x6e, 0x94, 0x81,
	0x91, 0x31, 0x66, 0x57, 0x01, 0xb2, 0x06, 0xe6, 0x22, 0xfa, 0x16, 0x68, 0xa1, 0xb7, 0x7f, 0xc9,
	0x5b, 0xe5, 0x2e, 0xe9, 0xd7, 0xf5, 0x87, 0x3b, 0x8f, 0x14, 0xc7, 0x66, 0xaa, 0x28, 0x20, 0xbd,
	0xeb, 0x32, 0x28, 0x0c, 0x45, 0xc0, 0x7d, 0x81, 0xff, 0xe0, 0x7c, 0x74, 0x02, 0xfb, 0x61, 0x36,
	0x9e, 0x2d, 0x22, 0x27, 0x5a, 0x89, 0xd6, 0x9e, 0x1c, 0xe7, 0x70, 0xe7, 0xa5, 0xad, 0x04, 0x4b,
	0x52, 0x98, 0x12, 0xee, 0xc4, 0xf4, 0x18, 0xee, 0x79, 0xbe, 0xeb, 0xcd, 0x9d, 0xc8, 0xe3, 0xbe,
	0xfd, 0x49, 0xea, 0x6c, 0xfd, 0xd7, 0x25, 0xfd, 0x06, 0x53, 0x6f, 0x13, 0xa9, 0xfe, 0xde, 0x6f,
	0x02, 0x4d, 0x2b, 0x0a, 0xd1, 0x59, 0x66, 0xbe, 0x51, 0x1d, 0xaa, 0x59, 0x0d, 0x91, 0x2a, 0xda,
	0x85, 0xde, 0x39, 0x77, 0x59, 0xc6, 0xa4, 0x8f, 0xa1, 0xea, 0x04, 0x41, 0x72, 0x17, 0x89, 0xf2,
	0xda, 0x98, 0xc6, 0xeb, 0x4e, 0x65, 0x14, 0x04, 0xe6, 0xe4, 0xd7, 0xf6, 0x83, 0x55, 0x9c, 0x20,
	0x30, 0x5d, 0xfa, 0x12, 0xea, 0x9e, 0x2f, 0x22, 0xc7, 0x9f, 0x63, 0xc2, 0xdf, 0x93, 0xfc, 0x07,
	0xf1, 0xba, 0x03, 0x66, 0x06, 0xcb, 0xa2, 0x5c, 0xc4, 0x60, 0x5b, 0x60, 0xba, 0x74, 0x0a, 0xfb,
	0x62, 0x75, 0x21, 0xe6, 0xa1, 0x17, 0x48, 0x79, 0x9e, 0x2b, 0xa5, 0xd5, 0xc6, 0x8f, 0xe2, 0x75,
	0x47, 0xb1, 0x72, 0x29, 0xf9, 0x4c, 0x01, 0x61, 0x4a, 0xbe, 0xd8, 0x74, 0x7b, 0x11, 0x28, 0x5b,
	0xf5, 0xe9, 0x0e, 0xe9, 0x49, 0x41, 0xfe, 0xdd, 0xab, 0x2f, 0xe8, 0x7f, 0x02, 0x34, 0xb7, 0xf2,
	0x25, 0x0a, 0xe1, 0x2c, 0x50, 0xee, 0xa2, 0xc1, 0x72, 0x66, 0x4c, 0xd3, 0xc4, 0xd1, 0x73, 0x68,
	0xe4, 0x4f, 0x8a, 0xd6, 0xa0, 0x72, 0xce, 0xce, 0x66, 0x67, 0x6a, 0x89, 0x36, 0xe0, 0xff, 0x91,
	0xf5, 0xfe, 0x99, 0x7d, 0x6e, 0x30, 0x95, 0xfc, 0x8d, 0x3e, 0x1a, 0x4c, 0x2d, 0x1f, 0x1d, 0xdf,
	0x5e, 0x6f, 0x66, 0x35, 0x40, 0xf5, 0xf5, 0xc8, 0x7c, 0x67, 0x4c, 0xd4, 0x12, 0x6d, 0x42, 0xcd,
	0xfa, 0x70, 0x7a, 0x6a, 0x18, 0x13, 0x63, 0xa2, 0x12, 0xdd, 0x02, 0x30, 0xf4, 0x59, 0x76, 0x74,
	0xd4, 0x80, 0x6a, 0xaa, 0x93, 0xee, 0xda, 0xb9, 0x63, 0x7d, 0xfb, 0xf0, 0xce, 0x5c, 0xda, 0xb1,
	0x4f, 0x9e, 0x92, 0x71, 0xeb, 0x7b, 0xac, 0x91, 0x9b, 0x58, 0x23, 0x3f, 0x63, 0x8d, 0x5c, 0x6f,
	0xb4, 0xd2, 0xcd, 0x46, 0x2b, 0xfd, 0xd8, 0x68, 0xa5, 0x8b, 0xaa, 0xfc, 0x7d, 0x9c, 0xfc, 0x09,
	0x00, 0x00, 0xff, 0xff, 0xc4, 0xc7, 0x7f, 0xf6, 0x79, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// E2TServiceClient is the client API for E2TService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type E2TServiceClient interface {
	// Stream opens an indications stream
	Stream(ctx context.Context, opts ...grpc.CallOption) (E2TService_StreamClient, error)
}

type e2TServiceClient struct {
	cc *grpc.ClientConn
}

func NewE2TServiceClient(cc *grpc.ClientConn) E2TServiceClient {
	return &e2TServiceClient{cc}
}

func (c *e2TServiceClient) Stream(ctx context.Context, opts ...grpc.CallOption) (E2TService_StreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_E2TService_serviceDesc.Streams[0], "/onos.e2t.e2.E2TService/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &e2TServiceStreamClient{stream}
	return x, nil
}

type E2TService_StreamClient interface {
	Send(*StreamRequest) error
	Recv() (*StreamResponse, error)
	grpc.ClientStream
}

type e2TServiceStreamClient struct {
	grpc.ClientStream
}

func (x *e2TServiceStreamClient) Send(m *StreamRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *e2TServiceStreamClient) Recv() (*StreamResponse, error) {
	m := new(StreamResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// E2TServiceServer is the server API for E2TService service.
type E2TServiceServer interface {
	// Stream opens an indications stream
	Stream(E2TService_StreamServer) error
}

// UnimplementedE2TServiceServer can be embedded to have forward compatible implementations.
type UnimplementedE2TServiceServer struct {
}

func (*UnimplementedE2TServiceServer) Stream(srv E2TService_StreamServer) error {
	return status.Errorf(codes.Unimplemented, "method Stream not implemented")
}

func RegisterE2TServiceServer(s *grpc.Server, srv E2TServiceServer) {
	s.RegisterService(&_E2TService_serviceDesc, srv)
}

func _E2TService_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(E2TServiceServer).Stream(&e2TServiceStreamServer{stream})
}

type E2TService_StreamServer interface {
	Send(*StreamResponse) error
	Recv() (*StreamRequest, error)
	grpc.ServerStream
}

type e2TServiceStreamServer struct {
	grpc.ServerStream
}

func (x *e2TServiceStreamServer) Send(m *StreamResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *e2TServiceStreamServer) Recv() (*StreamRequest, error) {
	m := new(StreamRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _E2TService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "onos.e2t.e2.E2TService",
	HandlerType: (*E2TServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _E2TService_Stream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "onos/e2t/e2/e2.proto",
}

func (m *ServiceModelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceModelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceModelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServiceModelId) > 0 {
		i -= len(m.ServiceModelId)
		copy(dAtA[i:], m.ServiceModelId)
		i = encodeVarintE2(dAtA, i, uint64(len(m.ServiceModelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServiceModelInfo != nil {
		{
			size, err := m.ServiceModelInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EncodingType != 0 {
		i = encodeVarintE2(dAtA, i, uint64(m.EncodingType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IndicationHeader) > 0 {
		i -= len(m.IndicationHeader)
		copy(dAtA[i:], m.IndicationHeader)
		i = encodeVarintE2(dAtA, i, uint64(len(m.IndicationHeader)))
		i--
		dAtA[i] = 0x22
	}
	if m.ResponseStatus != 0 {
		i = encodeVarintE2(dAtA, i, uint64(m.ResponseStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.ServiceModelInfo != nil {
		{
			size, err := m.ServiceModelInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.EncodingType != 0 {
		i = encodeVarintE2(dAtA, i, uint64(m.EncodingType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubscriptionID) > 0 {
		i -= len(m.SubscriptionID)
		copy(dAtA[i:], m.SubscriptionID)
		i = encodeVarintE2(dAtA, i, uint64(len(m.SubscriptionID)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.InstanceID) > 0 {
		i -= len(m.InstanceID)
		copy(dAtA[i:], m.InstanceID)
		i = encodeVarintE2(dAtA, i, uint64(len(m.InstanceID)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AppID) > 0 {
		i -= len(m.AppID)
		copy(dAtA[i:], m.AppID)
		i = encodeVarintE2(dAtA, i, uint64(len(m.AppID)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StreamResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IndicationMessage) > 0 {
		i -= len(m.IndicationMessage)
		copy(dAtA[i:], m.IndicationMessage)
		i = encodeVarintE2(dAtA, i, uint64(len(m.IndicationMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintE2(dAtA []byte, offset int, v uint64) int {
	offset -= sovE2(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ServiceModelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ServiceModelId)
	if l > 0 {
		n += 1 + l + sovE2(uint64(l))
	}
	return n
}

func (m *RequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EncodingType != 0 {
		n += 1 + sovE2(uint64(m.EncodingType))
	}
	if m.ServiceModelInfo != nil {
		l = m.ServiceModelInfo.Size()
		n += 1 + l + sovE2(uint64(l))
	}
	return n
}

func (m *ResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EncodingType != 0 {
		n += 1 + sovE2(uint64(m.EncodingType))
	}
	if m.ServiceModelInfo != nil {
		l = m.ServiceModelInfo.Size()
		n += 1 + l + sovE2(uint64(l))
	}
	if m.ResponseStatus != 0 {
		n += 1 + sovE2(uint64(m.ResponseStatus))
	}
	l = len(m.IndicationHeader)
	if l > 0 {
		n += 1 + l + sovE2(uint64(l))
	}
	return n
}

func (m *StreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovE2(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovE2(uint64(l))
	}
	l = len(m.InstanceID)
	if l > 0 {
		n += 1 + l + sovE2(uint64(l))
	}
	l = len(m.SubscriptionID)
	if l > 0 {
		n += 1 + l + sovE2(uint64(l))
	}
	return n
}

func (m *StreamResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovE2(uint64(l))
	}
	l = len(m.IndicationMessage)
	if l > 0 {
		n += 1 + l + sovE2(uint64(l))
	}
	return n
}

func sovE2(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozE2(x uint64) (n int) {
	return sovE2(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ServiceModelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceModelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceModelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodingType", wireType)
			}
			m.EncodingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncodingType |= EncodingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceModelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceModelInfo == nil {
				m.ServiceModelInfo = &ServiceModelInfo{}
			}
			if err := m.ServiceModelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncodingType", wireType)
			}
			m.EncodingType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EncodingType |= EncodingType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceModelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceModelInfo == nil {
				m.ServiceModelInfo = &ServiceModelInfo{}
			}
			if err := m.ServiceModelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseStatus", wireType)
			}
			m.ResponseStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResponseStatus |= ResponseStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndicationHeader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthE2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthE2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndicationHeader = append(m.IndicationHeader[:0], dAtA[iNdEx:postIndex]...)
			if m.IndicationHeader == nil {
				m.IndicationHeader = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = AppID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceID = InstanceID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubscriptionID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubscriptionID = SubscriptionID(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &ResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndicationMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthE2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthE2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IndicationMessage = append(m.IndicationMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.IndicationMessage == nil {
				m.IndicationMessage = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipE2(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowE2
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowE2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowE2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthE2
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupE2
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthE2
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthE2        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowE2          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupE2 = fmt.Errorf("proto: unexpected end of group")
)
