// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/e2/e2-interface.proto

package e2

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Definition of all message types in E2 interface
type MessageType int32

const (
	MessageType_UNKNOWN_MESSAGE            MessageType = 0
	MessageType_CELL_CONFIG_REQUEST        MessageType = 1
	MessageType_CELL_CONFIG_REPORT         MessageType = 2
	MessageType_UE_ADMISSION_REQUEST       MessageType = 3
	MessageType_UE_ADMISSION_RESPONSE      MessageType = 4
	MessageType_UE_ADMISSION_STATUS        MessageType = 5
	MessageType_UE_CONTEXT_UPDATE          MessageType = 6
	MessageType_UE_RECONFIG_IND            MessageType = 7
	MessageType_UE_RELEASE_IND             MessageType = 8
	MessageType_BEARER_ADMISSION_REQUEST   MessageType = 9
	MessageType_BEARER_ADMISSION_RESPONSE  MessageType = 10
	MessageType_BEARER_ADMISSION_STATUS    MessageType = 11
	MessageType_BEARER_RELEASE_IND         MessageType = 12
	MessageType_HO_REQUEST                 MessageType = 13
	MessageType_HO_FAILURE                 MessageType = 14
	MessageType_HO_COMPLETE                MessageType = 15
	MessageType_RXSIG_MEAS_REPORT          MessageType = 16
	MessageType_L2_MEAS_CONFIG             MessageType = 17
	MessageType_RADIO_MEAS_REPORT_PER_UE   MessageType = 18
	MessageType_RADIO_MEAS_REPORT_PER_CELL MessageType = 19
	MessageType_SCHED_MEAS_REPORT_PER_UE   MessageType = 20
	MessageType_SCHED_MEAS_REPORT_PER_CELL MessageType = 21
	MessageType_PDCP_MEAS_REPORT_PER_UE    MessageType = 22
	MessageType_UE_CAPABILITY_INFO         MessageType = 23
	MessageType_UE_CAPABILITY_ENQUIRY      MessageType = 24
	MessageType_SCELL_ADD                  MessageType = 25
	MessageType_SCELL_ADD_STATUS           MessageType = 26
	MessageType_SCELL_DELETE               MessageType = 27
	MessageType_RRM_CONFIG                 MessageType = 28
	MessageType_RRM_CONFIG_STATUS          MessageType = 29
	MessageType_SENB_ADD                   MessageType = 30
	MessageType_SENB_ADD_STATUS            MessageType = 31
	MessageType_SENB_DELETE                MessageType = 32
	MessageType_TRAFFIC_SPLIT_CONFIG       MessageType = 33
	MessageType_HO_CAUSE                   MessageType = 34
	MessageType_RRC_MEAS_CONFIG            MessageType = 35
)

var MessageType_name = map[int32]string{
	0:  "UNKNOWN_MESSAGE",
	1:  "CELL_CONFIG_REQUEST",
	2:  "CELL_CONFIG_REPORT",
	3:  "UE_ADMISSION_REQUEST",
	4:  "UE_ADMISSION_RESPONSE",
	5:  "UE_ADMISSION_STATUS",
	6:  "UE_CONTEXT_UPDATE",
	7:  "UE_RECONFIG_IND",
	8:  "UE_RELEASE_IND",
	9:  "BEARER_ADMISSION_REQUEST",
	10: "BEARER_ADMISSION_RESPONSE",
	11: "BEARER_ADMISSION_STATUS",
	12: "BEARER_RELEASE_IND",
	13: "HO_REQUEST",
	14: "HO_FAILURE",
	15: "HO_COMPLETE",
	16: "RXSIG_MEAS_REPORT",
	17: "L2_MEAS_CONFIG",
	18: "RADIO_MEAS_REPORT_PER_UE",
	19: "RADIO_MEAS_REPORT_PER_CELL",
	20: "SCHED_MEAS_REPORT_PER_UE",
	21: "SCHED_MEAS_REPORT_PER_CELL",
	22: "PDCP_MEAS_REPORT_PER_UE",
	23: "UE_CAPABILITY_INFO",
	24: "UE_CAPABILITY_ENQUIRY",
	25: "SCELL_ADD",
	26: "SCELL_ADD_STATUS",
	27: "SCELL_DELETE",
	28: "RRM_CONFIG",
	29: "RRM_CONFIG_STATUS",
	30: "SENB_ADD",
	31: "SENB_ADD_STATUS",
	32: "SENB_DELETE",
	33: "TRAFFIC_SPLIT_CONFIG",
	34: "HO_CAUSE",
	35: "RRC_MEAS_CONFIG",
}

var MessageType_value = map[string]int32{
	"UNKNOWN_MESSAGE":            0,
	"CELL_CONFIG_REQUEST":        1,
	"CELL_CONFIG_REPORT":         2,
	"UE_ADMISSION_REQUEST":       3,
	"UE_ADMISSION_RESPONSE":      4,
	"UE_ADMISSION_STATUS":        5,
	"UE_CONTEXT_UPDATE":          6,
	"UE_RECONFIG_IND":            7,
	"UE_RELEASE_IND":             8,
	"BEARER_ADMISSION_REQUEST":   9,
	"BEARER_ADMISSION_RESPONSE":  10,
	"BEARER_ADMISSION_STATUS":    11,
	"BEARER_RELEASE_IND":         12,
	"HO_REQUEST":                 13,
	"HO_FAILURE":                 14,
	"HO_COMPLETE":                15,
	"RXSIG_MEAS_REPORT":          16,
	"L2_MEAS_CONFIG":             17,
	"RADIO_MEAS_REPORT_PER_UE":   18,
	"RADIO_MEAS_REPORT_PER_CELL": 19,
	"SCHED_MEAS_REPORT_PER_UE":   20,
	"SCHED_MEAS_REPORT_PER_CELL": 21,
	"PDCP_MEAS_REPORT_PER_UE":    22,
	"UE_CAPABILITY_INFO":         23,
	"UE_CAPABILITY_ENQUIRY":      24,
	"SCELL_ADD":                  25,
	"SCELL_ADD_STATUS":           26,
	"SCELL_DELETE":               27,
	"RRM_CONFIG":                 28,
	"RRM_CONFIG_STATUS":          29,
	"SENB_ADD":                   30,
	"SENB_ADD_STATUS":            31,
	"SENB_DELETE":                32,
	"TRAFFIC_SPLIT_CONFIG":       33,
	"HO_CAUSE":                   34,
	"RRC_MEAS_CONFIG":            35,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{0}
}

type AdmEstCause int32

const (
	AdmEstCause_EMERGENCY     AdmEstCause = 0
	AdmEstCause_HIGHHP_ACCESS AdmEstCause = 1
	AdmEstCause_MT_ACCESS     AdmEstCause = 2
	AdmEstCause_MO_SIGNALLING AdmEstCause = 3
	AdmEstCause_MO_DATA       AdmEstCause = 4
)

var AdmEstCause_name = map[int32]string{
	0: "EMERGENCY",
	1: "HIGHHP_ACCESS",
	2: "MT_ACCESS",
	3: "MO_SIGNALLING",
	4: "MO_DATA",
}

var AdmEstCause_value = map[string]int32{
	"EMERGENCY":     0,
	"HIGHHP_ACCESS": 1,
	"MT_ACCESS":     2,
	"MO_SIGNALLING": 3,
	"MO_DATA":       4,
}

func (x AdmEstCause) String() string {
	return proto.EnumName(AdmEstCause_name, int32(x))
}

func (AdmEstCause) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{1}
}

type SuccessOrFailure int32

const (
	SuccessOrFailure_SUCCESS SuccessOrFailure = 0
	SuccessOrFailure_FAILURE SuccessOrFailure = 1
)

var SuccessOrFailure_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILURE",
}

var SuccessOrFailure_value = map[string]int32{
	"SUCCESS": 0,
	"FAILURE": 1,
}

func (x SuccessOrFailure) String() string {
	return proto.EnumName(SuccessOrFailure_name, int32(x))
}

func (SuccessOrFailure) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{2}
}

type ReconfigCause int32

const (
	ReconfigCause_RECONFIG_RLF     ReconfigCause = 0
	ReconfigCause_RECONFIG_HO_FAIL ReconfigCause = 1
	ReconfigCause_RECONFIG_OTHERS  ReconfigCause = 2
)

var ReconfigCause_name = map[int32]string{
	0: "RECONFIG_RLF",
	1: "RECONFIG_HO_FAIL",
	2: "RECONFIG_OTHERS",
}

var ReconfigCause_value = map[string]int32{
	"RECONFIG_RLF":     0,
	"RECONFIG_HO_FAIL": 1,
	"RECONFIG_OTHERS":  2,
}

func (x ReconfigCause) String() string {
	return proto.EnumName(ReconfigCause_name, int32(x))
}

func (ReconfigCause) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{3}
}

type ReleaseCause int32

const (
	ReleaseCause_RELEASE_INACTIVITY ReleaseCause = 0
	ReleaseCause_RELEASE_RLF        ReleaseCause = 1
	ReleaseCause_RELEASE_OTHERS     ReleaseCause = 2
)

var ReleaseCause_name = map[int32]string{
	0: "RELEASE_INACTIVITY",
	1: "RELEASE_RLF",
	2: "RELEASE_OTHERS",
}

var ReleaseCause_value = map[string]int32{
	"RELEASE_INACTIVITY": 0,
	"RELEASE_RLF":        1,
	"RELEASE_OTHERS":     2,
}

func (x ReleaseCause) String() string {
	return proto.EnumName(ReleaseCause_name, int32(x))
}

func (ReleaseCause) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{4}
}

type ERABDirection int32

const (
	ERABDirection_DL   ERABDirection = 0
	ERABDirection_UL   ERABDirection = 1
	ERABDirection_BOTH ERABDirection = 2
)

var ERABDirection_name = map[int32]string{
	0: "DL",
	1: "UL",
	2: "BOTH",
}

var ERABDirection_value = map[string]int32{
	"DL":   0,
	"UL":   1,
	"BOTH": 2,
}

func (x ERABDirection) String() string {
	return proto.EnumName(ERABDirection_name, int32(x))
}

func (ERABDirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{5}
}

type ERABType int32

const (
	ERABType_ERAB_DEFAULT   ERABType = 0
	ERABType_ERAB_DEDICATED ERABType = 1
)

var ERABType_name = map[int32]string{
	0: "ERAB_DEFAULT",
	1: "ERAB_DEDICATED",
}

var ERABType_value = map[string]int32{
	"ERAB_DEFAULT":   0,
	"ERAB_DEDICATED": 1,
}

func (x ERABType) String() string {
	return proto.EnumName(ERABType_name, int32(x))
}

func (ERABType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{6}
}

type ReportParamPR int32

const (
	ReportParamPR_REPORT_PARAM_PR_NOTHING   ReportParamPR = 0
	ReportParamPR_REPORT_PARAM_PR_PER_PARAM ReportParamPR = 1
	ReportParamPR_REPORT_PARAM_PR_A1PARAM   ReportParamPR = 2
	ReportParamPR_REPORT_PARAM_PR_A2PARAM   ReportParamPR = 3
	ReportParamPR_REPORT_PARAM_PR_A3PARAM   ReportParamPR = 4
	ReportParamPR_REPORT_PARAM_PR_A4PARAM   ReportParamPR = 5
	ReportParamPR_REPORT_PARAM_PR_A5PARAM   ReportParamPR = 6
	ReportParamPR_REPORT_PARAM_PR_A6PARAM   ReportParamPR = 7
)

var ReportParamPR_name = map[int32]string{
	0: "REPORT_PARAM_PR_NOTHING",
	1: "REPORT_PARAM_PR_PER_PARAM",
	2: "REPORT_PARAM_PR_A1PARAM",
	3: "REPORT_PARAM_PR_A2PARAM",
	4: "REPORT_PARAM_PR_A3PARAM",
	5: "REPORT_PARAM_PR_A4PARAM",
	6: "REPORT_PARAM_PR_A5PARAM",
	7: "REPORT_PARAM_PR_A6PARAM",
}

var ReportParamPR_value = map[string]int32{
	"REPORT_PARAM_PR_NOTHING":   0,
	"REPORT_PARAM_PR_PER_PARAM": 1,
	"REPORT_PARAM_PR_A1PARAM":   2,
	"REPORT_PARAM_PR_A2PARAM":   3,
	"REPORT_PARAM_PR_A3PARAM":   4,
	"REPORT_PARAM_PR_A4PARAM":   5,
	"REPORT_PARAM_PR_A5PARAM":   6,
	"REPORT_PARAM_PR_A6PARAM":   7,
}

func (x ReportParamPR) String() string {
	return proto.EnumName(ReportParamPR_name, int32(x))
}

func (ReportParamPR) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{7}
}

type PerParamReportIntervalMs int32

const (
	PerParamReportIntervalMs_PER_PARAM_MS_120   PerParamReportIntervalMs = 0
	PerParamReportIntervalMs_PER_PARAM_MS_240   PerParamReportIntervalMs = 1
	PerParamReportIntervalMs_PER_PARAM_MS_480   PerParamReportIntervalMs = 2
	PerParamReportIntervalMs_PER_PARAM_MS_640   PerParamReportIntervalMs = 3
	PerParamReportIntervalMs_PER_PARAM_MS_1024  PerParamReportIntervalMs = 4
	PerParamReportIntervalMs_PER_PARAM_MS_2048  PerParamReportIntervalMs = 5
	PerParamReportIntervalMs_PER_PARAM_MS_5120  PerParamReportIntervalMs = 6
	PerParamReportIntervalMs_PER_PARAM_MS_10240 PerParamReportIntervalMs = 7
	PerParamReportIntervalMs_PER_PARAM_MIN_1    PerParamReportIntervalMs = 8
	PerParamReportIntervalMs_PER_PARAM_MIN_6    PerParamReportIntervalMs = 9
	PerParamReportIntervalMs_PER_PARAM_MIN_12   PerParamReportIntervalMs = 10
	PerParamReportIntervalMs_PER_PARAM_MIN_30   PerParamReportIntervalMs = 11
	PerParamReportIntervalMs_PER_PARAM_MIN_60   PerParamReportIntervalMs = 12
)

var PerParamReportIntervalMs_name = map[int32]string{
	0:  "PER_PARAM_MS_120",
	1:  "PER_PARAM_MS_240",
	2:  "PER_PARAM_MS_480",
	3:  "PER_PARAM_MS_640",
	4:  "PER_PARAM_MS_1024",
	5:  "PER_PARAM_MS_2048",
	6:  "PER_PARAM_MS_5120",
	7:  "PER_PARAM_MS_10240",
	8:  "PER_PARAM_MIN_1",
	9:  "PER_PARAM_MIN_6",
	10: "PER_PARAM_MIN_12",
	11: "PER_PARAM_MIN_30",
	12: "PER_PARAM_MIN_60",
}

var PerParamReportIntervalMs_value = map[string]int32{
	"PER_PARAM_MS_120":   0,
	"PER_PARAM_MS_240":   1,
	"PER_PARAM_MS_480":   2,
	"PER_PARAM_MS_640":   3,
	"PER_PARAM_MS_1024":  4,
	"PER_PARAM_MS_2048":  5,
	"PER_PARAM_MS_5120":  6,
	"PER_PARAM_MS_10240": 7,
	"PER_PARAM_MIN_1":    8,
	"PER_PARAM_MIN_6":    9,
	"PER_PARAM_MIN_12":   10,
	"PER_PARAM_MIN_30":   11,
	"PER_PARAM_MIN_60":   12,
}

func (x PerParamReportIntervalMs) String() string {
	return proto.EnumName(PerParamReportIntervalMs_name, int32(x))
}

func (PerParamReportIntervalMs) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{8}
}

type ThresholdEUTRAPR int32

const (
	ThresholdEUTRAPR_THRESHOLD_EUTRA_PR_NOTHING ThresholdEUTRAPR = 0
	ThresholdEUTRAPR_THRESHOLD_EUTRA_PR_RSRP    ThresholdEUTRAPR = 1
	ThresholdEUTRAPR_THRESHOLD_EUTRA_PR_RSRQ    ThresholdEUTRAPR = 2
)

var ThresholdEUTRAPR_name = map[int32]string{
	0: "THRESHOLD_EUTRA_PR_NOTHING",
	1: "THRESHOLD_EUTRA_PR_RSRP",
	2: "THRESHOLD_EUTRA_PR_RSRQ",
}

var ThresholdEUTRAPR_value = map[string]int32{
	"THRESHOLD_EUTRA_PR_NOTHING": 0,
	"THRESHOLD_EUTRA_PR_RSRP":    1,
	"THRESHOLD_EUTRA_PR_RSRQ":    2,
}

func (x ThresholdEUTRAPR) String() string {
	return proto.EnumName(ThresholdEUTRAPR_name, int32(x))
}

func (ThresholdEUTRAPR) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{9}
}

type TimeToTrigger int32

const (
	TimeToTrigger_TTT_MS0    TimeToTrigger = 0
	TimeToTrigger_TTT_MS40   TimeToTrigger = 1
	TimeToTrigger_TTT_MS64   TimeToTrigger = 2
	TimeToTrigger_TTT_MS80   TimeToTrigger = 3
	TimeToTrigger_TTT_MS100  TimeToTrigger = 4
	TimeToTrigger_TTT_MS128  TimeToTrigger = 5
	TimeToTrigger_TTT_MS160  TimeToTrigger = 6
	TimeToTrigger_TTT_MS256  TimeToTrigger = 7
	TimeToTrigger_TTT_MS320  TimeToTrigger = 8
	TimeToTrigger_TTT_MS480  TimeToTrigger = 9
	TimeToTrigger_TTT_MS512  TimeToTrigger = 10
	TimeToTrigger_TTT_MS640  TimeToTrigger = 11
	TimeToTrigger_TTT_MS1024 TimeToTrigger = 12
	TimeToTrigger_TTT_MS1280 TimeToTrigger = 13
	TimeToTrigger_TTT_MS2560 TimeToTrigger = 14
	TimeToTrigger_TTT_MS5120 TimeToTrigger = 15
)

var TimeToTrigger_name = map[int32]string{
	0:  "TTT_MS0",
	1:  "TTT_MS40",
	2:  "TTT_MS64",
	3:  "TTT_MS80",
	4:  "TTT_MS100",
	5:  "TTT_MS128",
	6:  "TTT_MS160",
	7:  "TTT_MS256",
	8:  "TTT_MS320",
	9:  "TTT_MS480",
	10: "TTT_MS512",
	11: "TTT_MS640",
	12: "TTT_MS1024",
	13: "TTT_MS1280",
	14: "TTT_MS2560",
	15: "TTT_MS5120",
}

var TimeToTrigger_value = map[string]int32{
	"TTT_MS0":    0,
	"TTT_MS40":   1,
	"TTT_MS64":   2,
	"TTT_MS80":   3,
	"TTT_MS100":  4,
	"TTT_MS128":  5,
	"TTT_MS160":  6,
	"TTT_MS256":  7,
	"TTT_MS320":  8,
	"TTT_MS480":  9,
	"TTT_MS512":  10,
	"TTT_MS640":  11,
	"TTT_MS1024": 12,
	"TTT_MS1280": 13,
	"TTT_MS2560": 14,
	"TTT_MS5120": 15,
}

func (x TimeToTrigger) String() string {
	return proto.EnumName(TimeToTrigger_name, int32(x))
}

func (TimeToTrigger) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{10}
}

type TriggerQuantity int32

const (
	TriggerQuantity_TQ_RSRP TriggerQuantity = 0
	TriggerQuantity_TQ_RSRQ TriggerQuantity = 1
)

var TriggerQuantity_name = map[int32]string{
	0: "TQ_RSRP",
	1: "TQ_RSRQ",
}

var TriggerQuantity_value = map[string]int32{
	"TQ_RSRP": 0,
	"TQ_RSRQ": 1,
}

func (x TriggerQuantity) String() string {
	return proto.EnumName(TriggerQuantity_name, int32(x))
}

func (TriggerQuantity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{11}
}

type ReportQuality int32

const (
	ReportQuality_RQ_SAME ReportQuality = 0
	ReportQuality_RQ_BOTH ReportQuality = 1
)

var ReportQuality_name = map[int32]string{
	0: "RQ_SAME",
	1: "RQ_BOTH",
}

var ReportQuality_value = map[string]int32{
	"RQ_SAME": 0,
	"RQ_BOTH": 1,
}

func (x ReportQuality) String() string {
	return proto.EnumName(ReportQuality_name, int32(x))
}

func (ReportQuality) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{12}
}

type MeasIdActionPR int32

const (
	MeasIdActionPR_MEAS_ID_ACTION_PR_NOTHING    MeasIdActionPR = 0
	MeasIdActionPR_MEAS_ID_ACTION_PR_ADDMEASID  MeasIdActionPR = 1
	MeasIdActionPR_MEAS_ID_ACTION_PR_DELMEASID  MeasIdActionPR = 2
	MeasIdActionPR_MEAS_ID_ACTION_PR_HOTOTARGET MeasIdActionPR = 3
)

var MeasIdActionPR_name = map[int32]string{
	0: "MEAS_ID_ACTION_PR_NOTHING",
	1: "MEAS_ID_ACTION_PR_ADDMEASID",
	2: "MEAS_ID_ACTION_PR_DELMEASID",
	3: "MEAS_ID_ACTION_PR_HOTOTARGET",
}

var MeasIdActionPR_value = map[string]int32{
	"MEAS_ID_ACTION_PR_NOTHING":    0,
	"MEAS_ID_ACTION_PR_ADDMEASID":  1,
	"MEAS_ID_ACTION_PR_DELMEASID":  2,
	"MEAS_ID_ACTION_PR_HOTOTARGET": 3,
}

func (x MeasIdActionPR) String() string {
	return proto.EnumName(MeasIdActionPR_name, int32(x))
}

func (MeasIdActionPR) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{13}
}

type L2MeasReportIntervals int32

const (
	L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_NO_REPORT L2MeasReportIntervals = 0
	L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_MS_10     L2MeasReportIntervals = 1
	L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_MS_50     L2MeasReportIntervals = 2
	L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_MS_100    L2MeasReportIntervals = 3
	L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_MS_200    L2MeasReportIntervals = 4
	L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_MS_500    L2MeasReportIntervals = 5
	L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_MS_1024   L2MeasReportIntervals = 6
	L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_S_10      L2MeasReportIntervals = 7
	L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_MIN_1     L2MeasReportIntervals = 8
	L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_MIN_2     L2MeasReportIntervals = 9
	L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_MIN_5     L2MeasReportIntervals = 10
)

var L2MeasReportIntervals_name = map[int32]string{
	0:  "L2_MEAS_REPORT_INTERVAL_NO_REPORT",
	1:  "L2_MEAS_REPORT_INTERVAL_MS_10",
	2:  "L2_MEAS_REPORT_INTERVAL_MS_50",
	3:  "L2_MEAS_REPORT_INTERVAL_MS_100",
	4:  "L2_MEAS_REPORT_INTERVAL_MS_200",
	5:  "L2_MEAS_REPORT_INTERVAL_MS_500",
	6:  "L2_MEAS_REPORT_INTERVAL_MS_1024",
	7:  "L2_MEAS_REPORT_INTERVAL_S_10",
	8:  "L2_MEAS_REPORT_INTERVAL_MIN_1",
	9:  "L2_MEAS_REPORT_INTERVAL_MIN_2",
	10: "L2_MEAS_REPORT_INTERVAL_MIN_5",
}

var L2MeasReportIntervals_value = map[string]int32{
	"L2_MEAS_REPORT_INTERVAL_NO_REPORT": 0,
	"L2_MEAS_REPORT_INTERVAL_MS_10":     1,
	"L2_MEAS_REPORT_INTERVAL_MS_50":     2,
	"L2_MEAS_REPORT_INTERVAL_MS_100":    3,
	"L2_MEAS_REPORT_INTERVAL_MS_200":    4,
	"L2_MEAS_REPORT_INTERVAL_MS_500":    5,
	"L2_MEAS_REPORT_INTERVAL_MS_1024":   6,
	"L2_MEAS_REPORT_INTERVAL_S_10":      7,
	"L2_MEAS_REPORT_INTERVAL_MIN_1":     8,
	"L2_MEAS_REPORT_INTERVAL_MIN_2":     9,
	"L2_MEAS_REPORT_INTERVAL_MIN_5":     10,
}

func (x L2MeasReportIntervals) String() string {
	return proto.EnumName(L2MeasReportIntervals_name, int32(x))
}

func (L2MeasReportIntervals) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{14}
}

type XICICPA int32

const (
	XICICPA_XICIC_PA_DB_MINUS6      XICICPA = 0
	XICICPA_XICIC_PA_DB_MINUX4DOT77 XICICPA = 1
	XICICPA_XICIC_PA_DB_MINUS3      XICICPA = 2
	XICICPA_XICIC_PA_DB_MINUS1DOT77 XICICPA = 3
	XICICPA_XICIC_PA_DB_0           XICICPA = 4
	XICICPA_XICIC_PA_DB_1           XICICPA = 5
	XICICPA_XICIC_PA_DB_2           XICICPA = 6
	XICICPA_XICIC_PA_DB_3           XICICPA = 7
)

var XICICPA_name = map[int32]string{
	0: "XICIC_PA_DB_MINUS6",
	1: "XICIC_PA_DB_MINUX4DOT77",
	2: "XICIC_PA_DB_MINUS3",
	3: "XICIC_PA_DB_MINUS1DOT77",
	4: "XICIC_PA_DB_0",
	5: "XICIC_PA_DB_1",
	6: "XICIC_PA_DB_2",
	7: "XICIC_PA_DB_3",
}

var XICICPA_value = map[string]int32{
	"XICIC_PA_DB_MINUS6":      0,
	"XICIC_PA_DB_MINUX4DOT77": 1,
	"XICIC_PA_DB_MINUS3":      2,
	"XICIC_PA_DB_MINUS1DOT77": 3,
	"XICIC_PA_DB_0":           4,
	"XICIC_PA_DB_1":           5,
	"XICIC_PA_DB_2":           6,
	"XICIC_PA_DB_3":           7,
}

func (x XICICPA) String() string {
	return proto.EnumName(XICICPA_name, int32(x))
}

func (XICICPA) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{15}
}

type CACapClassDl int32

const (
	CACapClassDl_CACAP_CLASSDL_A CACapClassDl = 0
	CACapClassDl_CACAP_CLASSDL_B CACapClassDl = 1
	CACapClassDl_CACAP_CLASSDL_C CACapClassDl = 2
	CACapClassDl_CACAP_CLASSDL_D CACapClassDl = 3
	CACapClassDl_CACAP_CLASSDL_E CACapClassDl = 4
	CACapClassDl_CACAP_CLASSDL_F CACapClassDl = 5
)

var CACapClassDl_name = map[int32]string{
	0: "CACAP_CLASSDL_A",
	1: "CACAP_CLASSDL_B",
	2: "CACAP_CLASSDL_C",
	3: "CACAP_CLASSDL_D",
	4: "CACAP_CLASSDL_E",
	5: "CACAP_CLASSDL_F",
}

var CACapClassDl_value = map[string]int32{
	"CACAP_CLASSDL_A": 0,
	"CACAP_CLASSDL_B": 1,
	"CACAP_CLASSDL_C": 2,
	"CACAP_CLASSDL_D": 3,
	"CACAP_CLASSDL_E": 4,
	"CACAP_CLASSDL_F": 5,
}

func (x CACapClassDl) String() string {
	return proto.EnumName(CACapClassDl_name, int32(x))
}

func (CACapClassDl) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{16}
}

type CACapClassUl int32

const (
	CACapClassUl_CACAP_CLASSUL_A CACapClassUl = 0
	CACapClassUl_CACAP_CLASSUL_B CACapClassUl = 1
	CACapClassUl_CACAP_CLASSUL_C CACapClassUl = 2
	CACapClassUl_CACAP_CLASSUL_D CACapClassUl = 3
	CACapClassUl_CACAP_CLASSUL_E CACapClassUl = 4
	CACapClassUl_CACAP_CLASSUL_F CACapClassUl = 5
)

var CACapClassUl_name = map[int32]string{
	0: "CACAP_CLASSUL_A",
	1: "CACAP_CLASSUL_B",
	2: "CACAP_CLASSUL_C",
	3: "CACAP_CLASSUL_D",
	4: "CACAP_CLASSUL_E",
	5: "CACAP_CLASSUL_F",
}

var CACapClassUl_value = map[string]int32{
	"CACAP_CLASSUL_A": 0,
	"CACAP_CLASSUL_B": 1,
	"CACAP_CLASSUL_C": 2,
	"CACAP_CLASSUL_D": 3,
	"CACAP_CLASSUL_E": 4,
	"CACAP_CLASSUL_F": 5,
}

func (x CACapClassUl) String() string {
	return proto.EnumName(CACapClassUl_name, int32(x))
}

func (CACapClassUl) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{17}
}

type DCCapDrbType int32

const (
	DCCapDrbType_DCCAP_DRBTYPE_SUPPORTED DCCapDrbType = 0
)

var DCCapDrbType_name = map[int32]string{
	0: "DCCAP_DRBTYPE_SUPPORTED",
}

var DCCapDrbType_value = map[string]int32{
	"DCCAP_DRBTYPE_SUPPORTED": 0,
}

func (x DCCapDrbType) String() string {
	return proto.EnumName(DCCapDrbType_name, int32(x))
}

func (DCCapDrbType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{18}
}

type CADirection int32

const (
	CADirection_CADIRECTION_DL   CADirection = 0
	CADirection_CADIRECTION_UL   CADirection = 1
	CADirection_CADIRECTION_BOTH CADirection = 2
)

var CADirection_name = map[int32]string{
	0: "CADIRECTION_DL",
	1: "CADIRECTION_UL",
	2: "CADIRECTION_BOTH",
}

var CADirection_value = map[string]int32{
	"CADIRECTION_DL":   0,
	"CADIRECTION_UL":   1,
	"CADIRECTION_BOTH": 2,
}

func (x CADirection) String() string {
	return proto.EnumName(CADirection_name, int32(x))
}

func (CADirection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{19}
}

// TelemetryMessage carries sensory data about the RAN environment.
type TelemetryMessage struct {
	MessageType MessageType `protobuf:"varint,1,opt,name=messageType,proto3,enum=interface.e2.MessageType" json:"messageType,omitempty"`
	// Types that are valid to be assigned to S:
	//	*TelemetryMessage_RadioMeasReportPerUE
	//	*TelemetryMessage_RadioMeasReportPerCell
	//	*TelemetryMessage_SchedMeasReportPerCell
	//	*TelemetryMessage_PDCPMeasReportPerUe
	S isTelemetryMessage_S `protobuf_oneof:"s"`
}

func (m *TelemetryMessage) Reset()         { *m = TelemetryMessage{} }
func (m *TelemetryMessage) String() string { return proto.CompactTextString(m) }
func (*TelemetryMessage) ProtoMessage()    {}
func (*TelemetryMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{0}
}
func (m *TelemetryMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelemetryMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelemetryMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelemetryMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelemetryMessage.Merge(m, src)
}
func (m *TelemetryMessage) XXX_Size() int {
	return m.Size()
}
func (m *TelemetryMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_TelemetryMessage.DiscardUnknown(m)
}

var xxx_messageInfo_TelemetryMessage proto.InternalMessageInfo

type isTelemetryMessage_S interface {
	isTelemetryMessage_S()
	MarshalTo([]byte) (int, error)
	Size() int
}

type TelemetryMessage_RadioMeasReportPerUE struct {
	RadioMeasReportPerUE *RadioMeasReportPerUE `protobuf:"bytes,2,opt,name=radioMeasReportPerUE,proto3,oneof" json:"radioMeasReportPerUE,omitempty"`
}
type TelemetryMessage_RadioMeasReportPerCell struct {
	RadioMeasReportPerCell *RadioMeasReportPerCell `protobuf:"bytes,3,opt,name=radioMeasReportPerCell,proto3,oneof" json:"radioMeasReportPerCell,omitempty"`
}
type TelemetryMessage_SchedMeasReportPerCell struct {
	SchedMeasReportPerCell *SchedMeasReportPerCell `protobuf:"bytes,4,opt,name=schedMeasReportPerCell,proto3,oneof" json:"schedMeasReportPerCell,omitempty"`
}
type TelemetryMessage_PDCPMeasReportPerUe struct {
	PDCPMeasReportPerUe *PDCPMeasReportPerUe `protobuf:"bytes,5,opt,name=pDCPMeasReportPerUe,proto3,oneof" json:"pDCPMeasReportPerUe,omitempty"`
}

func (*TelemetryMessage_RadioMeasReportPerUE) isTelemetryMessage_S()   {}
func (*TelemetryMessage_RadioMeasReportPerCell) isTelemetryMessage_S() {}
func (*TelemetryMessage_SchedMeasReportPerCell) isTelemetryMessage_S() {}
func (*TelemetryMessage_PDCPMeasReportPerUe) isTelemetryMessage_S()    {}

func (m *TelemetryMessage) GetS() isTelemetryMessage_S {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *TelemetryMessage) GetMessageType() MessageType {
	if m != nil {
		return m.MessageType
	}
	return MessageType_UNKNOWN_MESSAGE
}

func (m *TelemetryMessage) GetRadioMeasReportPerUE() *RadioMeasReportPerUE {
	if x, ok := m.GetS().(*TelemetryMessage_RadioMeasReportPerUE); ok {
		return x.RadioMeasReportPerUE
	}
	return nil
}

func (m *TelemetryMessage) GetRadioMeasReportPerCell() *RadioMeasReportPerCell {
	if x, ok := m.GetS().(*TelemetryMessage_RadioMeasReportPerCell); ok {
		return x.RadioMeasReportPerCell
	}
	return nil
}

func (m *TelemetryMessage) GetSchedMeasReportPerCell() *SchedMeasReportPerCell {
	if x, ok := m.GetS().(*TelemetryMessage_SchedMeasReportPerCell); ok {
		return x.SchedMeasReportPerCell
	}
	return nil
}

func (m *TelemetryMessage) GetPDCPMeasReportPerUe() *PDCPMeasReportPerUe {
	if x, ok := m.GetS().(*TelemetryMessage_PDCPMeasReportPerUe); ok {
		return x.PDCPMeasReportPerUe
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TelemetryMessage) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TelemetryMessage_RadioMeasReportPerUE)(nil),
		(*TelemetryMessage_RadioMeasReportPerCell)(nil),
		(*TelemetryMessage_SchedMeasReportPerCell)(nil),
		(*TelemetryMessage_PDCPMeasReportPerUe)(nil),
	}
}

// ControlUpdate carries a class of asynchronous control messages initiated by the RAN environment.
type ControlUpdate struct {
	MessageType MessageType `protobuf:"varint,1,opt,name=messageType,proto3,enum=interface.e2.MessageType" json:"messageType,omitempty"`
	// Types that are valid to be assigned to S:
	//	*ControlUpdate_CellConfigReport
	//	*ControlUpdate_RRMConfigStatus
	//	*ControlUpdate_UEAdmissionRequest
	//	*ControlUpdate_UEAdmissionStatus
	//	*ControlUpdate_UEContextUpdate
	//	*ControlUpdate_BearerAdmissionRequest
	//	*ControlUpdate_BearerAdmissionStatus
	//	*ControlUpdate_HOComplete
	//	*ControlUpdate_HOFailure
	//	*ControlUpdate_HOCause
	//	*ControlUpdate_UEReleaseInd
	S isControlUpdate_S `protobuf_oneof:"s"`
}

func (m *ControlUpdate) Reset()         { *m = ControlUpdate{} }
func (m *ControlUpdate) String() string { return proto.CompactTextString(m) }
func (*ControlUpdate) ProtoMessage()    {}
func (*ControlUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{1}
}
func (m *ControlUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlUpdate.Merge(m, src)
}
func (m *ControlUpdate) XXX_Size() int {
	return m.Size()
}
func (m *ControlUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ControlUpdate proto.InternalMessageInfo

type isControlUpdate_S interface {
	isControlUpdate_S()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ControlUpdate_CellConfigReport struct {
	CellConfigReport *CellConfigReport `protobuf:"bytes,2,opt,name=cellConfigReport,proto3,oneof" json:"cellConfigReport,omitempty"`
}
type ControlUpdate_RRMConfigStatus struct {
	RRMConfigStatus *RRMConfigStatus `protobuf:"bytes,3,opt,name=rRMConfigStatus,proto3,oneof" json:"rRMConfigStatus,omitempty"`
}
type ControlUpdate_UEAdmissionRequest struct {
	UEAdmissionRequest *UEAdmissionRequest `protobuf:"bytes,4,opt,name=uEAdmissionRequest,proto3,oneof" json:"uEAdmissionRequest,omitempty"`
}
type ControlUpdate_UEAdmissionStatus struct {
	UEAdmissionStatus *UEAdmissionStatus `protobuf:"bytes,5,opt,name=uEAdmissionStatus,proto3,oneof" json:"uEAdmissionStatus,omitempty"`
}
type ControlUpdate_UEContextUpdate struct {
	UEContextUpdate *UEContextUpdate `protobuf:"bytes,6,opt,name=uEContextUpdate,proto3,oneof" json:"uEContextUpdate,omitempty"`
}
type ControlUpdate_BearerAdmissionRequest struct {
	BearerAdmissionRequest *BearerAdmissionRequest `protobuf:"bytes,7,opt,name=bearerAdmissionRequest,proto3,oneof" json:"bearerAdmissionRequest,omitempty"`
}
type ControlUpdate_BearerAdmissionStatus struct {
	BearerAdmissionStatus *BearerAdmissionStatus `protobuf:"bytes,8,opt,name=bearerAdmissionStatus,proto3,oneof" json:"bearerAdmissionStatus,omitempty"`
}
type ControlUpdate_HOComplete struct {
	HOComplete *HOComplete `protobuf:"bytes,9,opt,name=hOComplete,proto3,oneof" json:"hOComplete,omitempty"`
}
type ControlUpdate_HOFailure struct {
	HOFailure *HOFailure `protobuf:"bytes,10,opt,name=hOFailure,proto3,oneof" json:"hOFailure,omitempty"`
}
type ControlUpdate_HOCause struct {
	HOCause *HOCause `protobuf:"bytes,11,opt,name=hOCause,proto3,oneof" json:"hOCause,omitempty"`
}
type ControlUpdate_UEReleaseInd struct {
	UEReleaseInd *UEReleaseInd `protobuf:"bytes,12,opt,name=uEReleaseInd,proto3,oneof" json:"uEReleaseInd,omitempty"`
}

func (*ControlUpdate_CellConfigReport) isControlUpdate_S()       {}
func (*ControlUpdate_RRMConfigStatus) isControlUpdate_S()        {}
func (*ControlUpdate_UEAdmissionRequest) isControlUpdate_S()     {}
func (*ControlUpdate_UEAdmissionStatus) isControlUpdate_S()      {}
func (*ControlUpdate_UEContextUpdate) isControlUpdate_S()        {}
func (*ControlUpdate_BearerAdmissionRequest) isControlUpdate_S() {}
func (*ControlUpdate_BearerAdmissionStatus) isControlUpdate_S()  {}
func (*ControlUpdate_HOComplete) isControlUpdate_S()             {}
func (*ControlUpdate_HOFailure) isControlUpdate_S()              {}
func (*ControlUpdate_HOCause) isControlUpdate_S()                {}
func (*ControlUpdate_UEReleaseInd) isControlUpdate_S()           {}

func (m *ControlUpdate) GetS() isControlUpdate_S {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *ControlUpdate) GetMessageType() MessageType {
	if m != nil {
		return m.MessageType
	}
	return MessageType_UNKNOWN_MESSAGE
}

func (m *ControlUpdate) GetCellConfigReport() *CellConfigReport {
	if x, ok := m.GetS().(*ControlUpdate_CellConfigReport); ok {
		return x.CellConfigReport
	}
	return nil
}

func (m *ControlUpdate) GetRRMConfigStatus() *RRMConfigStatus {
	if x, ok := m.GetS().(*ControlUpdate_RRMConfigStatus); ok {
		return x.RRMConfigStatus
	}
	return nil
}

func (m *ControlUpdate) GetUEAdmissionRequest() *UEAdmissionRequest {
	if x, ok := m.GetS().(*ControlUpdate_UEAdmissionRequest); ok {
		return x.UEAdmissionRequest
	}
	return nil
}

func (m *ControlUpdate) GetUEAdmissionStatus() *UEAdmissionStatus {
	if x, ok := m.GetS().(*ControlUpdate_UEAdmissionStatus); ok {
		return x.UEAdmissionStatus
	}
	return nil
}

func (m *ControlUpdate) GetUEContextUpdate() *UEContextUpdate {
	if x, ok := m.GetS().(*ControlUpdate_UEContextUpdate); ok {
		return x.UEContextUpdate
	}
	return nil
}

func (m *ControlUpdate) GetBearerAdmissionRequest() *BearerAdmissionRequest {
	if x, ok := m.GetS().(*ControlUpdate_BearerAdmissionRequest); ok {
		return x.BearerAdmissionRequest
	}
	return nil
}

func (m *ControlUpdate) GetBearerAdmissionStatus() *BearerAdmissionStatus {
	if x, ok := m.GetS().(*ControlUpdate_BearerAdmissionStatus); ok {
		return x.BearerAdmissionStatus
	}
	return nil
}

func (m *ControlUpdate) GetHOComplete() *HOComplete {
	if x, ok := m.GetS().(*ControlUpdate_HOComplete); ok {
		return x.HOComplete
	}
	return nil
}

func (m *ControlUpdate) GetHOFailure() *HOFailure {
	if x, ok := m.GetS().(*ControlUpdate_HOFailure); ok {
		return x.HOFailure
	}
	return nil
}

func (m *ControlUpdate) GetHOCause() *HOCause {
	if x, ok := m.GetS().(*ControlUpdate_HOCause); ok {
		return x.HOCause
	}
	return nil
}

func (m *ControlUpdate) GetUEReleaseInd() *UEReleaseInd {
	if x, ok := m.GetS().(*ControlUpdate_UEReleaseInd); ok {
		return x.UEReleaseInd
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ControlUpdate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ControlUpdate_CellConfigReport)(nil),
		(*ControlUpdate_RRMConfigStatus)(nil),
		(*ControlUpdate_UEAdmissionRequest)(nil),
		(*ControlUpdate_UEAdmissionStatus)(nil),
		(*ControlUpdate_UEContextUpdate)(nil),
		(*ControlUpdate_BearerAdmissionRequest)(nil),
		(*ControlUpdate_BearerAdmissionStatus)(nil),
		(*ControlUpdate_HOComplete)(nil),
		(*ControlUpdate_HOFailure)(nil),
		(*ControlUpdate_HOCause)(nil),
		(*ControlUpdate_UEReleaseInd)(nil),
	}
}

// ControlResponse contains asynchronous responses to control updates, e.g. admission response.
type ControlResponse struct {
	MessageType MessageType `protobuf:"varint,1,opt,name=messageType,proto3,enum=interface.e2.MessageType" json:"messageType,omitempty"`
	// Types that are valid to be assigned to S:
	//	*ControlResponse_CellConfigRequest
	//	*ControlResponse_RRMConfig
	//	*ControlResponse_UEAdmissionResponse
	//	*ControlResponse_BearerAdmissionResponse
	//	*ControlResponse_HORequest
	S isControlResponse_S `protobuf_oneof:"s"`
}

func (m *ControlResponse) Reset()         { *m = ControlResponse{} }
func (m *ControlResponse) String() string { return proto.CompactTextString(m) }
func (*ControlResponse) ProtoMessage()    {}
func (*ControlResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{2}
}
func (m *ControlResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ControlResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ControlResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ControlResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ControlResponse.Merge(m, src)
}
func (m *ControlResponse) XXX_Size() int {
	return m.Size()
}
func (m *ControlResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ControlResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ControlResponse proto.InternalMessageInfo

type isControlResponse_S interface {
	isControlResponse_S()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ControlResponse_CellConfigRequest struct {
	CellConfigRequest *CellConfigRequest `protobuf:"bytes,2,opt,name=cellConfigRequest,proto3,oneof" json:"cellConfigRequest,omitempty"`
}
type ControlResponse_RRMConfig struct {
	RRMConfig *RRMConfig `protobuf:"bytes,3,opt,name=rRMConfig,proto3,oneof" json:"rRMConfig,omitempty"`
}
type ControlResponse_UEAdmissionResponse struct {
	UEAdmissionResponse *UEAdmissionResponse `protobuf:"bytes,5,opt,name=uEAdmissionResponse,proto3,oneof" json:"uEAdmissionResponse,omitempty"`
}
type ControlResponse_BearerAdmissionResponse struct {
	BearerAdmissionResponse *BearerAdmissionResponse `protobuf:"bytes,6,opt,name=bearerAdmissionResponse,proto3,oneof" json:"bearerAdmissionResponse,omitempty"`
}
type ControlResponse_HORequest struct {
	HORequest *HORequest `protobuf:"bytes,7,opt,name=hORequest,proto3,oneof" json:"hORequest,omitempty"`
}

func (*ControlResponse_CellConfigRequest) isControlResponse_S()       {}
func (*ControlResponse_RRMConfig) isControlResponse_S()               {}
func (*ControlResponse_UEAdmissionResponse) isControlResponse_S()     {}
func (*ControlResponse_BearerAdmissionResponse) isControlResponse_S() {}
func (*ControlResponse_HORequest) isControlResponse_S()               {}

func (m *ControlResponse) GetS() isControlResponse_S {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *ControlResponse) GetMessageType() MessageType {
	if m != nil {
		return m.MessageType
	}
	return MessageType_UNKNOWN_MESSAGE
}

func (m *ControlResponse) GetCellConfigRequest() *CellConfigRequest {
	if x, ok := m.GetS().(*ControlResponse_CellConfigRequest); ok {
		return x.CellConfigRequest
	}
	return nil
}

func (m *ControlResponse) GetRRMConfig() *RRMConfig {
	if x, ok := m.GetS().(*ControlResponse_RRMConfig); ok {
		return x.RRMConfig
	}
	return nil
}

func (m *ControlResponse) GetUEAdmissionResponse() *UEAdmissionResponse {
	if x, ok := m.GetS().(*ControlResponse_UEAdmissionResponse); ok {
		return x.UEAdmissionResponse
	}
	return nil
}

func (m *ControlResponse) GetBearerAdmissionResponse() *BearerAdmissionResponse {
	if x, ok := m.GetS().(*ControlResponse_BearerAdmissionResponse); ok {
		return x.BearerAdmissionResponse
	}
	return nil
}

func (m *ControlResponse) GetHORequest() *HORequest {
	if x, ok := m.GetS().(*ControlResponse_HORequest); ok {
		return x.HORequest
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ControlResponse) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ControlResponse_CellConfigRequest)(nil),
		(*ControlResponse_RRMConfig)(nil),
		(*ControlResponse_UEAdmissionResponse)(nil),
		(*ControlResponse_BearerAdmissionResponse)(nil),
		(*ControlResponse_HORequest)(nil),
	}
}

// Message header
type MessageHeader struct {
	MessageType MessageType `protobuf:"varint,1,opt,name=messageType,proto3,enum=interface.e2.MessageType" json:"messageType,omitempty"`
}

func (m *MessageHeader) Reset()         { *m = MessageHeader{} }
func (m *MessageHeader) String() string { return proto.CompactTextString(m) }
func (*MessageHeader) ProtoMessage()    {}
func (*MessageHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{3}
}
func (m *MessageHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageHeader.Merge(m, src)
}
func (m *MessageHeader) XXX_Size() int {
	return m.Size()
}
func (m *MessageHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageHeader.DiscardUnknown(m)
}

var xxx_messageInfo_MessageHeader proto.InternalMessageInfo

func (m *MessageHeader) GetMessageType() MessageType {
	if m != nil {
		return m.MessageType
	}
	return MessageType_UNKNOWN_MESSAGE
}

// Message payload; one of s defined below
type MessagePayload struct {
	// Types that are valid to be assigned to S:
	//	*MessagePayload_CellConfigRequest
	//	*MessagePayload_CellConfigReport
	//	*MessagePayload_UEAdmissionRequest
	//	*MessagePayload_UEAdmissionResponse
	//	*MessagePayload_UEAdmissionStatus
	//	*MessagePayload_UEContextUpdate
	//	*MessagePayload_UEReconfigInd
	//	*MessagePayload_UEReleaseInd
	//	*MessagePayload_BearerAdmissionRequest
	//	*MessagePayload_BearerAdmissionResponse
	//	*MessagePayload_BearerAdmissionStatus
	//	*MessagePayload_BearerReleaseInd
	//	*MessagePayload_HORequest
	//	*MessagePayload_HOFailure
	//	*MessagePayload_HOComplete
	//	*MessagePayload_HOCause
	//	*MessagePayload_RRCMeasConfig
	//	*MessagePayload_RxSigMeasReport
	//	*MessagePayload_L2MeasConfig
	//	*MessagePayload_RadioMeasReportPerU
	//	*MessagePayload_RadioMeasReportPerCell
	//	*MessagePayload_SchedMeasReportPerUE
	//	*MessagePayload_SchedMeasReportPerCell
	//	*MessagePayload_PDCPMeasReportPerUe
	//	*MessagePayload_RRMConfig
	//	*MessagePayload_RRMConfigStatus
	//	*MessagePayload_UECapabilityEnquiry
	//	*MessagePayload_UECapabilityInfo
	//	*MessagePayload_ScellAdd
	//	*MessagePayload_ScellAddStatus
	//	*MessagePayload_ScellDelete
	//	*MessagePayload_SeNBAdd
	//	*MessagePayload_SeNBAddStatus
	//	*MessagePayload_SeNBDelete
	//	*MessagePayload_TrafficSplitConfig
	S isMessagePayload_S `protobuf_oneof:"s"`
}

func (m *MessagePayload) Reset()         { *m = MessagePayload{} }
func (m *MessagePayload) String() string { return proto.CompactTextString(m) }
func (*MessagePayload) ProtoMessage()    {}
func (*MessagePayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{4}
}
func (m *MessagePayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessagePayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessagePayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessagePayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessagePayload.Merge(m, src)
}
func (m *MessagePayload) XXX_Size() int {
	return m.Size()
}
func (m *MessagePayload) XXX_DiscardUnknown() {
	xxx_messageInfo_MessagePayload.DiscardUnknown(m)
}

var xxx_messageInfo_MessagePayload proto.InternalMessageInfo

type isMessagePayload_S interface {
	isMessagePayload_S()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MessagePayload_CellConfigRequest struct {
	CellConfigRequest *CellConfigRequest `protobuf:"bytes,1,opt,name=cellConfigRequest,proto3,oneof" json:"cellConfigRequest,omitempty"`
}
type MessagePayload_CellConfigReport struct {
	CellConfigReport *CellConfigReport `protobuf:"bytes,2,opt,name=cellConfigReport,proto3,oneof" json:"cellConfigReport,omitempty"`
}
type MessagePayload_UEAdmissionRequest struct {
	UEAdmissionRequest *UEAdmissionRequest `protobuf:"bytes,3,opt,name=uEAdmissionRequest,proto3,oneof" json:"uEAdmissionRequest,omitempty"`
}
type MessagePayload_UEAdmissionResponse struct {
	UEAdmissionResponse *UEAdmissionResponse `protobuf:"bytes,4,opt,name=uEAdmissionResponse,proto3,oneof" json:"uEAdmissionResponse,omitempty"`
}
type MessagePayload_UEAdmissionStatus struct {
	UEAdmissionStatus *UEAdmissionStatus `protobuf:"bytes,5,opt,name=uEAdmissionStatus,proto3,oneof" json:"uEAdmissionStatus,omitempty"`
}
type MessagePayload_UEContextUpdate struct {
	UEContextUpdate *UEContextUpdate `protobuf:"bytes,6,opt,name=uEContextUpdate,proto3,oneof" json:"uEContextUpdate,omitempty"`
}
type MessagePayload_UEReconfigInd struct {
	UEReconfigInd *UEReconfigInd `protobuf:"bytes,7,opt,name=uEReconfigInd,proto3,oneof" json:"uEReconfigInd,omitempty"`
}
type MessagePayload_UEReleaseInd struct {
	UEReleaseInd *UEReleaseInd `protobuf:"bytes,8,opt,name=uEReleaseInd,proto3,oneof" json:"uEReleaseInd,omitempty"`
}
type MessagePayload_BearerAdmissionRequest struct {
	BearerAdmissionRequest *BearerAdmissionRequest `protobuf:"bytes,9,opt,name=bearerAdmissionRequest,proto3,oneof" json:"bearerAdmissionRequest,omitempty"`
}
type MessagePayload_BearerAdmissionResponse struct {
	BearerAdmissionResponse *BearerAdmissionResponse `protobuf:"bytes,10,opt,name=bearerAdmissionResponse,proto3,oneof" json:"bearerAdmissionResponse,omitempty"`
}
type MessagePayload_BearerAdmissionStatus struct {
	BearerAdmissionStatus *BearerAdmissionStatus `protobuf:"bytes,11,opt,name=bearerAdmissionStatus,proto3,oneof" json:"bearerAdmissionStatus,omitempty"`
}
type MessagePayload_BearerReleaseInd struct {
	BearerReleaseInd *BearerReleaseInd `protobuf:"bytes,12,opt,name=bearerReleaseInd,proto3,oneof" json:"bearerReleaseInd,omitempty"`
}
type MessagePayload_HORequest struct {
	HORequest *HORequest `protobuf:"bytes,13,opt,name=hORequest,proto3,oneof" json:"hORequest,omitempty"`
}
type MessagePayload_HOFailure struct {
	HOFailure *HOFailure `protobuf:"bytes,14,opt,name=hOFailure,proto3,oneof" json:"hOFailure,omitempty"`
}
type MessagePayload_HOComplete struct {
	HOComplete *HOComplete `protobuf:"bytes,15,opt,name=hOComplete,proto3,oneof" json:"hOComplete,omitempty"`
}
type MessagePayload_HOCause struct {
	HOCause *HOCause `protobuf:"bytes,16,opt,name=hOCause,proto3,oneof" json:"hOCause,omitempty"`
}
type MessagePayload_RRCMeasConfig struct {
	RRCMeasConfig *RRCMeasConfig `protobuf:"bytes,17,opt,name=rRCMeasConfig,proto3,oneof" json:"rRCMeasConfig,omitempty"`
}
type MessagePayload_RxSigMeasReport struct {
	RxSigMeasReport *RxSigMeasReport `protobuf:"bytes,18,opt,name=rxSigMeasReport,proto3,oneof" json:"rxSigMeasReport,omitempty"`
}
type MessagePayload_L2MeasConfig struct {
	L2MeasConfig *L2MeasConfig `protobuf:"bytes,19,opt,name=l2MeasConfig,proto3,oneof" json:"l2MeasConfig,omitempty"`
}
type MessagePayload_RadioMeasReportPerU struct {
	RadioMeasReportPerU *RadioMeasReportPerUE `protobuf:"bytes,20,opt,name=radioMeasReportPerU,proto3,oneof" json:"radioMeasReportPerU,omitempty"`
}
type MessagePayload_RadioMeasReportPerCell struct {
	RadioMeasReportPerCell *RadioMeasReportPerCell `protobuf:"bytes,21,opt,name=radioMeasReportPerCell,proto3,oneof" json:"radioMeasReportPerCell,omitempty"`
}
type MessagePayload_SchedMeasReportPerUE struct {
	SchedMeasReportPerUE *SchedMeasReportPerUE `protobuf:"bytes,22,opt,name=schedMeasReportPerUE,proto3,oneof" json:"schedMeasReportPerUE,omitempty"`
}
type MessagePayload_SchedMeasReportPerCell struct {
	SchedMeasReportPerCell *SchedMeasReportPerCell `protobuf:"bytes,23,opt,name=schedMeasReportPerCell,proto3,oneof" json:"schedMeasReportPerCell,omitempty"`
}
type MessagePayload_PDCPMeasReportPerUe struct {
	PDCPMeasReportPerUe *PDCPMeasReportPerUe `protobuf:"bytes,24,opt,name=pDCPMeasReportPerUe,proto3,oneof" json:"pDCPMeasReportPerUe,omitempty"`
}
type MessagePayload_RRMConfig struct {
	RRMConfig *RRMConfig `protobuf:"bytes,25,opt,name=rRMConfig,proto3,oneof" json:"rRMConfig,omitempty"`
}
type MessagePayload_RRMConfigStatus struct {
	RRMConfigStatus *RRMConfigStatus `protobuf:"bytes,26,opt,name=rRMConfigStatus,proto3,oneof" json:"rRMConfigStatus,omitempty"`
}
type MessagePayload_UECapabilityEnquiry struct {
	UECapabilityEnquiry *UECapabilityEnquiry `protobuf:"bytes,27,opt,name=uECapabilityEnquiry,proto3,oneof" json:"uECapabilityEnquiry,omitempty"`
}
type MessagePayload_UECapabilityInfo struct {
	UECapabilityInfo *UECapabilityInfo `protobuf:"bytes,28,opt,name=uECapabilityInfo,proto3,oneof" json:"uECapabilityInfo,omitempty"`
}
type MessagePayload_ScellAdd struct {
	ScellAdd *ScellAdd `protobuf:"bytes,29,opt,name=scellAdd,proto3,oneof" json:"scellAdd,omitempty"`
}
type MessagePayload_ScellAddStatus struct {
	ScellAddStatus *ScellAddStatus `protobuf:"bytes,30,opt,name=scellAddStatus,proto3,oneof" json:"scellAddStatus,omitempty"`
}
type MessagePayload_ScellDelete struct {
	ScellDelete *ScellDelete `protobuf:"bytes,31,opt,name=scellDelete,proto3,oneof" json:"scellDelete,omitempty"`
}
type MessagePayload_SeNBAdd struct {
	SeNBAdd *SeNBAdd `protobuf:"bytes,32,opt,name=seNBAdd,proto3,oneof" json:"seNBAdd,omitempty"`
}
type MessagePayload_SeNBAddStatus struct {
	SeNBAddStatus *SeNBAddStatus `protobuf:"bytes,33,opt,name=seNBAddStatus,proto3,oneof" json:"seNBAddStatus,omitempty"`
}
type MessagePayload_SeNBDelete struct {
	SeNBDelete *SeNBDelete `protobuf:"bytes,34,opt,name=seNBDelete,proto3,oneof" json:"seNBDelete,omitempty"`
}
type MessagePayload_TrafficSplitConfig struct {
	TrafficSplitConfig *TrafficSplitConfig `protobuf:"bytes,35,opt,name=trafficSplitConfig,proto3,oneof" json:"trafficSplitConfig,omitempty"`
}

func (*MessagePayload_CellConfigRequest) isMessagePayload_S()       {}
func (*MessagePayload_CellConfigReport) isMessagePayload_S()        {}
func (*MessagePayload_UEAdmissionRequest) isMessagePayload_S()      {}
func (*MessagePayload_UEAdmissionResponse) isMessagePayload_S()     {}
func (*MessagePayload_UEAdmissionStatus) isMessagePayload_S()       {}
func (*MessagePayload_UEContextUpdate) isMessagePayload_S()         {}
func (*MessagePayload_UEReconfigInd) isMessagePayload_S()           {}
func (*MessagePayload_UEReleaseInd) isMessagePayload_S()            {}
func (*MessagePayload_BearerAdmissionRequest) isMessagePayload_S()  {}
func (*MessagePayload_BearerAdmissionResponse) isMessagePayload_S() {}
func (*MessagePayload_BearerAdmissionStatus) isMessagePayload_S()   {}
func (*MessagePayload_BearerReleaseInd) isMessagePayload_S()        {}
func (*MessagePayload_HORequest) isMessagePayload_S()               {}
func (*MessagePayload_HOFailure) isMessagePayload_S()               {}
func (*MessagePayload_HOComplete) isMessagePayload_S()              {}
func (*MessagePayload_HOCause) isMessagePayload_S()                 {}
func (*MessagePayload_RRCMeasConfig) isMessagePayload_S()           {}
func (*MessagePayload_RxSigMeasReport) isMessagePayload_S()         {}
func (*MessagePayload_L2MeasConfig) isMessagePayload_S()            {}
func (*MessagePayload_RadioMeasReportPerU) isMessagePayload_S()     {}
func (*MessagePayload_RadioMeasReportPerCell) isMessagePayload_S()  {}
func (*MessagePayload_SchedMeasReportPerUE) isMessagePayload_S()    {}
func (*MessagePayload_SchedMeasReportPerCell) isMessagePayload_S()  {}
func (*MessagePayload_PDCPMeasReportPerUe) isMessagePayload_S()     {}
func (*MessagePayload_RRMConfig) isMessagePayload_S()               {}
func (*MessagePayload_RRMConfigStatus) isMessagePayload_S()         {}
func (*MessagePayload_UECapabilityEnquiry) isMessagePayload_S()     {}
func (*MessagePayload_UECapabilityInfo) isMessagePayload_S()        {}
func (*MessagePayload_ScellAdd) isMessagePayload_S()                {}
func (*MessagePayload_ScellAddStatus) isMessagePayload_S()          {}
func (*MessagePayload_ScellDelete) isMessagePayload_S()             {}
func (*MessagePayload_SeNBAdd) isMessagePayload_S()                 {}
func (*MessagePayload_SeNBAddStatus) isMessagePayload_S()           {}
func (*MessagePayload_SeNBDelete) isMessagePayload_S()              {}
func (*MessagePayload_TrafficSplitConfig) isMessagePayload_S()      {}

func (m *MessagePayload) GetS() isMessagePayload_S {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *MessagePayload) GetCellConfigRequest() *CellConfigRequest {
	if x, ok := m.GetS().(*MessagePayload_CellConfigRequest); ok {
		return x.CellConfigRequest
	}
	return nil
}

func (m *MessagePayload) GetCellConfigReport() *CellConfigReport {
	if x, ok := m.GetS().(*MessagePayload_CellConfigReport); ok {
		return x.CellConfigReport
	}
	return nil
}

func (m *MessagePayload) GetUEAdmissionRequest() *UEAdmissionRequest {
	if x, ok := m.GetS().(*MessagePayload_UEAdmissionRequest); ok {
		return x.UEAdmissionRequest
	}
	return nil
}

func (m *MessagePayload) GetUEAdmissionResponse() *UEAdmissionResponse {
	if x, ok := m.GetS().(*MessagePayload_UEAdmissionResponse); ok {
		return x.UEAdmissionResponse
	}
	return nil
}

func (m *MessagePayload) GetUEAdmissionStatus() *UEAdmissionStatus {
	if x, ok := m.GetS().(*MessagePayload_UEAdmissionStatus); ok {
		return x.UEAdmissionStatus
	}
	return nil
}

func (m *MessagePayload) GetUEContextUpdate() *UEContextUpdate {
	if x, ok := m.GetS().(*MessagePayload_UEContextUpdate); ok {
		return x.UEContextUpdate
	}
	return nil
}

func (m *MessagePayload) GetUEReconfigInd() *UEReconfigInd {
	if x, ok := m.GetS().(*MessagePayload_UEReconfigInd); ok {
		return x.UEReconfigInd
	}
	return nil
}

func (m *MessagePayload) GetUEReleaseInd() *UEReleaseInd {
	if x, ok := m.GetS().(*MessagePayload_UEReleaseInd); ok {
		return x.UEReleaseInd
	}
	return nil
}

func (m *MessagePayload) GetBearerAdmissionRequest() *BearerAdmissionRequest {
	if x, ok := m.GetS().(*MessagePayload_BearerAdmissionRequest); ok {
		return x.BearerAdmissionRequest
	}
	return nil
}

func (m *MessagePayload) GetBearerAdmissionResponse() *BearerAdmissionResponse {
	if x, ok := m.GetS().(*MessagePayload_BearerAdmissionResponse); ok {
		return x.BearerAdmissionResponse
	}
	return nil
}

func (m *MessagePayload) GetBearerAdmissionStatus() *BearerAdmissionStatus {
	if x, ok := m.GetS().(*MessagePayload_BearerAdmissionStatus); ok {
		return x.BearerAdmissionStatus
	}
	return nil
}

func (m *MessagePayload) GetBearerReleaseInd() *BearerReleaseInd {
	if x, ok := m.GetS().(*MessagePayload_BearerReleaseInd); ok {
		return x.BearerReleaseInd
	}
	return nil
}

func (m *MessagePayload) GetHORequest() *HORequest {
	if x, ok := m.GetS().(*MessagePayload_HORequest); ok {
		return x.HORequest
	}
	return nil
}

func (m *MessagePayload) GetHOFailure() *HOFailure {
	if x, ok := m.GetS().(*MessagePayload_HOFailure); ok {
		return x.HOFailure
	}
	return nil
}

func (m *MessagePayload) GetHOComplete() *HOComplete {
	if x, ok := m.GetS().(*MessagePayload_HOComplete); ok {
		return x.HOComplete
	}
	return nil
}

func (m *MessagePayload) GetHOCause() *HOCause {
	if x, ok := m.GetS().(*MessagePayload_HOCause); ok {
		return x.HOCause
	}
	return nil
}

func (m *MessagePayload) GetRRCMeasConfig() *RRCMeasConfig {
	if x, ok := m.GetS().(*MessagePayload_RRCMeasConfig); ok {
		return x.RRCMeasConfig
	}
	return nil
}

func (m *MessagePayload) GetRxSigMeasReport() *RxSigMeasReport {
	if x, ok := m.GetS().(*MessagePayload_RxSigMeasReport); ok {
		return x.RxSigMeasReport
	}
	return nil
}

func (m *MessagePayload) GetL2MeasConfig() *L2MeasConfig {
	if x, ok := m.GetS().(*MessagePayload_L2MeasConfig); ok {
		return x.L2MeasConfig
	}
	return nil
}

func (m *MessagePayload) GetRadioMeasReportPerU() *RadioMeasReportPerUE {
	if x, ok := m.GetS().(*MessagePayload_RadioMeasReportPerU); ok {
		return x.RadioMeasReportPerU
	}
	return nil
}

func (m *MessagePayload) GetRadioMeasReportPerCell() *RadioMeasReportPerCell {
	if x, ok := m.GetS().(*MessagePayload_RadioMeasReportPerCell); ok {
		return x.RadioMeasReportPerCell
	}
	return nil
}

func (m *MessagePayload) GetSchedMeasReportPerUE() *SchedMeasReportPerUE {
	if x, ok := m.GetS().(*MessagePayload_SchedMeasReportPerUE); ok {
		return x.SchedMeasReportPerUE
	}
	return nil
}

func (m *MessagePayload) GetSchedMeasReportPerCell() *SchedMeasReportPerCell {
	if x, ok := m.GetS().(*MessagePayload_SchedMeasReportPerCell); ok {
		return x.SchedMeasReportPerCell
	}
	return nil
}

func (m *MessagePayload) GetPDCPMeasReportPerUe() *PDCPMeasReportPerUe {
	if x, ok := m.GetS().(*MessagePayload_PDCPMeasReportPerUe); ok {
		return x.PDCPMeasReportPerUe
	}
	return nil
}

func (m *MessagePayload) GetRRMConfig() *RRMConfig {
	if x, ok := m.GetS().(*MessagePayload_RRMConfig); ok {
		return x.RRMConfig
	}
	return nil
}

func (m *MessagePayload) GetRRMConfigStatus() *RRMConfigStatus {
	if x, ok := m.GetS().(*MessagePayload_RRMConfigStatus); ok {
		return x.RRMConfigStatus
	}
	return nil
}

func (m *MessagePayload) GetUECapabilityEnquiry() *UECapabilityEnquiry {
	if x, ok := m.GetS().(*MessagePayload_UECapabilityEnquiry); ok {
		return x.UECapabilityEnquiry
	}
	return nil
}

func (m *MessagePayload) GetUECapabilityInfo() *UECapabilityInfo {
	if x, ok := m.GetS().(*MessagePayload_UECapabilityInfo); ok {
		return x.UECapabilityInfo
	}
	return nil
}

func (m *MessagePayload) GetScellAdd() *ScellAdd {
	if x, ok := m.GetS().(*MessagePayload_ScellAdd); ok {
		return x.ScellAdd
	}
	return nil
}

func (m *MessagePayload) GetScellAddStatus() *ScellAddStatus {
	if x, ok := m.GetS().(*MessagePayload_ScellAddStatus); ok {
		return x.ScellAddStatus
	}
	return nil
}

func (m *MessagePayload) GetScellDelete() *ScellDelete {
	if x, ok := m.GetS().(*MessagePayload_ScellDelete); ok {
		return x.ScellDelete
	}
	return nil
}

func (m *MessagePayload) GetSeNBAdd() *SeNBAdd {
	if x, ok := m.GetS().(*MessagePayload_SeNBAdd); ok {
		return x.SeNBAdd
	}
	return nil
}

func (m *MessagePayload) GetSeNBAddStatus() *SeNBAddStatus {
	if x, ok := m.GetS().(*MessagePayload_SeNBAddStatus); ok {
		return x.SeNBAddStatus
	}
	return nil
}

func (m *MessagePayload) GetSeNBDelete() *SeNBDelete {
	if x, ok := m.GetS().(*MessagePayload_SeNBDelete); ok {
		return x.SeNBDelete
	}
	return nil
}

func (m *MessagePayload) GetTrafficSplitConfig() *TrafficSplitConfig {
	if x, ok := m.GetS().(*MessagePayload_TrafficSplitConfig); ok {
		return x.TrafficSplitConfig
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MessagePayload) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MessagePayload_CellConfigRequest)(nil),
		(*MessagePayload_CellConfigReport)(nil),
		(*MessagePayload_UEAdmissionRequest)(nil),
		(*MessagePayload_UEAdmissionResponse)(nil),
		(*MessagePayload_UEAdmissionStatus)(nil),
		(*MessagePayload_UEContextUpdate)(nil),
		(*MessagePayload_UEReconfigInd)(nil),
		(*MessagePayload_UEReleaseInd)(nil),
		(*MessagePayload_BearerAdmissionRequest)(nil),
		(*MessagePayload_BearerAdmissionResponse)(nil),
		(*MessagePayload_BearerAdmissionStatus)(nil),
		(*MessagePayload_BearerReleaseInd)(nil),
		(*MessagePayload_HORequest)(nil),
		(*MessagePayload_HOFailure)(nil),
		(*MessagePayload_HOComplete)(nil),
		(*MessagePayload_HOCause)(nil),
		(*MessagePayload_RRCMeasConfig)(nil),
		(*MessagePayload_RxSigMeasReport)(nil),
		(*MessagePayload_L2MeasConfig)(nil),
		(*MessagePayload_RadioMeasReportPerU)(nil),
		(*MessagePayload_RadioMeasReportPerCell)(nil),
		(*MessagePayload_SchedMeasReportPerUE)(nil),
		(*MessagePayload_SchedMeasReportPerCell)(nil),
		(*MessagePayload_PDCPMeasReportPerUe)(nil),
		(*MessagePayload_RRMConfig)(nil),
		(*MessagePayload_RRMConfigStatus)(nil),
		(*MessagePayload_UECapabilityEnquiry)(nil),
		(*MessagePayload_UECapabilityInfo)(nil),
		(*MessagePayload_ScellAdd)(nil),
		(*MessagePayload_ScellAddStatus)(nil),
		(*MessagePayload_ScellDelete)(nil),
		(*MessagePayload_SeNBAdd)(nil),
		(*MessagePayload_SeNBAddStatus)(nil),
		(*MessagePayload_SeNBDelete)(nil),
		(*MessagePayload_TrafficSplitConfig)(nil),
	}
}

// Full message frame having one header and one payload
type Message struct {
	Header  *MessageHeader  `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Payload *MessagePayload `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{5}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetHeader() *MessageHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *Message) GetPayload() *MessagePayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

// RPC result
type ServiceResult struct {
	ResultCode    int32  `protobuf:"varint,1,opt,name=resultCode,proto3" json:"resultCode,omitempty"`
	ResultMessage string `protobuf:"bytes,2,opt,name=resultMessage,proto3" json:"resultMessage,omitempty"`
}

func (m *ServiceResult) Reset()         { *m = ServiceResult{} }
func (m *ServiceResult) String() string { return proto.CompactTextString(m) }
func (*ServiceResult) ProtoMessage()    {}
func (*ServiceResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{6}
}
func (m *ServiceResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceResult.Merge(m, src)
}
func (m *ServiceResult) XXX_Size() int {
	return m.Size()
}
func (m *ServiceResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceResult.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceResult proto.InternalMessageInfo

func (m *ServiceResult) GetResultCode() int32 {
	if m != nil {
		return m.ResultCode
	}
	return 0
}

func (m *ServiceResult) GetResultMessage() string {
	if m != nil {
		return m.ResultMessage
	}
	return ""
}

type ECGI struct {
	PlmnId string `protobuf:"bytes,1,opt,name=plmnId,proto3" json:"plmnId,omitempty"`
	Ecid   string `protobuf:"bytes,2,opt,name=ecid,proto3" json:"ecid,omitempty"`
}

func (m *ECGI) Reset()         { *m = ECGI{} }
func (m *ECGI) String() string { return proto.CompactTextString(m) }
func (*ECGI) ProtoMessage()    {}
func (*ECGI) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{7}
}
func (m *ECGI) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ECGI) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ECGI.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ECGI) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ECGI.Merge(m, src)
}
func (m *ECGI) XXX_Size() int {
	return m.Size()
}
func (m *ECGI) XXX_DiscardUnknown() {
	xxx_messageInfo_ECGI.DiscardUnknown(m)
}

var xxx_messageInfo_ECGI proto.InternalMessageInfo

func (m *ECGI) GetPlmnId() string {
	if m != nil {
		return m.PlmnId
	}
	return ""
}

func (m *ECGI) GetEcid() string {
	if m != nil {
		return m.Ecid
	}
	return ""
}

type CandScell struct {
	Pci      uint32 `protobuf:"varint,1,opt,name=pci,proto3" json:"pci,omitempty"`
	EarfcnDl string `protobuf:"bytes,2,opt,name=earfcnDl,proto3" json:"earfcnDl,omitempty"`
	Ecgi     *ECGI  `protobuf:"bytes,3,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
}

func (m *CandScell) Reset()         { *m = CandScell{} }
func (m *CandScell) String() string { return proto.CompactTextString(m) }
func (*CandScell) ProtoMessage()    {}
func (*CandScell) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{8}
}
func (m *CandScell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CandScell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CandScell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CandScell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CandScell.Merge(m, src)
}
func (m *CandScell) XXX_Size() int {
	return m.Size()
}
func (m *CandScell) XXX_DiscardUnknown() {
	xxx_messageInfo_CandScell.DiscardUnknown(m)
}

var xxx_messageInfo_CandScell proto.InternalMessageInfo

func (m *CandScell) GetPci() uint32 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *CandScell) GetEarfcnDl() string {
	if m != nil {
		return m.EarfcnDl
	}
	return ""
}

func (m *CandScell) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

// CellConfigRequest message
type CellConfigRequest struct {
	Ecgi *ECGI `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
}

func (m *CellConfigRequest) Reset()         { *m = CellConfigRequest{} }
func (m *CellConfigRequest) String() string { return proto.CompactTextString(m) }
func (*CellConfigRequest) ProtoMessage()    {}
func (*CellConfigRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{9}
}
func (m *CellConfigRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CellConfigRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CellConfigRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CellConfigRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CellConfigRequest.Merge(m, src)
}
func (m *CellConfigRequest) XXX_Size() int {
	return m.Size()
}
func (m *CellConfigRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CellConfigRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CellConfigRequest proto.InternalMessageInfo

func (m *CellConfigRequest) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

// CellConfigReport message
type CellConfigReport struct {
	Ecgi                   *ECGI        `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Pci                    uint32       `protobuf:"varint,2,opt,name=pci,proto3" json:"pci,omitempty"`
	CandScells             []*CandScell `protobuf:"bytes,3,rep,name=candScells,proto3" json:"candScells,omitempty"`
	EarfcnDl               string       `protobuf:"bytes,4,opt,name=earfcnDl,proto3" json:"earfcnDl,omitempty"`
	EarfcnUl               string       `protobuf:"bytes,5,opt,name=earfcnUl,proto3" json:"earfcnUl,omitempty"`
	RbsPerTtiDl            uint32       `protobuf:"varint,6,opt,name=rbsPerTtiDl,proto3" json:"rbsPerTtiDl,omitempty"`
	RbsPerTtiUl            uint32       `protobuf:"varint,7,opt,name=rbsPerTtiUl,proto3" json:"rbsPerTtiUl,omitempty"`
	NumTxAntenna           uint32       `protobuf:"varint,8,opt,name=numTxAntenna,proto3" json:"numTxAntenna,omitempty"`
	DuplexMode             string       `protobuf:"bytes,9,opt,name=duplexMode,proto3" json:"duplexMode,omitempty"`
	MaxNumConnectedUes     uint32       `protobuf:"varint,10,opt,name=maxNumConnectedUes,proto3" json:"maxNumConnectedUes,omitempty"`
	MaxNumConnectedBearers uint32       `protobuf:"varint,11,opt,name=maxNumConnectedBearers,proto3" json:"maxNumConnectedBearers,omitempty"`
	MaxNumUesSchedPerTtiDl uint32       `protobuf:"varint,12,opt,name=maxNumUesSchedPerTtiDl,proto3" json:"maxNumUesSchedPerTtiDl,omitempty"`
	MaxNumUesSchedPerTtiUl uint32       `protobuf:"varint,13,opt,name=maxNumUesSchedPerTtiUl,proto3" json:"maxNumUesSchedPerTtiUl,omitempty"`
	DlfsSchedEnable        string       `protobuf:"bytes,14,opt,name=dlfsSchedEnable,proto3" json:"dlfsSchedEnable,omitempty"`
}

func (m *CellConfigReport) Reset()         { *m = CellConfigReport{} }
func (m *CellConfigReport) String() string { return proto.CompactTextString(m) }
func (*CellConfigReport) ProtoMessage()    {}
func (*CellConfigReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{10}
}
func (m *CellConfigReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CellConfigReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CellConfigReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CellConfigReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CellConfigReport.Merge(m, src)
}
func (m *CellConfigReport) XXX_Size() int {
	return m.Size()
}
func (m *CellConfigReport) XXX_DiscardUnknown() {
	xxx_messageInfo_CellConfigReport.DiscardUnknown(m)
}

var xxx_messageInfo_CellConfigReport proto.InternalMessageInfo

func (m *CellConfigReport) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *CellConfigReport) GetPci() uint32 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *CellConfigReport) GetCandScells() []*CandScell {
	if m != nil {
		return m.CandScells
	}
	return nil
}

func (m *CellConfigReport) GetEarfcnDl() string {
	if m != nil {
		return m.EarfcnDl
	}
	return ""
}

func (m *CellConfigReport) GetEarfcnUl() string {
	if m != nil {
		return m.EarfcnUl
	}
	return ""
}

func (m *CellConfigReport) GetRbsPerTtiDl() uint32 {
	if m != nil {
		return m.RbsPerTtiDl
	}
	return 0
}

func (m *CellConfigReport) GetRbsPerTtiUl() uint32 {
	if m != nil {
		return m.RbsPerTtiUl
	}
	return 0
}

func (m *CellConfigReport) GetNumTxAntenna() uint32 {
	if m != nil {
		return m.NumTxAntenna
	}
	return 0
}

func (m *CellConfigReport) GetDuplexMode() string {
	if m != nil {
		return m.DuplexMode
	}
	return ""
}

func (m *CellConfigReport) GetMaxNumConnectedUes() uint32 {
	if m != nil {
		return m.MaxNumConnectedUes
	}
	return 0
}

func (m *CellConfigReport) GetMaxNumConnectedBearers() uint32 {
	if m != nil {
		return m.MaxNumConnectedBearers
	}
	return 0
}

func (m *CellConfigReport) GetMaxNumUesSchedPerTtiDl() uint32 {
	if m != nil {
		return m.MaxNumUesSchedPerTtiDl
	}
	return 0
}

func (m *CellConfigReport) GetMaxNumUesSchedPerTtiUl() uint32 {
	if m != nil {
		return m.MaxNumUesSchedPerTtiUl
	}
	return 0
}

func (m *CellConfigReport) GetDlfsSchedEnable() string {
	if m != nil {
		return m.DlfsSchedEnable
	}
	return ""
}

// UEAdmissionRequest message
type UEAdmissionRequest struct {
	Crnti             string      `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi              *ECGI       `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	AdmissionEstCause AdmEstCause `protobuf:"varint,3,opt,name=admissionEstCause,proto3,enum=interface.e2.AdmEstCause" json:"admissionEstCause,omitempty"`
}

func (m *UEAdmissionRequest) Reset()         { *m = UEAdmissionRequest{} }
func (m *UEAdmissionRequest) String() string { return proto.CompactTextString(m) }
func (*UEAdmissionRequest) ProtoMessage()    {}
func (*UEAdmissionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{11}
}
func (m *UEAdmissionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEAdmissionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEAdmissionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEAdmissionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEAdmissionRequest.Merge(m, src)
}
func (m *UEAdmissionRequest) XXX_Size() int {
	return m.Size()
}
func (m *UEAdmissionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UEAdmissionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UEAdmissionRequest proto.InternalMessageInfo

func (m *UEAdmissionRequest) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UEAdmissionRequest) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEAdmissionRequest) GetAdmissionEstCause() AdmEstCause {
	if m != nil {
		return m.AdmissionEstCause
	}
	return AdmEstCause_EMERGENCY
}

// UEAdmissionResponse message
type UEAdmissionResponse struct {
	Crnti                string           `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi                 *ECGI            `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	AdmissionEstResponse SuccessOrFailure `protobuf:"varint,3,opt,name=admissionEstResponse,proto3,enum=interface.e2.SuccessOrFailure" json:"admissionEstResponse,omitempty"`
}

func (m *UEAdmissionResponse) Reset()         { *m = UEAdmissionResponse{} }
func (m *UEAdmissionResponse) String() string { return proto.CompactTextString(m) }
func (*UEAdmissionResponse) ProtoMessage()    {}
func (*UEAdmissionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{12}
}
func (m *UEAdmissionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEAdmissionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEAdmissionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEAdmissionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEAdmissionResponse.Merge(m, src)
}
func (m *UEAdmissionResponse) XXX_Size() int {
	return m.Size()
}
func (m *UEAdmissionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UEAdmissionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UEAdmissionResponse proto.InternalMessageInfo

func (m *UEAdmissionResponse) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UEAdmissionResponse) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEAdmissionResponse) GetAdmissionEstResponse() SuccessOrFailure {
	if m != nil {
		return m.AdmissionEstResponse
	}
	return SuccessOrFailure_SUCCESS
}

// UEAdmissionStatus message
type UEAdmissionStatus struct {
	Crnti              string           `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi               *ECGI            `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	AdmissionEstStatus SuccessOrFailure `protobuf:"varint,3,opt,name=admissionEstStatus,proto3,enum=interface.e2.SuccessOrFailure" json:"admissionEstStatus,omitempty"`
}

func (m *UEAdmissionStatus) Reset()         { *m = UEAdmissionStatus{} }
func (m *UEAdmissionStatus) String() string { return proto.CompactTextString(m) }
func (*UEAdmissionStatus) ProtoMessage()    {}
func (*UEAdmissionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{13}
}
func (m *UEAdmissionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEAdmissionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEAdmissionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEAdmissionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEAdmissionStatus.Merge(m, src)
}
func (m *UEAdmissionStatus) XXX_Size() int {
	return m.Size()
}
func (m *UEAdmissionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_UEAdmissionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_UEAdmissionStatus proto.InternalMessageInfo

func (m *UEAdmissionStatus) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UEAdmissionStatus) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEAdmissionStatus) GetAdmissionEstStatus() SuccessOrFailure {
	if m != nil {
		return m.AdmissionEstStatus
	}
	return SuccessOrFailure_SUCCESS
}

// UEContextUpdate message
type UEContextUpdate struct {
	Crnti       string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi        *ECGI  `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	MmeUeS1ApId string `protobuf:"bytes,3,opt,name=mmeUeS1apId,proto3" json:"mmeUeS1apId,omitempty"`
	EnbUeS1ApId string `protobuf:"bytes,4,opt,name=enbUeS1apId,proto3" json:"enbUeS1apId,omitempty"`
	Imsi        string `protobuf:"bytes,5,opt,name=imsi,proto3" json:"imsi,omitempty"`
}

func (m *UEContextUpdate) Reset()         { *m = UEContextUpdate{} }
func (m *UEContextUpdate) String() string { return proto.CompactTextString(m) }
func (*UEContextUpdate) ProtoMessage()    {}
func (*UEContextUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{14}
}
func (m *UEContextUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEContextUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEContextUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEContextUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEContextUpdate.Merge(m, src)
}
func (m *UEContextUpdate) XXX_Size() int {
	return m.Size()
}
func (m *UEContextUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_UEContextUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_UEContextUpdate proto.InternalMessageInfo

func (m *UEContextUpdate) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UEContextUpdate) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEContextUpdate) GetMmeUeS1ApId() string {
	if m != nil {
		return m.MmeUeS1ApId
	}
	return ""
}

func (m *UEContextUpdate) GetEnbUeS1ApId() string {
	if m != nil {
		return m.EnbUeS1ApId
	}
	return ""
}

func (m *UEContextUpdate) GetImsi() string {
	if m != nil {
		return m.Imsi
	}
	return ""
}

// UEReconfigInd message
type UEReconfigInd struct {
	CrntiOld      string        `protobuf:"bytes,1,opt,name=crntiOld,proto3" json:"crntiOld,omitempty"`
	Ecgi          *ECGI         `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	CrntiNew      string        `protobuf:"bytes,3,opt,name=crntiNew,proto3" json:"crntiNew,omitempty"`
	ReconfigCause ReconfigCause `protobuf:"varint,4,opt,name=reconfigCause,proto3,enum=interface.e2.ReconfigCause" json:"reconfigCause,omitempty"`
}

func (m *UEReconfigInd) Reset()         { *m = UEReconfigInd{} }
func (m *UEReconfigInd) String() string { return proto.CompactTextString(m) }
func (*UEReconfigInd) ProtoMessage()    {}
func (*UEReconfigInd) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{15}
}
func (m *UEReconfigInd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEReconfigInd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEReconfigInd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEReconfigInd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEReconfigInd.Merge(m, src)
}
func (m *UEReconfigInd) XXX_Size() int {
	return m.Size()
}
func (m *UEReconfigInd) XXX_DiscardUnknown() {
	xxx_messageInfo_UEReconfigInd.DiscardUnknown(m)
}

var xxx_messageInfo_UEReconfigInd proto.InternalMessageInfo

func (m *UEReconfigInd) GetCrntiOld() string {
	if m != nil {
		return m.CrntiOld
	}
	return ""
}

func (m *UEReconfigInd) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEReconfigInd) GetCrntiNew() string {
	if m != nil {
		return m.CrntiNew
	}
	return ""
}

func (m *UEReconfigInd) GetReconfigCause() ReconfigCause {
	if m != nil {
		return m.ReconfigCause
	}
	return ReconfigCause_RECONFIG_RLF
}

// UEReleaseInd message
type UEReleaseInd struct {
	Crnti        string       `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi         *ECGI        `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	ReleaseCause ReleaseCause `protobuf:"varint,3,opt,name=releaseCause,proto3,enum=interface.e2.ReleaseCause" json:"releaseCause,omitempty"`
}

func (m *UEReleaseInd) Reset()         { *m = UEReleaseInd{} }
func (m *UEReleaseInd) String() string { return proto.CompactTextString(m) }
func (*UEReleaseInd) ProtoMessage()    {}
func (*UEReleaseInd) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{16}
}
func (m *UEReleaseInd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEReleaseInd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEReleaseInd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEReleaseInd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEReleaseInd.Merge(m, src)
}
func (m *UEReleaseInd) XXX_Size() int {
	return m.Size()
}
func (m *UEReleaseInd) XXX_DiscardUnknown() {
	xxx_messageInfo_UEReleaseInd.DiscardUnknown(m)
}

var xxx_messageInfo_UEReleaseInd proto.InternalMessageInfo

func (m *UEReleaseInd) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UEReleaseInd) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UEReleaseInd) GetReleaseCause() ReleaseCause {
	if m != nil {
		return m.ReleaseCause
	}
	return ReleaseCause_RELEASE_INACTIVITY
}

type UEAMBR struct {
	AmbrDl string `protobuf:"bytes,1,opt,name=ambrDl,proto3" json:"ambrDl,omitempty"`
	AmbrUl string `protobuf:"bytes,2,opt,name=ambrUl,proto3" json:"ambrUl,omitempty"`
}

func (m *UEAMBR) Reset()         { *m = UEAMBR{} }
func (m *UEAMBR) String() string { return proto.CompactTextString(m) }
func (*UEAMBR) ProtoMessage()    {}
func (*UEAMBR) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{17}
}
func (m *UEAMBR) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UEAMBR) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UEAMBR.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UEAMBR) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UEAMBR.Merge(m, src)
}
func (m *UEAMBR) XXX_Size() int {
	return m.Size()
}
func (m *UEAMBR) XXX_DiscardUnknown() {
	xxx_messageInfo_UEAMBR.DiscardUnknown(m)
}

var xxx_messageInfo_UEAMBR proto.InternalMessageInfo

func (m *UEAMBR) GetAmbrDl() string {
	if m != nil {
		return m.AmbrDl
	}
	return ""
}

func (m *UEAMBR) GetAmbrUl() string {
	if m != nil {
		return m.AmbrUl
	}
	return ""
}

type ERABParamsItem struct {
	Id        string        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Direction ERABDirection `protobuf:"varint,2,opt,name=direction,proto3,enum=interface.e2.ERABDirection" json:"direction,omitempty"`
	Type      ERABType      `protobuf:"varint,3,opt,name=type,proto3,enum=interface.e2.ERABType" json:"type,omitempty"`
	Qci       string        `protobuf:"bytes,4,opt,name=qci,proto3" json:"qci,omitempty"`
	Arp       uint32        `protobuf:"varint,5,opt,name=arp,proto3" json:"arp,omitempty"`
	GbrDl     string        `protobuf:"bytes,6,opt,name=gbrDl,proto3" json:"gbrDl,omitempty"`
	GbrUl     string        `protobuf:"bytes,7,opt,name=gbrUl,proto3" json:"gbrUl,omitempty"`
	MbrDl     string        `protobuf:"bytes,8,opt,name=mbrDl,proto3" json:"mbrDl,omitempty"`
	MbrUl     string        `protobuf:"bytes,9,opt,name=mbrUl,proto3" json:"mbrUl,omitempty"`
}

func (m *ERABParamsItem) Reset()         { *m = ERABParamsItem{} }
func (m *ERABParamsItem) String() string { return proto.CompactTextString(m) }
func (*ERABParamsItem) ProtoMessage()    {}
func (*ERABParamsItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{18}
}
func (m *ERABParamsItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ERABParamsItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ERABParamsItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ERABParamsItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ERABParamsItem.Merge(m, src)
}
func (m *ERABParamsItem) XXX_Size() int {
	return m.Size()
}
func (m *ERABParamsItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ERABParamsItem.DiscardUnknown(m)
}

var xxx_messageInfo_ERABParamsItem proto.InternalMessageInfo

func (m *ERABParamsItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ERABParamsItem) GetDirection() ERABDirection {
	if m != nil {
		return m.Direction
	}
	return ERABDirection_DL
}

func (m *ERABParamsItem) GetType() ERABType {
	if m != nil {
		return m.Type
	}
	return ERABType_ERAB_DEFAULT
}

func (m *ERABParamsItem) GetQci() string {
	if m != nil {
		return m.Qci
	}
	return ""
}

func (m *ERABParamsItem) GetArp() uint32 {
	if m != nil {
		return m.Arp
	}
	return 0
}

func (m *ERABParamsItem) GetGbrDl() string {
	if m != nil {
		return m.GbrDl
	}
	return ""
}

func (m *ERABParamsItem) GetGbrUl() string {
	if m != nil {
		return m.GbrUl
	}
	return ""
}

func (m *ERABParamsItem) GetMbrDl() string {
	if m != nil {
		return m.MbrDl
	}
	return ""
}

func (m *ERABParamsItem) GetMbrUl() string {
	if m != nil {
		return m.MbrUl
	}
	return ""
}

type ERABResponseItem struct {
	Id       string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Decision SuccessOrFailure `protobuf:"varint,2,opt,name=decision,proto3,enum=interface.e2.SuccessOrFailure" json:"decision,omitempty"`
}

func (m *ERABResponseItem) Reset()         { *m = ERABResponseItem{} }
func (m *ERABResponseItem) String() string { return proto.CompactTextString(m) }
func (*ERABResponseItem) ProtoMessage()    {}
func (*ERABResponseItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{19}
}
func (m *ERABResponseItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ERABResponseItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ERABResponseItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ERABResponseItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ERABResponseItem.Merge(m, src)
}
func (m *ERABResponseItem) XXX_Size() int {
	return m.Size()
}
func (m *ERABResponseItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ERABResponseItem.DiscardUnknown(m)
}

var xxx_messageInfo_ERABResponseItem proto.InternalMessageInfo

func (m *ERABResponseItem) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ERABResponseItem) GetDecision() SuccessOrFailure {
	if m != nil {
		return m.Decision
	}
	return SuccessOrFailure_SUCCESS
}

// BearerAdmissionRequest message
type BearerAdmissionRequest struct {
	Crnti        string            `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi         *ECGI             `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	UeAmbr       *UEAMBR           `protobuf:"bytes,3,opt,name=ueAmbr,proto3" json:"ueAmbr,omitempty"`
	NumErabsList uint32            `protobuf:"varint,4,opt,name=numErabsList,proto3" json:"numErabsList,omitempty"`
	ErabsParams  []*ERABParamsItem `protobuf:"bytes,5,rep,name=erabsParams,proto3" json:"erabsParams,omitempty"`
}

func (m *BearerAdmissionRequest) Reset()         { *m = BearerAdmissionRequest{} }
func (m *BearerAdmissionRequest) String() string { return proto.CompactTextString(m) }
func (*BearerAdmissionRequest) ProtoMessage()    {}
func (*BearerAdmissionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{20}
}
func (m *BearerAdmissionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerAdmissionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerAdmissionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerAdmissionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerAdmissionRequest.Merge(m, src)
}
func (m *BearerAdmissionRequest) XXX_Size() int {
	return m.Size()
}
func (m *BearerAdmissionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerAdmissionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BearerAdmissionRequest proto.InternalMessageInfo

func (m *BearerAdmissionRequest) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *BearerAdmissionRequest) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *BearerAdmissionRequest) GetUeAmbr() *UEAMBR {
	if m != nil {
		return m.UeAmbr
	}
	return nil
}

func (m *BearerAdmissionRequest) GetNumErabsList() uint32 {
	if m != nil {
		return m.NumErabsList
	}
	return 0
}

func (m *BearerAdmissionRequest) GetErabsParams() []*ERABParamsItem {
	if m != nil {
		return m.ErabsParams
	}
	return nil
}

// BearerAdmissionResponse message
type BearerAdmissionResponse struct {
	Crnti        string              `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi         *ECGI               `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	NumErabsList uint32              `protobuf:"varint,3,opt,name=numErabsList,proto3" json:"numErabsList,omitempty"`
	ErabResponse []*ERABResponseItem `protobuf:"bytes,4,rep,name=erabResponse,proto3" json:"erabResponse,omitempty"`
}

func (m *BearerAdmissionResponse) Reset()         { *m = BearerAdmissionResponse{} }
func (m *BearerAdmissionResponse) String() string { return proto.CompactTextString(m) }
func (*BearerAdmissionResponse) ProtoMessage()    {}
func (*BearerAdmissionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{21}
}
func (m *BearerAdmissionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerAdmissionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerAdmissionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerAdmissionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerAdmissionResponse.Merge(m, src)
}
func (m *BearerAdmissionResponse) XXX_Size() int {
	return m.Size()
}
func (m *BearerAdmissionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerAdmissionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BearerAdmissionResponse proto.InternalMessageInfo

func (m *BearerAdmissionResponse) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *BearerAdmissionResponse) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *BearerAdmissionResponse) GetNumErabsList() uint32 {
	if m != nil {
		return m.NumErabsList
	}
	return 0
}

func (m *BearerAdmissionResponse) GetErabResponse() []*ERABResponseItem {
	if m != nil {
		return m.ErabResponse
	}
	return nil
}

// BearerAdmissionStatus message
type BearerAdmissionStatus struct {
	Crnti        string              `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi         *ECGI               `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	NumErabsList uint32              `protobuf:"varint,3,opt,name=numErabsList,proto3" json:"numErabsList,omitempty"`
	ErabStatus   []*ERABResponseItem `protobuf:"bytes,4,rep,name=erabStatus,proto3" json:"erabStatus,omitempty"`
}

func (m *BearerAdmissionStatus) Reset()         { *m = BearerAdmissionStatus{} }
func (m *BearerAdmissionStatus) String() string { return proto.CompactTextString(m) }
func (*BearerAdmissionStatus) ProtoMessage()    {}
func (*BearerAdmissionStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{22}
}
func (m *BearerAdmissionStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerAdmissionStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerAdmissionStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerAdmissionStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerAdmissionStatus.Merge(m, src)
}
func (m *BearerAdmissionStatus) XXX_Size() int {
	return m.Size()
}
func (m *BearerAdmissionStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerAdmissionStatus.DiscardUnknown(m)
}

var xxx_messageInfo_BearerAdmissionStatus proto.InternalMessageInfo

func (m *BearerAdmissionStatus) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *BearerAdmissionStatus) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *BearerAdmissionStatus) GetNumErabsList() uint32 {
	if m != nil {
		return m.NumErabsList
	}
	return 0
}

func (m *BearerAdmissionStatus) GetErabStatus() []*ERABResponseItem {
	if m != nil {
		return m.ErabStatus
	}
	return nil
}

// BearerReleaseInd message
type BearerReleaseInd struct {
	Crnti        string   `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi         *ECGI    `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	NumErabsList uint32   `protobuf:"varint,3,opt,name=numErabsList,proto3" json:"numErabsList,omitempty"`
	ErabIds      []string `protobuf:"bytes,4,rep,name=erabIds,proto3" json:"erabIds,omitempty"`
}

func (m *BearerReleaseInd) Reset()         { *m = BearerReleaseInd{} }
func (m *BearerReleaseInd) String() string { return proto.CompactTextString(m) }
func (*BearerReleaseInd) ProtoMessage()    {}
func (*BearerReleaseInd) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{23}
}
func (m *BearerReleaseInd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BearerReleaseInd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BearerReleaseInd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BearerReleaseInd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BearerReleaseInd.Merge(m, src)
}
func (m *BearerReleaseInd) XXX_Size() int {
	return m.Size()
}
func (m *BearerReleaseInd) XXX_DiscardUnknown() {
	xxx_messageInfo_BearerReleaseInd.DiscardUnknown(m)
}

var xxx_messageInfo_BearerReleaseInd proto.InternalMessageInfo

func (m *BearerReleaseInd) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *BearerReleaseInd) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *BearerReleaseInd) GetNumErabsList() uint32 {
	if m != nil {
		return m.NumErabsList
	}
	return 0
}

func (m *BearerReleaseInd) GetErabIds() []string {
	if m != nil {
		return m.ErabIds
	}
	return nil
}

// HORequest message
type HORequest struct {
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	EcgiS *ECGI  `protobuf:"bytes,2,opt,name=ecgiS,proto3" json:"ecgiS,omitempty"`
	EcgiT *ECGI  `protobuf:"bytes,3,opt,name=ecgiT,proto3" json:"ecgiT,omitempty"`
}

func (m *HORequest) Reset()         { *m = HORequest{} }
func (m *HORequest) String() string { return proto.CompactTextString(m) }
func (*HORequest) ProtoMessage()    {}
func (*HORequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{24}
}
func (m *HORequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HORequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HORequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HORequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HORequest.Merge(m, src)
}
func (m *HORequest) XXX_Size() int {
	return m.Size()
}
func (m *HORequest) XXX_DiscardUnknown() {
	xxx_messageInfo_HORequest.DiscardUnknown(m)
}

var xxx_messageInfo_HORequest proto.InternalMessageInfo

func (m *HORequest) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *HORequest) GetEcgiS() *ECGI {
	if m != nil {
		return m.EcgiS
	}
	return nil
}

func (m *HORequest) GetEcgiT() *ECGI {
	if m != nil {
		return m.EcgiT
	}
	return nil
}

// HOFailure message
type HOFailure struct {
	Crnti          string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	EcgiS          *ECGI  `protobuf:"bytes,2,opt,name=ecgiS,proto3" json:"ecgiS,omitempty"`
	HoFailureCause string `protobuf:"bytes,3,opt,name=hoFailureCause,proto3" json:"hoFailureCause,omitempty"`
}

func (m *HOFailure) Reset()         { *m = HOFailure{} }
func (m *HOFailure) String() string { return proto.CompactTextString(m) }
func (*HOFailure) ProtoMessage()    {}
func (*HOFailure) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{25}
}
func (m *HOFailure) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HOFailure) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HOFailure.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HOFailure) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HOFailure.Merge(m, src)
}
func (m *HOFailure) XXX_Size() int {
	return m.Size()
}
func (m *HOFailure) XXX_DiscardUnknown() {
	xxx_messageInfo_HOFailure.DiscardUnknown(m)
}

var xxx_messageInfo_HOFailure proto.InternalMessageInfo

func (m *HOFailure) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *HOFailure) GetEcgiS() *ECGI {
	if m != nil {
		return m.EcgiS
	}
	return nil
}

func (m *HOFailure) GetHoFailureCause() string {
	if m != nil {
		return m.HoFailureCause
	}
	return ""
}

// HOComplete message
type HOComplete struct {
	CrntiNew string `protobuf:"bytes,1,opt,name=crntiNew,proto3" json:"crntiNew,omitempty"`
	EcgiS    *ECGI  `protobuf:"bytes,2,opt,name=ecgiS,proto3" json:"ecgiS,omitempty"`
	EcgiT    *ECGI  `protobuf:"bytes,3,opt,name=ecgiT,proto3" json:"ecgiT,omitempty"`
}

func (m *HOComplete) Reset()         { *m = HOComplete{} }
func (m *HOComplete) String() string { return proto.CompactTextString(m) }
func (*HOComplete) ProtoMessage()    {}
func (*HOComplete) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{26}
}
func (m *HOComplete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HOComplete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HOComplete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HOComplete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HOComplete.Merge(m, src)
}
func (m *HOComplete) XXX_Size() int {
	return m.Size()
}
func (m *HOComplete) XXX_DiscardUnknown() {
	xxx_messageInfo_HOComplete.DiscardUnknown(m)
}

var xxx_messageInfo_HOComplete proto.InternalMessageInfo

func (m *HOComplete) GetCrntiNew() string {
	if m != nil {
		return m.CrntiNew
	}
	return ""
}

func (m *HOComplete) GetEcgiS() *ECGI {
	if m != nil {
		return m.EcgiS
	}
	return nil
}

func (m *HOComplete) GetEcgiT() *ECGI {
	if m != nil {
		return m.EcgiT
	}
	return nil
}

// HOCause message
type HOCause struct {
	Crnti     string         `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	EcgiS     *ECGI          `protobuf:"bytes,2,opt,name=ecgiS,proto3" json:"ecgiS,omitempty"`
	EcgiT     *ECGI          `protobuf:"bytes,3,opt,name=ecgiT,proto3" json:"ecgiT,omitempty"`
	HoCause   string         `protobuf:"bytes,4,opt,name=hoCause,proto3" json:"hoCause,omitempty"`
	HoTrigger []*RXSigReport `protobuf:"bytes,5,rep,name=hoTrigger,proto3" json:"hoTrigger,omitempty"`
}

func (m *HOCause) Reset()         { *m = HOCause{} }
func (m *HOCause) String() string { return proto.CompactTextString(m) }
func (*HOCause) ProtoMessage()    {}
func (*HOCause) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{27}
}
func (m *HOCause) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HOCause) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HOCause.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HOCause) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HOCause.Merge(m, src)
}
func (m *HOCause) XXX_Size() int {
	return m.Size()
}
func (m *HOCause) XXX_DiscardUnknown() {
	xxx_messageInfo_HOCause.DiscardUnknown(m)
}

var xxx_messageInfo_HOCause proto.InternalMessageInfo

func (m *HOCause) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *HOCause) GetEcgiS() *ECGI {
	if m != nil {
		return m.EcgiS
	}
	return nil
}

func (m *HOCause) GetEcgiT() *ECGI {
	if m != nil {
		return m.EcgiT
	}
	return nil
}

func (m *HOCause) GetHoCause() string {
	if m != nil {
		return m.HoCause
	}
	return ""
}

func (m *HOCause) GetHoTrigger() []*RXSigReport {
	if m != nil {
		return m.HoTrigger
	}
	return nil
}

type MeasCell struct {
	Pci                  uint32 `protobuf:"varint,1,opt,name=pci,proto3" json:"pci,omitempty"`
	CellIndividualOffset string `protobuf:"bytes,2,opt,name=cellIndividualOffset,proto3" json:"cellIndividualOffset,omitempty"`
}

func (m *MeasCell) Reset()         { *m = MeasCell{} }
func (m *MeasCell) String() string { return proto.CompactTextString(m) }
func (*MeasCell) ProtoMessage()    {}
func (*MeasCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{28}
}
func (m *MeasCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeasCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeasCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeasCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeasCell.Merge(m, src)
}
func (m *MeasCell) XXX_Size() int {
	return m.Size()
}
func (m *MeasCell) XXX_DiscardUnknown() {
	xxx_messageInfo_MeasCell.DiscardUnknown(m)
}

var xxx_messageInfo_MeasCell proto.InternalMessageInfo

func (m *MeasCell) GetPci() uint32 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *MeasCell) GetCellIndividualOffset() string {
	if m != nil {
		return m.CellIndividualOffset
	}
	return ""
}

type MeasObject struct {
	DlFreq    string      `protobuf:"bytes,1,opt,name=dlFreq,proto3" json:"dlFreq,omitempty"`
	MeasCells []*MeasCell `protobuf:"bytes,2,rep,name=measCells,proto3" json:"measCells,omitempty"`
}

func (m *MeasObject) Reset()         { *m = MeasObject{} }
func (m *MeasObject) String() string { return proto.CompactTextString(m) }
func (*MeasObject) ProtoMessage()    {}
func (*MeasObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{29}
}
func (m *MeasObject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeasObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeasObject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeasObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeasObject.Merge(m, src)
}
func (m *MeasObject) XXX_Size() int {
	return m.Size()
}
func (m *MeasObject) XXX_DiscardUnknown() {
	xxx_messageInfo_MeasObject.DiscardUnknown(m)
}

var xxx_messageInfo_MeasObject proto.InternalMessageInfo

func (m *MeasObject) GetDlFreq() string {
	if m != nil {
		return m.DlFreq
	}
	return ""
}

func (m *MeasObject) GetMeasCells() []*MeasCell {
	if m != nil {
		return m.MeasCells
	}
	return nil
}

type ReportParamChoice struct {
	// Types that are valid to be assigned to Choice:
	//	*ReportParamChoice_PerParam
	//	*ReportParamChoice_A1Param
	//	*ReportParamChoice_A2Param
	//	*ReportParamChoice_A3Param
	//	*ReportParamChoice_A4Param
	//	*ReportParamChoice_A5Param
	//	*ReportParamChoice_A6Param
	Choice isReportParamChoice_Choice `protobuf_oneof:"choice"`
}

func (m *ReportParamChoice) Reset()         { *m = ReportParamChoice{} }
func (m *ReportParamChoice) String() string { return proto.CompactTextString(m) }
func (*ReportParamChoice) ProtoMessage()    {}
func (*ReportParamChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{30}
}
func (m *ReportParamChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportParamChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportParamChoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportParamChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportParamChoice.Merge(m, src)
}
func (m *ReportParamChoice) XXX_Size() int {
	return m.Size()
}
func (m *ReportParamChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportParamChoice.DiscardUnknown(m)
}

var xxx_messageInfo_ReportParamChoice proto.InternalMessageInfo

type isReportParamChoice_Choice interface {
	isReportParamChoice_Choice()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ReportParamChoice_PerParam struct {
	PerParam *PerParam `protobuf:"bytes,1,opt,name=perParam,proto3,oneof" json:"perParam,omitempty"`
}
type ReportParamChoice_A1Param struct {
	A1Param *A1Param `protobuf:"bytes,2,opt,name=a1Param,proto3,oneof" json:"a1Param,omitempty"`
}
type ReportParamChoice_A2Param struct {
	A2Param *A2Param `protobuf:"bytes,3,opt,name=a2Param,proto3,oneof" json:"a2Param,omitempty"`
}
type ReportParamChoice_A3Param struct {
	A3Param *A3Param `protobuf:"bytes,4,opt,name=a3Param,proto3,oneof" json:"a3Param,omitempty"`
}
type ReportParamChoice_A4Param struct {
	A4Param *A4Param `protobuf:"bytes,5,opt,name=a4Param,proto3,oneof" json:"a4Param,omitempty"`
}
type ReportParamChoice_A5Param struct {
	A5Param *A5Param `protobuf:"bytes,6,opt,name=a5Param,proto3,oneof" json:"a5Param,omitempty"`
}
type ReportParamChoice_A6Param struct {
	A6Param *A6Param `protobuf:"bytes,7,opt,name=a6Param,proto3,oneof" json:"a6Param,omitempty"`
}

func (*ReportParamChoice_PerParam) isReportParamChoice_Choice() {}
func (*ReportParamChoice_A1Param) isReportParamChoice_Choice()  {}
func (*ReportParamChoice_A2Param) isReportParamChoice_Choice()  {}
func (*ReportParamChoice_A3Param) isReportParamChoice_Choice()  {}
func (*ReportParamChoice_A4Param) isReportParamChoice_Choice()  {}
func (*ReportParamChoice_A5Param) isReportParamChoice_Choice()  {}
func (*ReportParamChoice_A6Param) isReportParamChoice_Choice()  {}

func (m *ReportParamChoice) GetChoice() isReportParamChoice_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *ReportParamChoice) GetPerParam() *PerParam {
	if x, ok := m.GetChoice().(*ReportParamChoice_PerParam); ok {
		return x.PerParam
	}
	return nil
}

func (m *ReportParamChoice) GetA1Param() *A1Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A1Param); ok {
		return x.A1Param
	}
	return nil
}

func (m *ReportParamChoice) GetA2Param() *A2Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A2Param); ok {
		return x.A2Param
	}
	return nil
}

func (m *ReportParamChoice) GetA3Param() *A3Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A3Param); ok {
		return x.A3Param
	}
	return nil
}

func (m *ReportParamChoice) GetA4Param() *A4Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A4Param); ok {
		return x.A4Param
	}
	return nil
}

func (m *ReportParamChoice) GetA5Param() *A5Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A5Param); ok {
		return x.A5Param
	}
	return nil
}

func (m *ReportParamChoice) GetA6Param() *A6Param {
	if x, ok := m.GetChoice().(*ReportParamChoice_A6Param); ok {
		return x.A6Param
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ReportParamChoice) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ReportParamChoice_PerParam)(nil),
		(*ReportParamChoice_A1Param)(nil),
		(*ReportParamChoice_A2Param)(nil),
		(*ReportParamChoice_A3Param)(nil),
		(*ReportParamChoice_A4Param)(nil),
		(*ReportParamChoice_A5Param)(nil),
		(*ReportParamChoice_A6Param)(nil),
	}
}

type ThresholdEUTRAChoice struct {
	// Types that are valid to be assigned to Choice:
	//	*ThresholdEUTRAChoice_ThresholdRSRP
	//	*ThresholdEUTRAChoice_ThresholdRSRQ
	Choice isThresholdEUTRAChoice_Choice `protobuf_oneof:"choice"`
}

func (m *ThresholdEUTRAChoice) Reset()         { *m = ThresholdEUTRAChoice{} }
func (m *ThresholdEUTRAChoice) String() string { return proto.CompactTextString(m) }
func (*ThresholdEUTRAChoice) ProtoMessage()    {}
func (*ThresholdEUTRAChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{31}
}
func (m *ThresholdEUTRAChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThresholdEUTRAChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThresholdEUTRAChoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThresholdEUTRAChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThresholdEUTRAChoice.Merge(m, src)
}
func (m *ThresholdEUTRAChoice) XXX_Size() int {
	return m.Size()
}
func (m *ThresholdEUTRAChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_ThresholdEUTRAChoice.DiscardUnknown(m)
}

var xxx_messageInfo_ThresholdEUTRAChoice proto.InternalMessageInfo

type isThresholdEUTRAChoice_Choice interface {
	isThresholdEUTRAChoice_Choice()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ThresholdEUTRAChoice_ThresholdRSRP struct {
	ThresholdRSRP string `protobuf:"bytes,1,opt,name=thresholdRSRP,proto3,oneof" json:"thresholdRSRP,omitempty"`
}
type ThresholdEUTRAChoice_ThresholdRSRQ struct {
	ThresholdRSRQ string `protobuf:"bytes,2,opt,name=thresholdRSRQ,proto3,oneof" json:"thresholdRSRQ,omitempty"`
}

func (*ThresholdEUTRAChoice_ThresholdRSRP) isThresholdEUTRAChoice_Choice() {}
func (*ThresholdEUTRAChoice_ThresholdRSRQ) isThresholdEUTRAChoice_Choice() {}

func (m *ThresholdEUTRAChoice) GetChoice() isThresholdEUTRAChoice_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *ThresholdEUTRAChoice) GetThresholdRSRP() string {
	if x, ok := m.GetChoice().(*ThresholdEUTRAChoice_ThresholdRSRP); ok {
		return x.ThresholdRSRP
	}
	return ""
}

func (m *ThresholdEUTRAChoice) GetThresholdRSRQ() string {
	if x, ok := m.GetChoice().(*ThresholdEUTRAChoice_ThresholdRSRQ); ok {
		return x.ThresholdRSRQ
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ThresholdEUTRAChoice) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ThresholdEUTRAChoice_ThresholdRSRP)(nil),
		(*ThresholdEUTRAChoice_ThresholdRSRQ)(nil),
	}
}

type ThreasholdEUTRA struct {
	Present ThresholdEUTRAPR      `protobuf:"varint,1,opt,name=present,proto3,enum=interface.e2.ThresholdEUTRAPR" json:"present,omitempty"`
	Choice  *ThresholdEUTRAChoice `protobuf:"bytes,2,opt,name=choice,proto3" json:"choice,omitempty"`
}

func (m *ThreasholdEUTRA) Reset()         { *m = ThreasholdEUTRA{} }
func (m *ThreasholdEUTRA) String() string { return proto.CompactTextString(m) }
func (*ThreasholdEUTRA) ProtoMessage()    {}
func (*ThreasholdEUTRA) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{32}
}
func (m *ThreasholdEUTRA) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ThreasholdEUTRA) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ThreasholdEUTRA.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ThreasholdEUTRA) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ThreasholdEUTRA.Merge(m, src)
}
func (m *ThreasholdEUTRA) XXX_Size() int {
	return m.Size()
}
func (m *ThreasholdEUTRA) XXX_DiscardUnknown() {
	xxx_messageInfo_ThreasholdEUTRA.DiscardUnknown(m)
}

var xxx_messageInfo_ThreasholdEUTRA proto.InternalMessageInfo

func (m *ThreasholdEUTRA) GetPresent() ThresholdEUTRAPR {
	if m != nil {
		return m.Present
	}
	return ThresholdEUTRAPR_THRESHOLD_EUTRA_PR_NOTHING
}

func (m *ThreasholdEUTRA) GetChoice() *ThresholdEUTRAChoice {
	if m != nil {
		return m.Choice
	}
	return nil
}

type PerParam struct {
	ReportIntervalMs PerParamReportIntervalMs `protobuf:"varint,1,opt,name=reportIntervalMs,proto3,enum=interface.e2.PerParamReportIntervalMs" json:"reportIntervalMs,omitempty"`
}

func (m *PerParam) Reset()         { *m = PerParam{} }
func (m *PerParam) String() string { return proto.CompactTextString(m) }
func (*PerParam) ProtoMessage()    {}
func (*PerParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{33}
}
func (m *PerParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PerParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PerParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PerParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PerParam.Merge(m, src)
}
func (m *PerParam) XXX_Size() int {
	return m.Size()
}
func (m *PerParam) XXX_DiscardUnknown() {
	xxx_messageInfo_PerParam.DiscardUnknown(m)
}

var xxx_messageInfo_PerParam proto.InternalMessageInfo

func (m *PerParam) GetReportIntervalMs() PerParamReportIntervalMs {
	if m != nil {
		return m.ReportIntervalMs
	}
	return PerParamReportIntervalMs_PER_PARAM_MS_120
}

type A1Param struct {
	A1Threshold *ThreasholdEUTRA `protobuf:"bytes,1,opt,name=a1Threshold,proto3" json:"a1Threshold,omitempty"`
}

func (m *A1Param) Reset()         { *m = A1Param{} }
func (m *A1Param) String() string { return proto.CompactTextString(m) }
func (*A1Param) ProtoMessage()    {}
func (*A1Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{34}
}
func (m *A1Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A1Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A1Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A1Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A1Param.Merge(m, src)
}
func (m *A1Param) XXX_Size() int {
	return m.Size()
}
func (m *A1Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A1Param.DiscardUnknown(m)
}

var xxx_messageInfo_A1Param proto.InternalMessageInfo

func (m *A1Param) GetA1Threshold() *ThreasholdEUTRA {
	if m != nil {
		return m.A1Threshold
	}
	return nil
}

type A2Param struct {
	A2Threshold *ThreasholdEUTRA `protobuf:"bytes,1,opt,name=a2Threshold,proto3" json:"a2Threshold,omitempty"`
}

func (m *A2Param) Reset()         { *m = A2Param{} }
func (m *A2Param) String() string { return proto.CompactTextString(m) }
func (*A2Param) ProtoMessage()    {}
func (*A2Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{35}
}
func (m *A2Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A2Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A2Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A2Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A2Param.Merge(m, src)
}
func (m *A2Param) XXX_Size() int {
	return m.Size()
}
func (m *A2Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A2Param.DiscardUnknown(m)
}

var xxx_messageInfo_A2Param proto.InternalMessageInfo

func (m *A2Param) GetA2Threshold() *ThreasholdEUTRA {
	if m != nil {
		return m.A2Threshold
	}
	return nil
}

type A3Param struct {
	A3Offset string `protobuf:"bytes,1,opt,name=a3Offset,proto3" json:"a3Offset,omitempty"`
}

func (m *A3Param) Reset()         { *m = A3Param{} }
func (m *A3Param) String() string { return proto.CompactTextString(m) }
func (*A3Param) ProtoMessage()    {}
func (*A3Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{36}
}
func (m *A3Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A3Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A3Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A3Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A3Param.Merge(m, src)
}
func (m *A3Param) XXX_Size() int {
	return m.Size()
}
func (m *A3Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A3Param.DiscardUnknown(m)
}

var xxx_messageInfo_A3Param proto.InternalMessageInfo

func (m *A3Param) GetA3Offset() string {
	if m != nil {
		return m.A3Offset
	}
	return ""
}

type A4Param struct {
	A4Threshold *ThreasholdEUTRA `protobuf:"bytes,1,opt,name=a4Threshold,proto3" json:"a4Threshold,omitempty"`
}

func (m *A4Param) Reset()         { *m = A4Param{} }
func (m *A4Param) String() string { return proto.CompactTextString(m) }
func (*A4Param) ProtoMessage()    {}
func (*A4Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{37}
}
func (m *A4Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A4Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A4Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A4Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A4Param.Merge(m, src)
}
func (m *A4Param) XXX_Size() int {
	return m.Size()
}
func (m *A4Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A4Param.DiscardUnknown(m)
}

var xxx_messageInfo_A4Param proto.InternalMessageInfo

func (m *A4Param) GetA4Threshold() *ThreasholdEUTRA {
	if m != nil {
		return m.A4Threshold
	}
	return nil
}

type A5Param struct {
	A5Threshold1 *ThreasholdEUTRA `protobuf:"bytes,1,opt,name=a5Threshold1,proto3" json:"a5Threshold1,omitempty"`
	A5Threshold2 *ThreasholdEUTRA `protobuf:"bytes,2,opt,name=a5Threshold2,proto3" json:"a5Threshold2,omitempty"`
}

func (m *A5Param) Reset()         { *m = A5Param{} }
func (m *A5Param) String() string { return proto.CompactTextString(m) }
func (*A5Param) ProtoMessage()    {}
func (*A5Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{38}
}
func (m *A5Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A5Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A5Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A5Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A5Param.Merge(m, src)
}
func (m *A5Param) XXX_Size() int {
	return m.Size()
}
func (m *A5Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A5Param.DiscardUnknown(m)
}

var xxx_messageInfo_A5Param proto.InternalMessageInfo

func (m *A5Param) GetA5Threshold1() *ThreasholdEUTRA {
	if m != nil {
		return m.A5Threshold1
	}
	return nil
}

func (m *A5Param) GetA5Threshold2() *ThreasholdEUTRA {
	if m != nil {
		return m.A5Threshold2
	}
	return nil
}

type A6Param struct {
	A6Offset string `protobuf:"bytes,1,opt,name=a6Offset,proto3" json:"a6Offset,omitempty"`
}

func (m *A6Param) Reset()         { *m = A6Param{} }
func (m *A6Param) String() string { return proto.CompactTextString(m) }
func (*A6Param) ProtoMessage()    {}
func (*A6Param) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{39}
}
func (m *A6Param) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *A6Param) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_A6Param.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *A6Param) XXX_Merge(src proto.Message) {
	xxx_messageInfo_A6Param.Merge(m, src)
}
func (m *A6Param) XXX_Size() int {
	return m.Size()
}
func (m *A6Param) XXX_DiscardUnknown() {
	xxx_messageInfo_A6Param.DiscardUnknown(m)
}

var xxx_messageInfo_A6Param proto.InternalMessageInfo

func (m *A6Param) GetA6Offset() string {
	if m != nil {
		return m.A6Offset
	}
	return ""
}

type ReportParam struct {
	Present       ReportParamPR      `protobuf:"varint,1,opt,name=present,proto3,enum=interface.e2.ReportParamPR" json:"present,omitempty"`
	Choice        *ReportParamChoice `protobuf:"bytes,2,opt,name=choice,proto3" json:"choice,omitempty"`
	Hysteresis    string             `protobuf:"bytes,3,opt,name=hysteresis,proto3" json:"hysteresis,omitempty"`
	Timetotrigger TimeToTrigger      `protobuf:"varint,4,opt,name=timetotrigger,proto3,enum=interface.e2.TimeToTrigger" json:"timetotrigger,omitempty"`
}

func (m *ReportParam) Reset()         { *m = ReportParam{} }
func (m *ReportParam) String() string { return proto.CompactTextString(m) }
func (*ReportParam) ProtoMessage()    {}
func (*ReportParam) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{40}
}
func (m *ReportParam) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportParam) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportParam.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportParam) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportParam.Merge(m, src)
}
func (m *ReportParam) XXX_Size() int {
	return m.Size()
}
func (m *ReportParam) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportParam.DiscardUnknown(m)
}

var xxx_messageInfo_ReportParam proto.InternalMessageInfo

func (m *ReportParam) GetPresent() ReportParamPR {
	if m != nil {
		return m.Present
	}
	return ReportParamPR_REPORT_PARAM_PR_NOTHING
}

func (m *ReportParam) GetChoice() *ReportParamChoice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *ReportParam) GetHysteresis() string {
	if m != nil {
		return m.Hysteresis
	}
	return ""
}

func (m *ReportParam) GetTimetotrigger() TimeToTrigger {
	if m != nil {
		return m.Timetotrigger
	}
	return TimeToTrigger_TTT_MS0
}

type ReportConfig struct {
	ReportParams    *ReportParam    `protobuf:"bytes,1,opt,name=reportParams,proto3" json:"reportParams,omitempty"`
	TriggerQuantity TriggerQuantity `protobuf:"varint,2,opt,name=triggerQuantity,proto3,enum=interface.e2.TriggerQuantity" json:"triggerQuantity,omitempty"`
	ReportQuality   ReportQuality   `protobuf:"varint,3,opt,name=reportQuality,proto3,enum=interface.e2.ReportQuality" json:"reportQuality,omitempty"`
}

func (m *ReportConfig) Reset()         { *m = ReportConfig{} }
func (m *ReportConfig) String() string { return proto.CompactTextString(m) }
func (*ReportConfig) ProtoMessage()    {}
func (*ReportConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{41}
}
func (m *ReportConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportConfig.Merge(m, src)
}
func (m *ReportConfig) XXX_Size() int {
	return m.Size()
}
func (m *ReportConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ReportConfig proto.InternalMessageInfo

func (m *ReportConfig) GetReportParams() *ReportParam {
	if m != nil {
		return m.ReportParams
	}
	return nil
}

func (m *ReportConfig) GetTriggerQuantity() TriggerQuantity {
	if m != nil {
		return m.TriggerQuantity
	}
	return TriggerQuantity_TQ_RSRP
}

func (m *ReportConfig) GetReportQuality() ReportQuality {
	if m != nil {
		return m.ReportQuality
	}
	return ReportQuality_RQ_SAME
}

type AddMeasId struct {
	AddMeasId []string `protobuf:"bytes,1,rep,name=addMeasId,proto3" json:"addMeasId,omitempty"`
}

func (m *AddMeasId) Reset()         { *m = AddMeasId{} }
func (m *AddMeasId) String() string { return proto.CompactTextString(m) }
func (*AddMeasId) ProtoMessage()    {}
func (*AddMeasId) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{42}
}
func (m *AddMeasId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddMeasId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddMeasId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddMeasId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddMeasId.Merge(m, src)
}
func (m *AddMeasId) XXX_Size() int {
	return m.Size()
}
func (m *AddMeasId) XXX_DiscardUnknown() {
	xxx_messageInfo_AddMeasId.DiscardUnknown(m)
}

var xxx_messageInfo_AddMeasId proto.InternalMessageInfo

func (m *AddMeasId) GetAddMeasId() []string {
	if m != nil {
		return m.AddMeasId
	}
	return nil
}

type DelMeasId struct {
	DelMeasId []string `protobuf:"bytes,1,rep,name=delMeasId,proto3" json:"delMeasId,omitempty"`
}

func (m *DelMeasId) Reset()         { *m = DelMeasId{} }
func (m *DelMeasId) String() string { return proto.CompactTextString(m) }
func (*DelMeasId) ProtoMessage()    {}
func (*DelMeasId) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{43}
}
func (m *DelMeasId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelMeasId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelMeasId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelMeasId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelMeasId.Merge(m, src)
}
func (m *DelMeasId) XXX_Size() int {
	return m.Size()
}
func (m *DelMeasId) XXX_DiscardUnknown() {
	xxx_messageInfo_DelMeasId.DiscardUnknown(m)
}

var xxx_messageInfo_DelMeasId proto.InternalMessageInfo

func (m *DelMeasId) GetDelMeasId() []string {
	if m != nil {
		return m.DelMeasId
	}
	return nil
}

type MeasIdActionChoice struct {
	// Types that are valid to be assigned to Choice:
	//	*MeasIdActionChoice_AddMeasId
	//	*MeasIdActionChoice_DelMeasId
	//	*MeasIdActionChoice_Hototarget
	Choice isMeasIdActionChoice_Choice `protobuf_oneof:"choice"`
}

func (m *MeasIdActionChoice) Reset()         { *m = MeasIdActionChoice{} }
func (m *MeasIdActionChoice) String() string { return proto.CompactTextString(m) }
func (*MeasIdActionChoice) ProtoMessage()    {}
func (*MeasIdActionChoice) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{44}
}
func (m *MeasIdActionChoice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeasIdActionChoice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeasIdActionChoice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeasIdActionChoice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeasIdActionChoice.Merge(m, src)
}
func (m *MeasIdActionChoice) XXX_Size() int {
	return m.Size()
}
func (m *MeasIdActionChoice) XXX_DiscardUnknown() {
	xxx_messageInfo_MeasIdActionChoice.DiscardUnknown(m)
}

var xxx_messageInfo_MeasIdActionChoice proto.InternalMessageInfo

type isMeasIdActionChoice_Choice interface {
	isMeasIdActionChoice_Choice()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MeasIdActionChoice_AddMeasId struct {
	AddMeasId *AddMeasId `protobuf:"bytes,1,opt,name=addMeasId,proto3,oneof" json:"addMeasId,omitempty"`
}
type MeasIdActionChoice_DelMeasId struct {
	DelMeasId *DelMeasId `protobuf:"bytes,2,opt,name=delMeasId,proto3,oneof" json:"delMeasId,omitempty"`
}
type MeasIdActionChoice_Hototarget struct {
	Hototarget string `protobuf:"bytes,3,opt,name=hototarget,proto3,oneof" json:"hototarget,omitempty"`
}

func (*MeasIdActionChoice_AddMeasId) isMeasIdActionChoice_Choice()  {}
func (*MeasIdActionChoice_DelMeasId) isMeasIdActionChoice_Choice()  {}
func (*MeasIdActionChoice_Hototarget) isMeasIdActionChoice_Choice() {}

func (m *MeasIdActionChoice) GetChoice() isMeasIdActionChoice_Choice {
	if m != nil {
		return m.Choice
	}
	return nil
}

func (m *MeasIdActionChoice) GetAddMeasId() *AddMeasId {
	if x, ok := m.GetChoice().(*MeasIdActionChoice_AddMeasId); ok {
		return x.AddMeasId
	}
	return nil
}

func (m *MeasIdActionChoice) GetDelMeasId() *DelMeasId {
	if x, ok := m.GetChoice().(*MeasIdActionChoice_DelMeasId); ok {
		return x.DelMeasId
	}
	return nil
}

func (m *MeasIdActionChoice) GetHototarget() string {
	if x, ok := m.GetChoice().(*MeasIdActionChoice_Hototarget); ok {
		return x.Hototarget
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MeasIdActionChoice) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MeasIdActionChoice_AddMeasId)(nil),
		(*MeasIdActionChoice_DelMeasId)(nil),
		(*MeasIdActionChoice_Hototarget)(nil),
	}
}

type MeasIdAction struct {
	Present MeasIdActionPR      `protobuf:"varint,1,opt,name=present,proto3,enum=interface.e2.MeasIdActionPR" json:"present,omitempty"`
	Choice  *MeasIdActionChoice `protobuf:"bytes,2,opt,name=choice,proto3" json:"choice,omitempty"`
}

func (m *MeasIdAction) Reset()         { *m = MeasIdAction{} }
func (m *MeasIdAction) String() string { return proto.CompactTextString(m) }
func (*MeasIdAction) ProtoMessage()    {}
func (*MeasIdAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{45}
}
func (m *MeasIdAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeasIdAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeasIdAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeasIdAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeasIdAction.Merge(m, src)
}
func (m *MeasIdAction) XXX_Size() int {
	return m.Size()
}
func (m *MeasIdAction) XXX_DiscardUnknown() {
	xxx_messageInfo_MeasIdAction.DiscardUnknown(m)
}

var xxx_messageInfo_MeasIdAction proto.InternalMessageInfo

func (m *MeasIdAction) GetPresent() MeasIdActionPR {
	if m != nil {
		return m.Present
	}
	return MeasIdActionPR_MEAS_ID_ACTION_PR_NOTHING
}

func (m *MeasIdAction) GetChoice() *MeasIdActionChoice {
	if m != nil {
		return m.Choice
	}
	return nil
}

type MeasID struct {
	MeasObjectId   string        `protobuf:"bytes,1,opt,name=measObjectId,proto3" json:"measObjectId,omitempty"`
	ReportConfigId string        `protobuf:"bytes,2,opt,name=reportConfigId,proto3" json:"reportConfigId,omitempty"`
	Action         *MeasIdAction `protobuf:"bytes,3,opt,name=action,proto3" json:"action,omitempty"`
}

func (m *MeasID) Reset()         { *m = MeasID{} }
func (m *MeasID) String() string { return proto.CompactTextString(m) }
func (*MeasID) ProtoMessage()    {}
func (*MeasID) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{46}
}
func (m *MeasID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeasID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeasID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeasID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeasID.Merge(m, src)
}
func (m *MeasID) XXX_Size() int {
	return m.Size()
}
func (m *MeasID) XXX_DiscardUnknown() {
	xxx_messageInfo_MeasID.DiscardUnknown(m)
}

var xxx_messageInfo_MeasID proto.InternalMessageInfo

func (m *MeasID) GetMeasObjectId() string {
	if m != nil {
		return m.MeasObjectId
	}
	return ""
}

func (m *MeasID) GetReportConfigId() string {
	if m != nil {
		return m.ReportConfigId
	}
	return ""
}

func (m *MeasID) GetAction() *MeasIdAction {
	if m != nil {
		return m.Action
	}
	return nil
}

// RRCMeasConfig message
type RRCMeasConfig struct {
	Ecgi          *ECGI           `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti         []string        `protobuf:"bytes,2,rep,name=crnti,proto3" json:"crnti,omitempty"`
	MeasObjects   []*MeasObject   `protobuf:"bytes,3,rep,name=measObjects,proto3" json:"measObjects,omitempty"`
	ReportConfigs []*ReportConfig `protobuf:"bytes,4,rep,name=reportConfigs,proto3" json:"reportConfigs,omitempty"`
	MeasIds       []*MeasID       `protobuf:"bytes,5,rep,name=measIds,proto3" json:"measIds,omitempty"`
}

func (m *RRCMeasConfig) Reset()         { *m = RRCMeasConfig{} }
func (m *RRCMeasConfig) String() string { return proto.CompactTextString(m) }
func (*RRCMeasConfig) ProtoMessage()    {}
func (*RRCMeasConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{47}
}
func (m *RRCMeasConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RRCMeasConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RRCMeasConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RRCMeasConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RRCMeasConfig.Merge(m, src)
}
func (m *RRCMeasConfig) XXX_Size() int {
	return m.Size()
}
func (m *RRCMeasConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RRCMeasConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RRCMeasConfig proto.InternalMessageInfo

func (m *RRCMeasConfig) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RRCMeasConfig) GetCrnti() []string {
	if m != nil {
		return m.Crnti
	}
	return nil
}

func (m *RRCMeasConfig) GetMeasObjects() []*MeasObject {
	if m != nil {
		return m.MeasObjects
	}
	return nil
}

func (m *RRCMeasConfig) GetReportConfigs() []*ReportConfig {
	if m != nil {
		return m.ReportConfigs
	}
	return nil
}

func (m *RRCMeasConfig) GetMeasIds() []*MeasID {
	if m != nil {
		return m.MeasIds
	}
	return nil
}

type PCIARFCN struct {
	Pci      uint32 `protobuf:"varint,1,opt,name=pci,proto3" json:"pci,omitempty"`
	EarfcnDl string `protobuf:"bytes,2,opt,name=earfcnDl,proto3" json:"earfcnDl,omitempty"`
}

func (m *PCIARFCN) Reset()         { *m = PCIARFCN{} }
func (m *PCIARFCN) String() string { return proto.CompactTextString(m) }
func (*PCIARFCN) ProtoMessage()    {}
func (*PCIARFCN) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{48}
}
func (m *PCIARFCN) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PCIARFCN) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PCIARFCN.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PCIARFCN) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PCIARFCN.Merge(m, src)
}
func (m *PCIARFCN) XXX_Size() int {
	return m.Size()
}
func (m *PCIARFCN) XXX_DiscardUnknown() {
	xxx_messageInfo_PCIARFCN.DiscardUnknown(m)
}

var xxx_messageInfo_PCIARFCN proto.InternalMessageInfo

func (m *PCIARFCN) GetPci() uint32 {
	if m != nil {
		return m.Pci
	}
	return 0
}

func (m *PCIARFCN) GetEarfcnDl() string {
	if m != nil {
		return m.EarfcnDl
	}
	return ""
}

type RXSigReport struct {
	PciArfcn *PCIARFCN `protobuf:"bytes,1,opt,name=pciArfcn,proto3" json:"pciArfcn,omitempty"`
	Ecgi     *ECGI     `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Rsrp     string    `protobuf:"bytes,3,opt,name=rsrp,proto3" json:"rsrp,omitempty"`
	Rsrq     string    `protobuf:"bytes,4,opt,name=rsrq,proto3" json:"rsrq,omitempty"`
}

func (m *RXSigReport) Reset()         { *m = RXSigReport{} }
func (m *RXSigReport) String() string { return proto.CompactTextString(m) }
func (*RXSigReport) ProtoMessage()    {}
func (*RXSigReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{49}
}
func (m *RXSigReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RXSigReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RXSigReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RXSigReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RXSigReport.Merge(m, src)
}
func (m *RXSigReport) XXX_Size() int {
	return m.Size()
}
func (m *RXSigReport) XXX_DiscardUnknown() {
	xxx_messageInfo_RXSigReport.DiscardUnknown(m)
}

var xxx_messageInfo_RXSigReport proto.InternalMessageInfo

func (m *RXSigReport) GetPciArfcn() *PCIARFCN {
	if m != nil {
		return m.PciArfcn
	}
	return nil
}

func (m *RXSigReport) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RXSigReport) GetRsrp() string {
	if m != nil {
		return m.Rsrp
	}
	return ""
}

func (m *RXSigReport) GetRsrq() string {
	if m != nil {
		return m.Rsrq
	}
	return ""
}

// RxSigMeasReport message
type RxSigMeasReport struct {
	Crnti          []string       `protobuf:"bytes,1,rep,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi           *ECGI          `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	CellMeasReport []*RXSigReport `protobuf:"bytes,3,rep,name=cellMeasReport,proto3" json:"cellMeasReport,omitempty"`
}

func (m *RxSigMeasReport) Reset()         { *m = RxSigMeasReport{} }
func (m *RxSigMeasReport) String() string { return proto.CompactTextString(m) }
func (*RxSigMeasReport) ProtoMessage()    {}
func (*RxSigMeasReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{50}
}
func (m *RxSigMeasReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RxSigMeasReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RxSigMeasReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RxSigMeasReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RxSigMeasReport.Merge(m, src)
}
func (m *RxSigMeasReport) XXX_Size() int {
	return m.Size()
}
func (m *RxSigMeasReport) XXX_DiscardUnknown() {
	xxx_messageInfo_RxSigMeasReport.DiscardUnknown(m)
}

var xxx_messageInfo_RxSigMeasReport proto.InternalMessageInfo

func (m *RxSigMeasReport) GetCrnti() []string {
	if m != nil {
		return m.Crnti
	}
	return nil
}

func (m *RxSigMeasReport) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RxSigMeasReport) GetCellMeasReport() []*RXSigReport {
	if m != nil {
		return m.CellMeasReport
	}
	return nil
}

type L2ReportInterval struct {
	TRadioMeasReportPerUe   L2MeasReportIntervals `protobuf:"varint,1,opt,name=tRadioMeasReportPerUe,proto3,enum=interface.e2.L2MeasReportIntervals" json:"tRadioMeasReportPerUe,omitempty"`
	TRadioMeasReportPerCell L2MeasReportIntervals `protobuf:"varint,2,opt,name=tRadioMeasReportPerCell,proto3,enum=interface.e2.L2MeasReportIntervals" json:"tRadioMeasReportPerCell,omitempty"`
	TSchedMeasReportPerUe   L2MeasReportIntervals `protobuf:"varint,3,opt,name=tSchedMeasReportPerUe,proto3,enum=interface.e2.L2MeasReportIntervals" json:"tSchedMeasReportPerUe,omitempty"`
	TSchedMeasReportPerCell L2MeasReportIntervals `protobuf:"varint,4,opt,name=tSchedMeasReportPerCell,proto3,enum=interface.e2.L2MeasReportIntervals" json:"tSchedMeasReportPerCell,omitempty"`
	TPdcpMeasReportPerUe    L2MeasReportIntervals `protobuf:"varint,5,opt,name=tPdcpMeasReportPerUe,proto3,enum=interface.e2.L2MeasReportIntervals" json:"tPdcpMeasReportPerUe,omitempty"`
}

func (m *L2ReportInterval) Reset()         { *m = L2ReportInterval{} }
func (m *L2ReportInterval) String() string { return proto.CompactTextString(m) }
func (*L2ReportInterval) ProtoMessage()    {}
func (*L2ReportInterval) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{51}
}
func (m *L2ReportInterval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2ReportInterval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2ReportInterval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2ReportInterval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2ReportInterval.Merge(m, src)
}
func (m *L2ReportInterval) XXX_Size() int {
	return m.Size()
}
func (m *L2ReportInterval) XXX_DiscardUnknown() {
	xxx_messageInfo_L2ReportInterval.DiscardUnknown(m)
}

var xxx_messageInfo_L2ReportInterval proto.InternalMessageInfo

func (m *L2ReportInterval) GetTRadioMeasReportPerUe() L2MeasReportIntervals {
	if m != nil {
		return m.TRadioMeasReportPerUe
	}
	return L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_NO_REPORT
}

func (m *L2ReportInterval) GetTRadioMeasReportPerCell() L2MeasReportIntervals {
	if m != nil {
		return m.TRadioMeasReportPerCell
	}
	return L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_NO_REPORT
}

func (m *L2ReportInterval) GetTSchedMeasReportPerUe() L2MeasReportIntervals {
	if m != nil {
		return m.TSchedMeasReportPerUe
	}
	return L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_NO_REPORT
}

func (m *L2ReportInterval) GetTSchedMeasReportPerCell() L2MeasReportIntervals {
	if m != nil {
		return m.TSchedMeasReportPerCell
	}
	return L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_NO_REPORT
}

func (m *L2ReportInterval) GetTPdcpMeasReportPerUe() L2MeasReportIntervals {
	if m != nil {
		return m.TPdcpMeasReportPerUe
	}
	return L2MeasReportIntervals_L2_MEAS_REPORT_INTERVAL_NO_REPORT
}

// L2MeasConfig message
type L2MeasConfig struct {
	Ecgi            *ECGI             `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti           []string          `protobuf:"bytes,2,rep,name=crnti,proto3" json:"crnti,omitempty"`
	ReportIntervals *L2ReportInterval `protobuf:"bytes,3,opt,name=reportIntervals,proto3" json:"reportIntervals,omitempty"`
}

func (m *L2MeasConfig) Reset()         { *m = L2MeasConfig{} }
func (m *L2MeasConfig) String() string { return proto.CompactTextString(m) }
func (*L2MeasConfig) ProtoMessage()    {}
func (*L2MeasConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{52}
}
func (m *L2MeasConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *L2MeasConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_L2MeasConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *L2MeasConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_L2MeasConfig.Merge(m, src)
}
func (m *L2MeasConfig) XXX_Size() int {
	return m.Size()
}
func (m *L2MeasConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_L2MeasConfig.DiscardUnknown(m)
}

var xxx_messageInfo_L2MeasConfig proto.InternalMessageInfo

func (m *L2MeasConfig) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *L2MeasConfig) GetCrnti() []string {
	if m != nil {
		return m.Crnti
	}
	return nil
}

func (m *L2MeasConfig) GetReportIntervals() *L2ReportInterval {
	if m != nil {
		return m.ReportIntervals
	}
	return nil
}

// L2MeasureReports (periodic) messages
type RadioRepPerServCell struct {
	Ecgi          *ECGI    `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	CqiHist       []uint32 `protobuf:"varint,2,rep,packed,name=cqiHist,proto3" json:"cqiHist,omitempty"`
	RiHist        []string `protobuf:"bytes,3,rep,name=riHist,proto3" json:"riHist,omitempty"`
	PuschSinrHist []string `protobuf:"bytes,4,rep,name=puschSinrHist,proto3" json:"puschSinrHist,omitempty"`
	PucchSinrHist []string `protobuf:"bytes,5,rep,name=pucchSinrHist,proto3" json:"pucchSinrHist,omitempty"`
}

func (m *RadioRepPerServCell) Reset()         { *m = RadioRepPerServCell{} }
func (m *RadioRepPerServCell) String() string { return proto.CompactTextString(m) }
func (*RadioRepPerServCell) ProtoMessage()    {}
func (*RadioRepPerServCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{53}
}
func (m *RadioRepPerServCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RadioRepPerServCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RadioRepPerServCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RadioRepPerServCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadioRepPerServCell.Merge(m, src)
}
func (m *RadioRepPerServCell) XXX_Size() int {
	return m.Size()
}
func (m *RadioRepPerServCell) XXX_DiscardUnknown() {
	xxx_messageInfo_RadioRepPerServCell.DiscardUnknown(m)
}

var xxx_messageInfo_RadioRepPerServCell proto.InternalMessageInfo

func (m *RadioRepPerServCell) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RadioRepPerServCell) GetCqiHist() []uint32 {
	if m != nil {
		return m.CqiHist
	}
	return nil
}

func (m *RadioRepPerServCell) GetRiHist() []string {
	if m != nil {
		return m.RiHist
	}
	return nil
}

func (m *RadioRepPerServCell) GetPuschSinrHist() []string {
	if m != nil {
		return m.PuschSinrHist
	}
	return nil
}

func (m *RadioRepPerServCell) GetPucchSinrHist() []string {
	if m != nil {
		return m.PucchSinrHist
	}
	return nil
}

// RadioMeasReportPerUE message
type RadioMeasReportPerUE struct {
	Ecgi                 *ECGI                  `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti                string                 `protobuf:"bytes,2,opt,name=crnti,proto3" json:"crnti,omitempty"`
	RadioReportServCells []*RadioRepPerServCell `protobuf:"bytes,3,rep,name=radioReportServCells,proto3" json:"radioReportServCells,omitempty"`
}

func (m *RadioMeasReportPerUE) Reset()         { *m = RadioMeasReportPerUE{} }
func (m *RadioMeasReportPerUE) String() string { return proto.CompactTextString(m) }
func (*RadioMeasReportPerUE) ProtoMessage()    {}
func (*RadioMeasReportPerUE) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{54}
}
func (m *RadioMeasReportPerUE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RadioMeasReportPerUE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RadioMeasReportPerUE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RadioMeasReportPerUE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadioMeasReportPerUE.Merge(m, src)
}
func (m *RadioMeasReportPerUE) XXX_Size() int {
	return m.Size()
}
func (m *RadioMeasReportPerUE) XXX_DiscardUnknown() {
	xxx_messageInfo_RadioMeasReportPerUE.DiscardUnknown(m)
}

var xxx_messageInfo_RadioMeasReportPerUE proto.InternalMessageInfo

func (m *RadioMeasReportPerUE) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RadioMeasReportPerUE) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *RadioMeasReportPerUE) GetRadioReportServCells() []*RadioRepPerServCell {
	if m != nil {
		return m.RadioReportServCells
	}
	return nil
}

// RadioMeasReportPerCell message
type RadioMeasReportPerCell struct {
	Ecgi               *ECGI    `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	PuschIntfPwrHist   []uint32 `protobuf:"varint,2,rep,packed,name=puschIntfPwrHist,proto3" json:"puschIntfPwrHist,omitempty"`
	PucchIntfPowerHist []uint32 `protobuf:"varint,3,rep,packed,name=pucchIntfPowerHist,proto3" json:"pucchIntfPowerHist,omitempty"`
}

func (m *RadioMeasReportPerCell) Reset()         { *m = RadioMeasReportPerCell{} }
func (m *RadioMeasReportPerCell) String() string { return proto.CompactTextString(m) }
func (*RadioMeasReportPerCell) ProtoMessage()    {}
func (*RadioMeasReportPerCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{55}
}
func (m *RadioMeasReportPerCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RadioMeasReportPerCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RadioMeasReportPerCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RadioMeasReportPerCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RadioMeasReportPerCell.Merge(m, src)
}
func (m *RadioMeasReportPerCell) XXX_Size() int {
	return m.Size()
}
func (m *RadioMeasReportPerCell) XXX_DiscardUnknown() {
	xxx_messageInfo_RadioMeasReportPerCell.DiscardUnknown(m)
}

var xxx_messageInfo_RadioMeasReportPerCell proto.InternalMessageInfo

func (m *RadioMeasReportPerCell) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RadioMeasReportPerCell) GetPuschIntfPwrHist() []uint32 {
	if m != nil {
		return m.PuschIntfPwrHist
	}
	return nil
}

func (m *RadioMeasReportPerCell) GetPucchIntfPowerHist() []uint32 {
	if m != nil {
		return m.PucchIntfPowerHist
	}
	return nil
}

type PRBUsage struct {
	PrbUsageDl []string `protobuf:"bytes,1,rep,name=prbUsageDl,proto3" json:"prbUsageDl,omitempty"`
	PrbUsageUl []string `protobuf:"bytes,2,rep,name=prbUsageUl,proto3" json:"prbUsageUl,omitempty"`
}

func (m *PRBUsage) Reset()         { *m = PRBUsage{} }
func (m *PRBUsage) String() string { return proto.CompactTextString(m) }
func (*PRBUsage) ProtoMessage()    {}
func (*PRBUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{56}
}
func (m *PRBUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PRBUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PRBUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PRBUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PRBUsage.Merge(m, src)
}
func (m *PRBUsage) XXX_Size() int {
	return m.Size()
}
func (m *PRBUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_PRBUsage.DiscardUnknown(m)
}

var xxx_messageInfo_PRBUsage proto.InternalMessageInfo

func (m *PRBUsage) GetPrbUsageDl() []string {
	if m != nil {
		return m.PrbUsageDl
	}
	return nil
}

func (m *PRBUsage) GetPrbUsageUl() []string {
	if m != nil {
		return m.PrbUsageUl
	}
	return nil
}

type SchedMeasRepPerServCell struct {
	Ecgi           *ECGI     `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	QciVals        []string  `protobuf:"bytes,2,rep,name=qciVals,proto3" json:"qciVals,omitempty"`
	PrbUsage       *PRBUsage `protobuf:"bytes,3,opt,name=prbUsage,proto3" json:"prbUsage,omitempty"`
	McsDl          []string  `protobuf:"bytes,4,rep,name=mcsDl,proto3" json:"mcsDl,omitempty"`
	NumSchedTtisDl []string  `protobuf:"bytes,5,rep,name=numSchedTtisDl,proto3" json:"numSchedTtisDl,omitempty"`
	McsUl          []string  `protobuf:"bytes,6,rep,name=mcsUl,proto3" json:"mcsUl,omitempty"`
	NumSchedTtisUl []string  `protobuf:"bytes,7,rep,name=numSchedTtisUl,proto3" json:"numSchedTtisUl,omitempty"`
	RankDl1        []string  `protobuf:"bytes,8,rep,name=rankDl1,proto3" json:"rankDl1,omitempty"`
	RankDl2        []string  `protobuf:"bytes,9,rep,name=rankDl2,proto3" json:"rankDl2,omitempty"`
}

func (m *SchedMeasRepPerServCell) Reset()         { *m = SchedMeasRepPerServCell{} }
func (m *SchedMeasRepPerServCell) String() string { return proto.CompactTextString(m) }
func (*SchedMeasRepPerServCell) ProtoMessage()    {}
func (*SchedMeasRepPerServCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{57}
}
func (m *SchedMeasRepPerServCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedMeasRepPerServCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedMeasRepPerServCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedMeasRepPerServCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedMeasRepPerServCell.Merge(m, src)
}
func (m *SchedMeasRepPerServCell) XXX_Size() int {
	return m.Size()
}
func (m *SchedMeasRepPerServCell) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedMeasRepPerServCell.DiscardUnknown(m)
}

var xxx_messageInfo_SchedMeasRepPerServCell proto.InternalMessageInfo

func (m *SchedMeasRepPerServCell) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetQciVals() []string {
	if m != nil {
		return m.QciVals
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetPrbUsage() *PRBUsage {
	if m != nil {
		return m.PrbUsage
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetMcsDl() []string {
	if m != nil {
		return m.McsDl
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetNumSchedTtisDl() []string {
	if m != nil {
		return m.NumSchedTtisDl
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetMcsUl() []string {
	if m != nil {
		return m.McsUl
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetNumSchedTtisUl() []string {
	if m != nil {
		return m.NumSchedTtisUl
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetRankDl1() []string {
	if m != nil {
		return m.RankDl1
	}
	return nil
}

func (m *SchedMeasRepPerServCell) GetRankDl2() []string {
	if m != nil {
		return m.RankDl2
	}
	return nil
}

// SchedMeasReportPerUE message
type SchedMeasReportPerUE struct {
	Ecgi                 *ECGI                      `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti                string                     `protobuf:"bytes,2,opt,name=crnti,proto3" json:"crnti,omitempty"`
	SchedReportServCells []*SchedMeasRepPerServCell `protobuf:"bytes,3,rep,name=schedReportServCells,proto3" json:"schedReportServCells,omitempty"`
}

func (m *SchedMeasReportPerUE) Reset()         { *m = SchedMeasReportPerUE{} }
func (m *SchedMeasReportPerUE) String() string { return proto.CompactTextString(m) }
func (*SchedMeasReportPerUE) ProtoMessage()    {}
func (*SchedMeasReportPerUE) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{58}
}
func (m *SchedMeasReportPerUE) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedMeasReportPerUE) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedMeasReportPerUE.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedMeasReportPerUE) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedMeasReportPerUE.Merge(m, src)
}
func (m *SchedMeasReportPerUE) XXX_Size() int {
	return m.Size()
}
func (m *SchedMeasReportPerUE) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedMeasReportPerUE.DiscardUnknown(m)
}

var xxx_messageInfo_SchedMeasReportPerUE proto.InternalMessageInfo

func (m *SchedMeasReportPerUE) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *SchedMeasReportPerUE) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *SchedMeasReportPerUE) GetSchedReportServCells() []*SchedMeasRepPerServCell {
	if m != nil {
		return m.SchedReportServCells
	}
	return nil
}

// SchedMeasReportPerCell message
type SchedMeasReportPerCell struct {
	Ecgi          *ECGI     `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	QciVals       []string  `protobuf:"bytes,2,rep,name=qciVals,proto3" json:"qciVals,omitempty"`
	PrbUsagePcell *PRBUsage `protobuf:"bytes,3,opt,name=prbUsagePcell,proto3" json:"prbUsagePcell,omitempty"`
	PrbUsageScell *PRBUsage `protobuf:"bytes,4,opt,name=prbUsageScell,proto3" json:"prbUsageScell,omitempty"`
}

func (m *SchedMeasReportPerCell) Reset()         { *m = SchedMeasReportPerCell{} }
func (m *SchedMeasReportPerCell) String() string { return proto.CompactTextString(m) }
func (*SchedMeasReportPerCell) ProtoMessage()    {}
func (*SchedMeasReportPerCell) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{59}
}
func (m *SchedMeasReportPerCell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedMeasReportPerCell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedMeasReportPerCell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedMeasReportPerCell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedMeasReportPerCell.Merge(m, src)
}
func (m *SchedMeasReportPerCell) XXX_Size() int {
	return m.Size()
}
func (m *SchedMeasReportPerCell) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedMeasReportPerCell.DiscardUnknown(m)
}

var xxx_messageInfo_SchedMeasReportPerCell proto.InternalMessageInfo

func (m *SchedMeasReportPerCell) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *SchedMeasReportPerCell) GetQciVals() []string {
	if m != nil {
		return m.QciVals
	}
	return nil
}

func (m *SchedMeasReportPerCell) GetPrbUsagePcell() *PRBUsage {
	if m != nil {
		return m.PrbUsagePcell
	}
	return nil
}

func (m *SchedMeasReportPerCell) GetPrbUsageScell() *PRBUsage {
	if m != nil {
		return m.PrbUsageScell
	}
	return nil
}

// PdcpMeasReportPerUE message
type PDCPMeasReportPerUe struct {
	Ecgi             *ECGI    `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti            string   `protobuf:"bytes,2,opt,name=crnti,proto3" json:"crnti,omitempty"`
	QciVals          []string `protobuf:"bytes,3,rep,name=qciVals,proto3" json:"qciVals,omitempty"`
	DataVolDl        []uint32 `protobuf:"varint,4,rep,packed,name=dataVolDl,proto3" json:"dataVolDl,omitempty"`
	DataVolUl        []uint32 `protobuf:"varint,5,rep,packed,name=dataVolUl,proto3" json:"dataVolUl,omitempty"`
	PktDelayDl       []uint32 `protobuf:"varint,6,rep,packed,name=pktDelayDl,proto3" json:"pktDelayDl,omitempty"`
	PktDiscardRateDl []uint32 `protobuf:"varint,7,rep,packed,name=pktDiscardRateDl,proto3" json:"pktDiscardRateDl,omitempty"`
	PktLossRateDl    []uint32 `protobuf:"varint,8,rep,packed,name=pktLossRateDl,proto3" json:"pktLossRateDl,omitempty"`
	PktLossRateUl    []uint32 `protobuf:"varint,9,rep,packed,name=pktLossRateUl,proto3" json:"pktLossRateUl,omitempty"`
	ThroughputDl     []uint32 `protobuf:"varint,10,rep,packed,name=throughputDl,proto3" json:"throughputDl,omitempty"`
	ThroughputUl     []uint32 `protobuf:"varint,11,rep,packed,name=throughputUl,proto3" json:"throughputUl,omitempty"`
}

func (m *PDCPMeasReportPerUe) Reset()         { *m = PDCPMeasReportPerUe{} }
func (m *PDCPMeasReportPerUe) String() string { return proto.CompactTextString(m) }
func (*PDCPMeasReportPerUe) ProtoMessage()    {}
func (*PDCPMeasReportPerUe) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{60}
}
func (m *PDCPMeasReportPerUe) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PDCPMeasReportPerUe) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PDCPMeasReportPerUe.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PDCPMeasReportPerUe) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PDCPMeasReportPerUe.Merge(m, src)
}
func (m *PDCPMeasReportPerUe) XXX_Size() int {
	return m.Size()
}
func (m *PDCPMeasReportPerUe) XXX_DiscardUnknown() {
	xxx_messageInfo_PDCPMeasReportPerUe.DiscardUnknown(m)
}

var xxx_messageInfo_PDCPMeasReportPerUe proto.InternalMessageInfo

func (m *PDCPMeasReportPerUe) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *PDCPMeasReportPerUe) GetQciVals() []string {
	if m != nil {
		return m.QciVals
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetDataVolDl() []uint32 {
	if m != nil {
		return m.DataVolDl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetDataVolUl() []uint32 {
	if m != nil {
		return m.DataVolUl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetPktDelayDl() []uint32 {
	if m != nil {
		return m.PktDelayDl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetPktDiscardRateDl() []uint32 {
	if m != nil {
		return m.PktDiscardRateDl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetPktLossRateDl() []uint32 {
	if m != nil {
		return m.PktLossRateDl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetPktLossRateUl() []uint32 {
	if m != nil {
		return m.PktLossRateUl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetThroughputDl() []uint32 {
	if m != nil {
		return m.ThroughputDl
	}
	return nil
}

func (m *PDCPMeasReportPerUe) GetThroughputUl() []uint32 {
	if m != nil {
		return m.ThroughputUl
	}
	return nil
}

// RRMConfig message
type RRMConfig struct {
	Ecgi              *ECGI     `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti             []string  `protobuf:"bytes,2,rep,name=crnti,proto3" json:"crnti,omitempty"`
	PciArfcn          *PCIARFCN `protobuf:"bytes,3,opt,name=pciArfcn,proto3" json:"pciArfcn,omitempty"`
	PA                []XICICPA `protobuf:"varint,4,rep,packed,name=pA,proto3,enum=interface.e2.XICICPA" json:"pA,omitempty"`
	StartPrbDl        []uint32  `protobuf:"varint,5,rep,packed,name=startPrbDl,proto3" json:"startPrbDl,omitempty"`
	EndPrbDl          []uint32  `protobuf:"varint,6,rep,packed,name=endPrbDl,proto3" json:"endPrbDl,omitempty"`
	SubFrameBitmaskDl []string  `protobuf:"bytes,7,rep,name=subFrameBitmaskDl,proto3" json:"subFrameBitmaskDl,omitempty"`
	P0UePusch         []uint32  `protobuf:"varint,8,rep,packed,name=p0UePusch,proto3" json:"p0UePusch,omitempty"`
	StartPrbUl        []uint32  `protobuf:"varint,9,rep,packed,name=startPrbUl,proto3" json:"startPrbUl,omitempty"`
	EndPrbUl          []uint32  `protobuf:"varint,10,rep,packed,name=endPrbUl,proto3" json:"endPrbUl,omitempty"`
	SubFrameBitmaskUl []string  `protobuf:"bytes,11,rep,name=subFrameBitmaskUl,proto3" json:"subFrameBitmaskUl,omitempty"`
}

func (m *RRMConfig) Reset()         { *m = RRMConfig{} }
func (m *RRMConfig) String() string { return proto.CompactTextString(m) }
func (*RRMConfig) ProtoMessage()    {}
func (*RRMConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{61}
}
func (m *RRMConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RRMConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RRMConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RRMConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RRMConfig.Merge(m, src)
}
func (m *RRMConfig) XXX_Size() int {
	return m.Size()
}
func (m *RRMConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RRMConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RRMConfig proto.InternalMessageInfo

func (m *RRMConfig) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RRMConfig) GetCrnti() []string {
	if m != nil {
		return m.Crnti
	}
	return nil
}

func (m *RRMConfig) GetPciArfcn() *PCIARFCN {
	if m != nil {
		return m.PciArfcn
	}
	return nil
}

func (m *RRMConfig) GetPA() []XICICPA {
	if m != nil {
		return m.PA
	}
	return nil
}

func (m *RRMConfig) GetStartPrbDl() []uint32 {
	if m != nil {
		return m.StartPrbDl
	}
	return nil
}

func (m *RRMConfig) GetEndPrbDl() []uint32 {
	if m != nil {
		return m.EndPrbDl
	}
	return nil
}

func (m *RRMConfig) GetSubFrameBitmaskDl() []string {
	if m != nil {
		return m.SubFrameBitmaskDl
	}
	return nil
}

func (m *RRMConfig) GetP0UePusch() []uint32 {
	if m != nil {
		return m.P0UePusch
	}
	return nil
}

func (m *RRMConfig) GetStartPrbUl() []uint32 {
	if m != nil {
		return m.StartPrbUl
	}
	return nil
}

func (m *RRMConfig) GetEndPrbUl() []uint32 {
	if m != nil {
		return m.EndPrbUl
	}
	return nil
}

func (m *RRMConfig) GetSubFrameBitmaskUl() []string {
	if m != nil {
		return m.SubFrameBitmaskUl
	}
	return nil
}

// RRMConfigStatus message
type RRMConfigStatus struct {
	Ecgi   *ECGI              `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Crnti  []string           `protobuf:"bytes,2,rep,name=crnti,proto3" json:"crnti,omitempty"`
	Status []SuccessOrFailure `protobuf:"varint,3,rep,packed,name=status,proto3,enum=interface.e2.SuccessOrFailure" json:"status,omitempty"`
}

func (m *RRMConfigStatus) Reset()         { *m = RRMConfigStatus{} }
func (m *RRMConfigStatus) String() string { return proto.CompactTextString(m) }
func (*RRMConfigStatus) ProtoMessage()    {}
func (*RRMConfigStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{62}
}
func (m *RRMConfigStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RRMConfigStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RRMConfigStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RRMConfigStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RRMConfigStatus.Merge(m, src)
}
func (m *RRMConfigStatus) XXX_Size() int {
	return m.Size()
}
func (m *RRMConfigStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RRMConfigStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RRMConfigStatus proto.InternalMessageInfo

func (m *RRMConfigStatus) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *RRMConfigStatus) GetCrnti() []string {
	if m != nil {
		return m.Crnti
	}
	return nil
}

func (m *RRMConfigStatus) GetStatus() []SuccessOrFailure {
	if m != nil {
		return m.Status
	}
	return nil
}

type CACap struct {
	Band              string       `protobuf:"bytes,1,opt,name=band,proto3" json:"band,omitempty"`
	Caclassdl         CACapClassDl `protobuf:"varint,2,opt,name=caclassdl,proto3,enum=interface.e2.CACapClassDl" json:"caclassdl,omitempty"`
	Caclassul         CACapClassUl `protobuf:"varint,3,opt,name=caclassul,proto3,enum=interface.e2.CACapClassUl" json:"caclassul,omitempty"`
	CrossCarrierSched string       `protobuf:"bytes,4,opt,name=crossCarrierSched,proto3" json:"crossCarrierSched,omitempty"`
}

func (m *CACap) Reset()         { *m = CACap{} }
func (m *CACap) String() string { return proto.CompactTextString(m) }
func (*CACap) ProtoMessage()    {}
func (*CACap) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{63}
}
func (m *CACap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CACap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CACap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CACap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CACap.Merge(m, src)
}
func (m *CACap) XXX_Size() int {
	return m.Size()
}
func (m *CACap) XXX_DiscardUnknown() {
	xxx_messageInfo_CACap.DiscardUnknown(m)
}

var xxx_messageInfo_CACap proto.InternalMessageInfo

func (m *CACap) GetBand() string {
	if m != nil {
		return m.Band
	}
	return ""
}

func (m *CACap) GetCaclassdl() CACapClassDl {
	if m != nil {
		return m.Caclassdl
	}
	return CACapClassDl_CACAP_CLASSDL_A
}

func (m *CACap) GetCaclassul() CACapClassUl {
	if m != nil {
		return m.Caclassul
	}
	return CACapClassUl_CACAP_CLASSUL_A
}

func (m *CACap) GetCrossCarrierSched() string {
	if m != nil {
		return m.CrossCarrierSched
	}
	return ""
}

type DCCap struct {
	DrbTypeSplit DCCapDrbType `protobuf:"varint,1,opt,name=drbTypeSplit,proto3,enum=interface.e2.DCCapDrbType" json:"drbTypeSplit,omitempty"`
}

func (m *DCCap) Reset()         { *m = DCCap{} }
func (m *DCCap) String() string { return proto.CompactTextString(m) }
func (*DCCap) ProtoMessage()    {}
func (*DCCap) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{64}
}
func (m *DCCap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DCCap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DCCap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DCCap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DCCap.Merge(m, src)
}
func (m *DCCap) XXX_Size() int {
	return m.Size()
}
func (m *DCCap) XXX_DiscardUnknown() {
	xxx_messageInfo_DCCap.DiscardUnknown(m)
}

var xxx_messageInfo_DCCap proto.InternalMessageInfo

func (m *DCCap) GetDrbTypeSplit() DCCapDrbType {
	if m != nil {
		return m.DrbTypeSplit
	}
	return DCCapDrbType_DCCAP_DRBTYPE_SUPPORTED
}

// UECapabilityEnqyuiry message
type UECapabilityEnquiry struct {
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi  *ECGI  `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
}

func (m *UECapabilityEnquiry) Reset()         { *m = UECapabilityEnquiry{} }
func (m *UECapabilityEnquiry) String() string { return proto.CompactTextString(m) }
func (*UECapabilityEnquiry) ProtoMessage()    {}
func (*UECapabilityEnquiry) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{65}
}
func (m *UECapabilityEnquiry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UECapabilityEnquiry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UECapabilityEnquiry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UECapabilityEnquiry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UECapabilityEnquiry.Merge(m, src)
}
func (m *UECapabilityEnquiry) XXX_Size() int {
	return m.Size()
}
func (m *UECapabilityEnquiry) XXX_DiscardUnknown() {
	xxx_messageInfo_UECapabilityEnquiry.DiscardUnknown(m)
}

var xxx_messageInfo_UECapabilityEnquiry proto.InternalMessageInfo

func (m *UECapabilityEnquiry) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UECapabilityEnquiry) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

// UECapabilityInfo message
type UECapabilityInfo struct {
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi  *ECGI  `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	CaCap *CACap `protobuf:"bytes,3,opt,name=caCap,proto3" json:"caCap,omitempty"`
	DcCap *DCCap `protobuf:"bytes,4,opt,name=dcCap,proto3" json:"dcCap,omitempty"`
}

func (m *UECapabilityInfo) Reset()         { *m = UECapabilityInfo{} }
func (m *UECapabilityInfo) String() string { return proto.CompactTextString(m) }
func (*UECapabilityInfo) ProtoMessage()    {}
func (*UECapabilityInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{66}
}
func (m *UECapabilityInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UECapabilityInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UECapabilityInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UECapabilityInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UECapabilityInfo.Merge(m, src)
}
func (m *UECapabilityInfo) XXX_Size() int {
	return m.Size()
}
func (m *UECapabilityInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_UECapabilityInfo.DiscardUnknown(m)
}

var xxx_messageInfo_UECapabilityInfo proto.InternalMessageInfo

func (m *UECapabilityInfo) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *UECapabilityInfo) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *UECapabilityInfo) GetCaCap() *CACap {
	if m != nil {
		return m.CaCap
	}
	return nil
}

func (m *UECapabilityInfo) GetDcCap() *DCCap {
	if m != nil {
		return m.DcCap
	}
	return nil
}

type PropScell struct {
	PciArfcn                *PCIARFCN   `protobuf:"bytes,1,opt,name=pciArfcn,proto3" json:"pciArfcn,omitempty"`
	CrossCarrierSchedEnable string      `protobuf:"bytes,2,opt,name=crossCarrierSchedEnable,proto3" json:"crossCarrierSchedEnable,omitempty"`
	CaDirection             CADirection `protobuf:"varint,3,opt,name=caDirection,proto3,enum=interface.e2.CADirection" json:"caDirection,omitempty"`
	DeactTimer              string      `protobuf:"bytes,4,opt,name=deactTimer,proto3" json:"deactTimer,omitempty"`
}

func (m *PropScell) Reset()         { *m = PropScell{} }
func (m *PropScell) String() string { return proto.CompactTextString(m) }
func (*PropScell) ProtoMessage()    {}
func (*PropScell) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{67}
}
func (m *PropScell) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PropScell) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PropScell.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PropScell) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PropScell.Merge(m, src)
}
func (m *PropScell) XXX_Size() int {
	return m.Size()
}
func (m *PropScell) XXX_DiscardUnknown() {
	xxx_messageInfo_PropScell.DiscardUnknown(m)
}

var xxx_messageInfo_PropScell proto.InternalMessageInfo

func (m *PropScell) GetPciArfcn() *PCIARFCN {
	if m != nil {
		return m.PciArfcn
	}
	return nil
}

func (m *PropScell) GetCrossCarrierSchedEnable() string {
	if m != nil {
		return m.CrossCarrierSchedEnable
	}
	return ""
}

func (m *PropScell) GetCaDirection() CADirection {
	if m != nil {
		return m.CaDirection
	}
	return CADirection_CADIRECTION_DL
}

func (m *PropScell) GetDeactTimer() string {
	if m != nil {
		return m.DeactTimer
	}
	return ""
}

// ScellAdd message
type ScellAdd struct {
	Crnti      string       `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi       *ECGI        `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	ScellsProp []*PropScell `protobuf:"bytes,3,rep,name=scellsProp,proto3" json:"scellsProp,omitempty"`
}

func (m *ScellAdd) Reset()         { *m = ScellAdd{} }
func (m *ScellAdd) String() string { return proto.CompactTextString(m) }
func (*ScellAdd) ProtoMessage()    {}
func (*ScellAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{68}
}
func (m *ScellAdd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScellAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScellAdd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScellAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScellAdd.Merge(m, src)
}
func (m *ScellAdd) XXX_Size() int {
	return m.Size()
}
func (m *ScellAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_ScellAdd.DiscardUnknown(m)
}

var xxx_messageInfo_ScellAdd proto.InternalMessageInfo

func (m *ScellAdd) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *ScellAdd) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *ScellAdd) GetScellsProp() []*PropScell {
	if m != nil {
		return m.ScellsProp
	}
	return nil
}

// ScellAddStatus message
type ScellAddStatus struct {
	Crnti     string             `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi      *ECGI              `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	ScellsInd []*PCIARFCN        `protobuf:"bytes,3,rep,name=scellsInd,proto3" json:"scellsInd,omitempty"`
	Status    []SuccessOrFailure `protobuf:"varint,4,rep,packed,name=status,proto3,enum=interface.e2.SuccessOrFailure" json:"status,omitempty"`
}

func (m *ScellAddStatus) Reset()         { *m = ScellAddStatus{} }
func (m *ScellAddStatus) String() string { return proto.CompactTextString(m) }
func (*ScellAddStatus) ProtoMessage()    {}
func (*ScellAddStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{69}
}
func (m *ScellAddStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScellAddStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScellAddStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScellAddStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScellAddStatus.Merge(m, src)
}
func (m *ScellAddStatus) XXX_Size() int {
	return m.Size()
}
func (m *ScellAddStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_ScellAddStatus.DiscardUnknown(m)
}

var xxx_messageInfo_ScellAddStatus proto.InternalMessageInfo

func (m *ScellAddStatus) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *ScellAddStatus) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *ScellAddStatus) GetScellsInd() []*PCIARFCN {
	if m != nil {
		return m.ScellsInd
	}
	return nil
}

func (m *ScellAddStatus) GetStatus() []SuccessOrFailure {
	if m != nil {
		return m.Status
	}
	return nil
}

// ScellDelete message
type ScellDelete struct {
	Crnti     string      `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi      *ECGI       `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	ScellsInd []*PCIARFCN `protobuf:"bytes,3,rep,name=scellsInd,proto3" json:"scellsInd,omitempty"`
}

func (m *ScellDelete) Reset()         { *m = ScellDelete{} }
func (m *ScellDelete) String() string { return proto.CompactTextString(m) }
func (*ScellDelete) ProtoMessage()    {}
func (*ScellDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{70}
}
func (m *ScellDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScellDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScellDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScellDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScellDelete.Merge(m, src)
}
func (m *ScellDelete) XXX_Size() int {
	return m.Size()
}
func (m *ScellDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_ScellDelete.DiscardUnknown(m)
}

var xxx_messageInfo_ScellDelete proto.InternalMessageInfo

func (m *ScellDelete) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *ScellDelete) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *ScellDelete) GetScellsInd() []*PCIARFCN {
	if m != nil {
		return m.ScellsInd
	}
	return nil
}

// SeNBAdd message
type SeNBAdd struct {
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	MEcgi *ECGI  `protobuf:"bytes,2,opt,name=mEcgi,proto3" json:"mEcgi,omitempty"`
	SEcgi *ECGI  `protobuf:"bytes,3,opt,name=sEcgi,proto3" json:"sEcgi,omitempty"`
}

func (m *SeNBAdd) Reset()         { *m = SeNBAdd{} }
func (m *SeNBAdd) String() string { return proto.CompactTextString(m) }
func (*SeNBAdd) ProtoMessage()    {}
func (*SeNBAdd) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{71}
}
func (m *SeNBAdd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeNBAdd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeNBAdd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeNBAdd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeNBAdd.Merge(m, src)
}
func (m *SeNBAdd) XXX_Size() int {
	return m.Size()
}
func (m *SeNBAdd) XXX_DiscardUnknown() {
	xxx_messageInfo_SeNBAdd.DiscardUnknown(m)
}

var xxx_messageInfo_SeNBAdd proto.InternalMessageInfo

func (m *SeNBAdd) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *SeNBAdd) GetMEcgi() *ECGI {
	if m != nil {
		return m.MEcgi
	}
	return nil
}

func (m *SeNBAdd) GetSEcgi() *ECGI {
	if m != nil {
		return m.SEcgi
	}
	return nil
}

// SeNBAddStatus message
type SeNBAddStatus struct {
	Crnti  string           `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi   *ECGI            `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	Status SuccessOrFailure `protobuf:"varint,3,opt,name=status,proto3,enum=interface.e2.SuccessOrFailure" json:"status,omitempty"`
}

func (m *SeNBAddStatus) Reset()         { *m = SeNBAddStatus{} }
func (m *SeNBAddStatus) String() string { return proto.CompactTextString(m) }
func (*SeNBAddStatus) ProtoMessage()    {}
func (*SeNBAddStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{72}
}
func (m *SeNBAddStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeNBAddStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeNBAddStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeNBAddStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeNBAddStatus.Merge(m, src)
}
func (m *SeNBAddStatus) XXX_Size() int {
	return m.Size()
}
func (m *SeNBAddStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SeNBAddStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SeNBAddStatus proto.InternalMessageInfo

func (m *SeNBAddStatus) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *SeNBAddStatus) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *SeNBAddStatus) GetStatus() SuccessOrFailure {
	if m != nil {
		return m.Status
	}
	return SuccessOrFailure_SUCCESS
}

// SeNBDelete message
type SeNBDelete struct {
	Crnti string `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	MEcgi *ECGI  `protobuf:"bytes,2,opt,name=mEcgi,proto3" json:"mEcgi,omitempty"`
	SEcgi *ECGI  `protobuf:"bytes,3,opt,name=sEcgi,proto3" json:"sEcgi,omitempty"`
}

func (m *SeNBDelete) Reset()         { *m = SeNBDelete{} }
func (m *SeNBDelete) String() string { return proto.CompactTextString(m) }
func (*SeNBDelete) ProtoMessage()    {}
func (*SeNBDelete) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{73}
}
func (m *SeNBDelete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeNBDelete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeNBDelete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeNBDelete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeNBDelete.Merge(m, src)
}
func (m *SeNBDelete) XXX_Size() int {
	return m.Size()
}
func (m *SeNBDelete) XXX_DiscardUnknown() {
	xxx_messageInfo_SeNBDelete.DiscardUnknown(m)
}

var xxx_messageInfo_SeNBDelete proto.InternalMessageInfo

func (m *SeNBDelete) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *SeNBDelete) GetMEcgi() *ECGI {
	if m != nil {
		return m.MEcgi
	}
	return nil
}

func (m *SeNBDelete) GetSEcgi() *ECGI {
	if m != nil {
		return m.SEcgi
	}
	return nil
}

type TrafficSplitPercentage struct {
	Ecgi                *ECGI  `protobuf:"bytes,1,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	TrafficPercentageDl string `protobuf:"bytes,2,opt,name=trafficPercentageDl,proto3" json:"trafficPercentageDl,omitempty"`
	TrafficPercentageUl string `protobuf:"bytes,3,opt,name=trafficPercentageUl,proto3" json:"trafficPercentageUl,omitempty"`
}

func (m *TrafficSplitPercentage) Reset()         { *m = TrafficSplitPercentage{} }
func (m *TrafficSplitPercentage) String() string { return proto.CompactTextString(m) }
func (*TrafficSplitPercentage) ProtoMessage()    {}
func (*TrafficSplitPercentage) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{74}
}
func (m *TrafficSplitPercentage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrafficSplitPercentage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrafficSplitPercentage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrafficSplitPercentage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficSplitPercentage.Merge(m, src)
}
func (m *TrafficSplitPercentage) XXX_Size() int {
	return m.Size()
}
func (m *TrafficSplitPercentage) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficSplitPercentage.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficSplitPercentage proto.InternalMessageInfo

func (m *TrafficSplitPercentage) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *TrafficSplitPercentage) GetTrafficPercentageDl() string {
	if m != nil {
		return m.TrafficPercentageDl
	}
	return ""
}

func (m *TrafficSplitPercentage) GetTrafficPercentageUl() string {
	if m != nil {
		return m.TrafficPercentageUl
	}
	return ""
}

// TrafficSplitConfig message
type TrafficSplitConfig struct {
	Crnti                  string                    `protobuf:"bytes,1,opt,name=crnti,proto3" json:"crnti,omitempty"`
	Ecgi                   *ECGI                     `protobuf:"bytes,2,opt,name=ecgi,proto3" json:"ecgi,omitempty"`
	TrafficSplitPercentage []*TrafficSplitPercentage `protobuf:"bytes,3,rep,name=trafficSplitPercentage,proto3" json:"trafficSplitPercentage,omitempty"`
}

func (m *TrafficSplitConfig) Reset()         { *m = TrafficSplitConfig{} }
func (m *TrafficSplitConfig) String() string { return proto.CompactTextString(m) }
func (*TrafficSplitConfig) ProtoMessage()    {}
func (*TrafficSplitConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_310687c643405aa4, []int{75}
}
func (m *TrafficSplitConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrafficSplitConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrafficSplitConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrafficSplitConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrafficSplitConfig.Merge(m, src)
}
func (m *TrafficSplitConfig) XXX_Size() int {
	return m.Size()
}
func (m *TrafficSplitConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_TrafficSplitConfig.DiscardUnknown(m)
}

var xxx_messageInfo_TrafficSplitConfig proto.InternalMessageInfo

func (m *TrafficSplitConfig) GetCrnti() string {
	if m != nil {
		return m.Crnti
	}
	return ""
}

func (m *TrafficSplitConfig) GetEcgi() *ECGI {
	if m != nil {
		return m.Ecgi
	}
	return nil
}

func (m *TrafficSplitConfig) GetTrafficSplitPercentage() []*TrafficSplitPercentage {
	if m != nil {
		return m.TrafficSplitPercentage
	}
	return nil
}

func init() {
	proto.RegisterEnum("interface.e2.MessageType", MessageType_name, MessageType_value)
	proto.RegisterEnum("interface.e2.AdmEstCause", AdmEstCause_name, AdmEstCause_value)
	proto.RegisterEnum("interface.e2.SuccessOrFailure", SuccessOrFailure_name, SuccessOrFailure_value)
	proto.RegisterEnum("interface.e2.ReconfigCause", ReconfigCause_name, ReconfigCause_value)
	proto.RegisterEnum("interface.e2.ReleaseCause", ReleaseCause_name, ReleaseCause_value)
	proto.RegisterEnum("interface.e2.ERABDirection", ERABDirection_name, ERABDirection_value)
	proto.RegisterEnum("interface.e2.ERABType", ERABType_name, ERABType_value)
	proto.RegisterEnum("interface.e2.ReportParamPR", ReportParamPR_name, ReportParamPR_value)
	proto.RegisterEnum("interface.e2.PerParamReportIntervalMs", PerParamReportIntervalMs_name, PerParamReportIntervalMs_value)
	proto.RegisterEnum("interface.e2.ThresholdEUTRAPR", ThresholdEUTRAPR_name, ThresholdEUTRAPR_value)
	proto.RegisterEnum("interface.e2.TimeToTrigger", TimeToTrigger_name, TimeToTrigger_value)
	proto.RegisterEnum("interface.e2.TriggerQuantity", TriggerQuantity_name, TriggerQuantity_value)
	proto.RegisterEnum("interface.e2.ReportQuality", ReportQuality_name, ReportQuality_value)
	proto.RegisterEnum("interface.e2.MeasIdActionPR", MeasIdActionPR_name, MeasIdActionPR_value)
	proto.RegisterEnum("interface.e2.L2MeasReportIntervals", L2MeasReportIntervals_name, L2MeasReportIntervals_value)
	proto.RegisterEnum("interface.e2.XICICPA", XICICPA_name, XICICPA_value)
	proto.RegisterEnum("interface.e2.CACapClassDl", CACapClassDl_name, CACapClassDl_value)
	proto.RegisterEnum("interface.e2.CACapClassUl", CACapClassUl_name, CACapClassUl_value)
	proto.RegisterEnum("interface.e2.DCCapDrbType", DCCapDrbType_name, DCCapDrbType_value)
	proto.RegisterEnum("interface.e2.CADirection", CADirection_name, CADirection_value)
	proto.RegisterType((*TelemetryMessage)(nil), "interface.e2.TelemetryMessage")
	proto.RegisterType((*ControlUpdate)(nil), "interface.e2.ControlUpdate")
	proto.RegisterType((*ControlResponse)(nil), "interface.e2.ControlResponse")
	proto.RegisterType((*MessageHeader)(nil), "interface.e2.MessageHeader")
	proto.RegisterType((*MessagePayload)(nil), "interface.e2.MessagePayload")
	proto.RegisterType((*Message)(nil), "interface.e2.Message")
	proto.RegisterType((*ServiceResult)(nil), "interface.e2.ServiceResult")
	proto.RegisterType((*ECGI)(nil), "interface.e2.ECGI")
	proto.RegisterType((*CandScell)(nil), "interface.e2.CandScell")
	proto.RegisterType((*CellConfigRequest)(nil), "interface.e2.CellConfigRequest")
	proto.RegisterType((*CellConfigReport)(nil), "interface.e2.CellConfigReport")
	proto.RegisterType((*UEAdmissionRequest)(nil), "interface.e2.UEAdmissionRequest")
	proto.RegisterType((*UEAdmissionResponse)(nil), "interface.e2.UEAdmissionResponse")
	proto.RegisterType((*UEAdmissionStatus)(nil), "interface.e2.UEAdmissionStatus")
	proto.RegisterType((*UEContextUpdate)(nil), "interface.e2.UEContextUpdate")
	proto.RegisterType((*UEReconfigInd)(nil), "interface.e2.UEReconfigInd")
	proto.RegisterType((*UEReleaseInd)(nil), "interface.e2.UEReleaseInd")
	proto.RegisterType((*UEAMBR)(nil), "interface.e2.UEAMBR")
	proto.RegisterType((*ERABParamsItem)(nil), "interface.e2.ERABParamsItem")
	proto.RegisterType((*ERABResponseItem)(nil), "interface.e2.ERABResponseItem")
	proto.RegisterType((*BearerAdmissionRequest)(nil), "interface.e2.BearerAdmissionRequest")
	proto.RegisterType((*BearerAdmissionResponse)(nil), "interface.e2.BearerAdmissionResponse")
	proto.RegisterType((*BearerAdmissionStatus)(nil), "interface.e2.BearerAdmissionStatus")
	proto.RegisterType((*BearerReleaseInd)(nil), "interface.e2.BearerReleaseInd")
	proto.RegisterType((*HORequest)(nil), "interface.e2.HORequest")
	proto.RegisterType((*HOFailure)(nil), "interface.e2.HOFailure")
	proto.RegisterType((*HOComplete)(nil), "interface.e2.HOComplete")
	proto.RegisterType((*HOCause)(nil), "interface.e2.HOCause")
	proto.RegisterType((*MeasCell)(nil), "interface.e2.MeasCell")
	proto.RegisterType((*MeasObject)(nil), "interface.e2.MeasObject")
	proto.RegisterType((*ReportParamChoice)(nil), "interface.e2.ReportParamChoice")
	proto.RegisterType((*ThresholdEUTRAChoice)(nil), "interface.e2.ThresholdEUTRAChoice")
	proto.RegisterType((*ThreasholdEUTRA)(nil), "interface.e2.ThreasholdEUTRA")
	proto.RegisterType((*PerParam)(nil), "interface.e2.PerParam")
	proto.RegisterType((*A1Param)(nil), "interface.e2.A1Param")
	proto.RegisterType((*A2Param)(nil), "interface.e2.A2Param")
	proto.RegisterType((*A3Param)(nil), "interface.e2.A3Param")
	proto.RegisterType((*A4Param)(nil), "interface.e2.A4Param")
	proto.RegisterType((*A5Param)(nil), "interface.e2.A5Param")
	proto.RegisterType((*A6Param)(nil), "interface.e2.A6Param")
	proto.RegisterType((*ReportParam)(nil), "interface.e2.ReportParam")
	proto.RegisterType((*ReportConfig)(nil), "interface.e2.ReportConfig")
	proto.RegisterType((*AddMeasId)(nil), "interface.e2.AddMeasId")
	proto.RegisterType((*DelMeasId)(nil), "interface.e2.DelMeasId")
	proto.RegisterType((*MeasIdActionChoice)(nil), "interface.e2.MeasIdActionChoice")
	proto.RegisterType((*MeasIdAction)(nil), "interface.e2.MeasIdAction")
	proto.RegisterType((*MeasID)(nil), "interface.e2.MeasID")
	proto.RegisterType((*RRCMeasConfig)(nil), "interface.e2.RRCMeasConfig")
	proto.RegisterType((*PCIARFCN)(nil), "interface.e2.PCIARFCN")
	proto.RegisterType((*RXSigReport)(nil), "interface.e2.RXSigReport")
	proto.RegisterType((*RxSigMeasReport)(nil), "interface.e2.RxSigMeasReport")
	proto.RegisterType((*L2ReportInterval)(nil), "interface.e2.L2ReportInterval")
	proto.RegisterType((*L2MeasConfig)(nil), "interface.e2.L2MeasConfig")
	proto.RegisterType((*RadioRepPerServCell)(nil), "interface.e2.RadioRepPerServCell")
	proto.RegisterType((*RadioMeasReportPerUE)(nil), "interface.e2.RadioMeasReportPerUE")
	proto.RegisterType((*RadioMeasReportPerCell)(nil), "interface.e2.RadioMeasReportPerCell")
	proto.RegisterType((*PRBUsage)(nil), "interface.e2.PRBUsage")
	proto.RegisterType((*SchedMeasRepPerServCell)(nil), "interface.e2.SchedMeasRepPerServCell")
	proto.RegisterType((*SchedMeasReportPerUE)(nil), "interface.e2.SchedMeasReportPerUE")
	proto.RegisterType((*SchedMeasReportPerCell)(nil), "interface.e2.SchedMeasReportPerCell")
	proto.RegisterType((*PDCPMeasReportPerUe)(nil), "interface.e2.PDCPMeasReportPerUe")
	proto.RegisterType((*RRMConfig)(nil), "interface.e2.RRMConfig")
	proto.RegisterType((*RRMConfigStatus)(nil), "interface.e2.RRMConfigStatus")
	proto.RegisterType((*CACap)(nil), "interface.e2.CACap")
	proto.RegisterType((*DCCap)(nil), "interface.e2.DCCap")
	proto.RegisterType((*UECapabilityEnquiry)(nil), "interface.e2.UECapabilityEnquiry")
	proto.RegisterType((*UECapabilityInfo)(nil), "interface.e2.UECapabilityInfo")
	proto.RegisterType((*PropScell)(nil), "interface.e2.PropScell")
	proto.RegisterType((*ScellAdd)(nil), "interface.e2.ScellAdd")
	proto.RegisterType((*ScellAddStatus)(nil), "interface.e2.ScellAddStatus")
	proto.RegisterType((*ScellDelete)(nil), "interface.e2.ScellDelete")
	proto.RegisterType((*SeNBAdd)(nil), "interface.e2.SeNBAdd")
	proto.RegisterType((*SeNBAddStatus)(nil), "interface.e2.SeNBAddStatus")
	proto.RegisterType((*SeNBDelete)(nil), "interface.e2.SeNBDelete")
	proto.RegisterType((*TrafficSplitPercentage)(nil), "interface.e2.TrafficSplitPercentage")
	proto.RegisterType((*TrafficSplitConfig)(nil), "interface.e2.TrafficSplitConfig")
}

func init() { proto.RegisterFile("api/e2/e2-interface.proto", fileDescriptor_310687c643405aa4) }

var fileDescriptor_310687c643405aa4 = []byte{
	// 5311 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x7c, 0xdb, 0x6f, 0x23, 0xc9,
	0x75, 0x37, 0x9b, 0x94, 0x44, 0xf1, 0x50, 0x94, 0x7a, 0x4a, 0x1a, 0x89, 0x73, 0x59, 0xed, 0x6c,
	0xef, 0x05, 0x6b, 0xd9, 0xdf, 0x5a, 0xe2, 0x48, 0x9a, 0xf9, 0xd6, 0xf1, 0xc6, 0x2d, 0xb2, 0x25,
	0xd2, 0xa6, 0x44, 0x4e, 0x35, 0x7b, 0x3d, 0x93, 0xcb, 0x12, 0x2d, 0xb2, 0x67, 0xc4, 0x6c, 0xf3,
	0x32, 0xdd, 0xcd, 0xf1, 0x0e, 0x90, 0x87, 0x18, 0x81, 0x91, 0x04, 0x30, 0x72, 0x05, 0xfc, 0x92,
	0x3c, 0x24, 0x40, 0x90, 0x3c, 0xe4, 0x21, 0x41, 0x90, 0x97, 0xc0, 0x09, 0xfc, 0x94, 0x0b, 0xf2,
	0xe4, 0xa7, 0x20, 0xc9, 0x4b, 0x0c, 0xfb, 0x25, 0xff, 0x42, 0x10, 0x20, 0x08, 0xea, 0xd2, 0xf7,
	0xa2, 0x46, 0x5a, 0xae, 0x37, 0x79, 0x1a, 0xd6, 0x39, 0xbf, 0x73, 0xea, 0xd4, 0xa9, 0x53, 0xa7,
	0x4e, 0x55, 0xd7, 0x08, 0x6e, 0x99, 0x93, 0xc1, 0x97, 0xad, 0xca, 0x97, 0xad, 0xca, 0xff, 0x1b,
	0x8c, 0x3c, 0xcb, 0x79, 0x6a, 0xf6, 0xac, 0xf7, 0x26, 0xce, 0xd8, 0x1b, 0xa3, 0x95, 0x90, 0x60,
	0x55, 0x94, 0xbf, 0xcb, 0x81, 0xdc, 0xb1, 0x6c, 0x6b, 0x68, 0x79, 0xce, 0xcb, 0x53, 0xcb, 0x75,
	0xcd, 0x67, 0x16, 0xfa, 0x0a, 0x14, 0x87, 0xec, 0x67, 0xe7, 0xe5, 0xc4, 0x2a, 0x4b, 0xf7, 0xa4,
	0x77, 0x57, 0x2b, 0xb7, 0xde, 0x8b, 0x0a, 0xbe, 0x77, 0x1a, 0x02, 0x70, 0x14, 0x8d, 0x1e, 0xc3,
	0x86, 0x63, 0xf6, 0x07, 0xe3, 0x53, 0xcb, 0x74, 0xb1, 0x35, 0x19, 0x3b, 0x5e, 0xdb, 0x72, 0x0c,
	0xad, 0x9c, 0xbd, 0x27, 0xbd, 0x5b, 0xac, 0x28, 0x71, 0x2d, 0x58, 0x80, 0xac, 0x67, 0xb0, 0x50,
	0x03, 0xfa, 0x08, 0x36, 0xd3, 0xf4, 0xaa, 0x65, 0xdb, 0xe5, 0x1c, 0xd5, 0xfd, 0xd6, 0xab, 0x74,
	0x13, 0x6c, 0x3d, 0x83, 0x67, 0x68, 0x21, 0xfa, 0xdd, 0xde, 0x85, 0xd5, 0x4f, 0xeb, 0x5f, 0x10,
	0xe9, 0xd7, 0x85, 0x58, 0xa2, 0x5f, 0xac, 0x05, 0x19, 0xb0, 0x3e, 0xa9, 0x55, 0xdb, 0xf1, 0x61,
	0x59, 0xe5, 0x45, 0xaa, 0xfc, 0x8d, 0xb8, 0xf2, 0x76, 0x1a, 0x58, 0xcf, 0x60, 0x91, 0xfc, 0x51,
	0x0e, 0x24, 0x57, 0xf9, 0x76, 0x1e, 0x4a, 0xd5, 0xf1, 0xc8, 0x73, 0xc6, 0xb6, 0x31, 0xe9, 0x9b,
	0xde, 0x9c, 0x93, 0xd8, 0x04, 0xb9, 0x67, 0xd9, 0x76, 0x75, 0x3c, 0x7a, 0x3a, 0x78, 0xc6, 0x3a,
	0xe3, 0x13, 0xb8, 0x1d, 0xd7, 0x50, 0x4d, 0xa0, 0xea, 0x19, 0x9c, 0x92, 0x44, 0x0d, 0x58, 0x73,
	0xf0, 0x29, 0x23, 0xe9, 0x9e, 0xe9, 0x4d, 0x5d, 0x3e, 0x63, 0xaf, 0x25, 0x66, 0x2c, 0x0e, 0xaa,
	0x67, 0x70, 0x52, 0x0e, 0x61, 0x40, 0x53, 0x4d, 0xed, 0x0f, 0x07, 0xae, 0x3b, 0x18, 0x8f, 0xb0,
	0xf5, 0x7c, 0x6a, 0xb9, 0x1e, 0x9f, 0x9f, 0x7b, 0x71, 0x6d, 0x46, 0x0a, 0x57, 0xcf, 0x60, 0x81,
	0x34, 0x6a, 0xc1, 0x8d, 0x08, 0x95, 0x1b, 0xc8, 0x66, 0xe5, 0xf5, 0x99, 0x2a, 0x03, 0x13, 0xd3,
	0xb2, 0x64, 0xbc, 0x53, 0x8d, 0xcc, 0x86, 0xf5, 0x89, 0xc7, 0x66, 0xa3, 0xbc, 0x24, 0x1a, 0xaf,
	0x11, 0x07, 0x91, 0xf1, 0x26, 0xe4, 0x48, 0x4c, 0x9e, 0x5b, 0xa6, 0x63, 0x39, 0xa9, 0x31, 0xe7,
	0x45, 0x31, 0x79, 0x24, 0xc4, 0x92, 0x98, 0x14, 0x6b, 0x41, 0x3f, 0x0f, 0x37, 0x13, 0x1c, 0x3e,
	0xfe, 0x65, 0xaa, 0xfe, 0xcd, 0x4b, 0xd5, 0x07, 0x3e, 0x10, 0xeb, 0x40, 0xef, 0x03, 0x5c, 0xb4,
	0xaa, 0xe3, 0xe1, 0xc4, 0xb6, 0x3c, 0xab, 0x5c, 0xa0, 0x1a, 0xcb, 0x71, 0x8d, 0xf5, 0x80, 0x5f,
	0xcf, 0xe0, 0x08, 0x1a, 0x3d, 0x80, 0xc2, 0x45, 0xeb, 0xd8, 0x1c, 0xd8, 0x53, 0xc7, 0x2a, 0x03,
	0x15, 0xdd, 0x4a, 0x8a, 0x72, 0x76, 0x3d, 0x83, 0x43, 0x2c, 0xda, 0x83, 0xfc, 0x45, 0xab, 0x6a,
	0x4e, 0x5d, 0xab, 0x5c, 0xa4, 0x62, 0x37, 0x53, 0x3d, 0x12, 0x66, 0x3d, 0x83, 0x7d, 0x1c, 0xfa,
	0x1a, 0xac, 0x4c, 0x35, 0x6c, 0xd9, 0x96, 0xe9, 0x5a, 0x8d, 0x51, 0xbf, 0xbc, 0x42, 0xe5, 0x6e,
	0x27, 0x27, 0x2b, 0x44, 0xd4, 0x33, 0x38, 0x26, 0xc1, 0xd6, 0xe0, 0x0f, 0x73, 0xb0, 0xc6, 0xd7,
	0x20, 0xb6, 0xdc, 0xc9, 0x78, 0xe4, 0xce, 0xb9, 0x0a, 0x5b, 0x70, 0x23, 0xba, 0x96, 0xd8, 0xbc,
	0x67, 0x45, 0x81, 0x59, 0x4d, 0xc2, 0x48, 0x60, 0xa6, 0x64, 0x89, 0x53, 0x83, 0x05, 0xc5, 0x97,
	0xe0, 0xd6, 0x8c, 0x25, 0x48, 0x9c, 0x1a, 0x60, 0x49, 0xea, 0x8a, 0x2d, 0x1c, 0x36, 0x3a, 0x71,
	0xea, 0x32, 0xd2, 0x40, 0x92, 0xba, 0x04, 0xf2, 0xc8, 0x84, 0xad, 0x54, 0x5c, 0x72, 0xd5, 0x6c,
	0xc1, 0xbc, 0xfd, 0x8a, 0xf0, 0x0e, 0xd4, 0xcf, 0xd2, 0xc3, 0xe2, 0x28, 0xbe, 0x66, 0x52, 0x71,
	0x14, 0xfa, 0x2c, 0xc4, 0xb2, 0x29, 0x6d, 0x42, 0x89, 0xcf, 0x4e, 0xdd, 0x32, 0xfb, 0x96, 0x33,
	0xd7, 0x7c, 0x2a, 0xff, 0xb6, 0x01, 0xab, 0x9c, 0xd9, 0x36, 0x5f, 0xda, 0x63, 0xb3, 0x2f, 0x9e,
	0x62, 0x69, 0x8e, 0x29, 0xfe, 0x6c, 0x33, 0xb7, 0x38, 0xdd, 0xe6, 0xe6, 0x4a, 0xb7, 0x33, 0x62,
	0x69, 0x61, 0xce, 0x58, 0xfa, 0xbf, 0x9c, 0xc5, 0xab, 0x50, 0x22, 0xe9, 0xa2, 0x47, 0x5d, 0x4b,
	0x32, 0x0c, 0x0b, 0xc4, 0x3b, 0xe9, 0x0c, 0x13, 0x40, 0xea, 0x19, 0x1c, 0x97, 0x49, 0x65, 0xa9,
	0xe5, 0xeb, 0x66, 0xa9, 0x4b, 0x36, 0x93, 0xc2, 0x67, 0xb2, 0x99, 0x5c, 0xb2, 0x9c, 0xe1, 0x33,
	0x5a, 0xce, 0x33, 0xf7, 0xab, 0xe2, 0x67, 0xb0, 0x5f, 0x35, 0x41, 0x66, 0x8c, 0xd4, 0x5e, 0xb0,
	0x2d, 0xd2, 0x1b, 0xf3, 0x74, 0x4a, 0x32, 0x9e, 0x79, 0x4a, 0x57, 0xcf, 0x3c, 0xf1, 0xad, 0x6f,
	0xf5, 0x1a, 0x5b, 0x5f, 0x7c, 0xbf, 0x5d, 0xbb, 0xd6, 0x7e, 0x1b, 0xd9, 0x36, 0xe5, 0x2b, 0x6e,
	0x9b, 0x55, 0x28, 0x39, 0xb8, 0x4a, 0xca, 0x51, 0xbe, 0xa3, 0xdc, 0x10, 0x45, 0x35, 0x8e, 0x42,
	0x48, 0x54, 0xc7, 0x64, 0x68, 0x6d, 0xf8, 0x89, 0x3e, 0x78, 0x16, 0x56, 0xb5, 0x65, 0x24, 0xac,
	0x0d, 0xe3, 0x20, 0x5a, 0x1b, 0xc6, 0x49, 0x64, 0x81, 0xd8, 0x95, 0x88, 0x39, 0xeb, 0xa2, 0x05,
	0xd2, 0xac, 0xc4, 0xac, 0x89, 0x49, 0xa0, 0x0f, 0x61, 0x5d, 0x70, 0xf2, 0x28, 0x6f, 0x5c, 0xe3,
	0xe8, 0x22, 0x52, 0x70, 0xc9, 0xc9, 0xe5, 0xe6, 0x67, 0x72, 0x72, 0x79, 0x0c, 0x1b, 0xe9, 0x33,
	0x87, 0xa1, 0x95, 0x37, 0x45, 0x86, 0xeb, 0x02, 0x24, 0x39, 0x73, 0x89, 0x34, 0x5c, 0x72, 0x26,
	0xda, 0xfa, 0x69, 0x9e, 0x89, 0xca, 0xf3, 0x9d, 0x89, 0xe2, 0x85, 0xce, 0xad, 0x6b, 0x14, 0x3a,
	0x82, 0xa3, 0xca, 0xed, 0x4f, 0x79, 0x54, 0xa1, 0xfb, 0x5c, 0xd5, 0x9c, 0x98, 0xe7, 0x03, 0x7b,
	0xe0, 0xbd, 0xd4, 0x46, 0xcf, 0xa7, 0x03, 0xe7, 0x65, 0xf9, 0x8e, 0x78, 0x9f, 0x4b, 0x01, 0xd9,
	0x3e, 0x97, 0x22, 0x93, 0x24, 0x15, 0x25, 0x37, 0x46, 0x4f, 0xc7, 0xe5, 0xbb, 0xa2, 0x24, 0x65,
	0x24, 0x50, 0x24, 0x49, 0x25, 0x25, 0xd1, 0x3e, 0x2c, 0xbb, 0x64, 0xd7, 0x57, 0xfb, 0xfd, 0xf2,
	0x6b, 0x54, 0xcb, 0x66, 0x72, 0x46, 0x19, 0xb7, 0x9e, 0xc1, 0x01, 0x12, 0x1d, 0xc3, 0xaa, 0xff,
	0x9b, 0x3b, 0x69, 0x9b, 0xca, 0xde, 0x15, 0xcb, 0x06, 0x3e, 0x4a, 0x48, 0xa1, 0xaf, 0x42, 0x91,
	0x52, 0x6a, 0x16, 0xcd, 0x58, 0xaf, 0x53, 0x25, 0xb7, 0x04, 0x4a, 0x18, 0xa0, 0x9e, 0xc1, 0x51,
	0x3c, 0xc9, 0x59, 0xae, 0x75, 0x76, 0x44, 0x6c, 0xbf, 0x27, 0xca, 0x59, 0x3a, 0x63, 0x92, 0x9c,
	0xc5, 0x71, 0x24, 0x67, 0xf1, 0x9f, 0xdc, 0xf0, 0x37, 0x44, 0x39, 0x4b, 0x8f, 0x42, 0x48, 0xce,
	0x8a, 0xc9, 0x90, 0x3c, 0x4b, 0x08, 0xdc, 0x6a, 0x45, 0x94, 0x67, 0xf5, 0x80, 0x4f, 0xf2, 0x6c,
	0x88, 0x26, 0x15, 0x95, 0xe7, 0x98, 0x4f, 0x9f, 0x0e, 0x7a, 0xfa, 0xc4, 0x1e, 0x78, 0x3c, 0x44,
	0xdf, 0x14, 0x55, 0x54, 0x9d, 0x14, 0x8e, 0x54, 0x54, 0x69, 0x69, 0x56, 0xaa, 0xbe, 0x80, 0xbc,
	0x7f, 0x7f, 0x73, 0x1f, 0x96, 0x2e, 0x68, 0xb9, 0xca, 0x2b, 0xc9, 0x3b, 0xc2, 0xfa, 0x94, 0x55,
	0xb4, 0x98, 0x43, 0xd1, 0x21, 0xe4, 0x27, 0xac, 0x28, 0xe5, 0xf5, 0xe2, 0x5d, 0xa1, 0x14, 0x2f,
	0x5c, 0xb1, 0x0f, 0x56, 0x0c, 0x28, 0xe9, 0x96, 0xf3, 0x62, 0xd0, 0xb3, 0xb0, 0xe5, 0x4e, 0x6d,
	0x0f, 0x6d, 0x03, 0x38, 0xf4, 0x57, 0x75, 0xdc, 0x67, 0x15, 0xf2, 0x22, 0x8e, 0x50, 0xd0, 0x5b,
	0x50, 0x62, 0x2d, 0xae, 0x91, 0x76, 0x57, 0xc0, 0x71, 0xa2, 0x52, 0x81, 0x05, 0xad, 0x7a, 0xd2,
	0x40, 0x9b, 0xb0, 0x34, 0xb1, 0x87, 0xa3, 0x46, 0x9f, 0x6a, 0x2a, 0x60, 0xde, 0x42, 0x08, 0x16,
	0xac, 0xde, 0xa0, 0xcf, 0x85, 0xe9, 0x6f, 0xc5, 0x84, 0x42, 0xd5, 0x1c, 0xf5, 0x69, 0xc4, 0x20,
	0x19, 0x72, 0x93, 0xde, 0x80, 0x4a, 0x95, 0x30, 0xf9, 0x89, 0x6e, 0xc3, 0xb2, 0x65, 0x3a, 0x4f,
	0x7b, 0xa3, 0x9a, 0xcd, 0xc5, 0x82, 0x36, 0x7a, 0x87, 0xa8, 0x7b, 0x36, 0xe0, 0xa5, 0x2d, 0x8a,
	0x0f, 0x9d, 0x18, 0x82, 0x29, 0x5f, 0xf9, 0x0a, 0xdc, 0x48, 0x15, 0xe2, 0x81, 0xb0, 0xf4, 0x0a,
	0xe1, 0x7f, 0x58, 0x00, 0x39, 0x59, 0x76, 0x5f, 0x55, 0xd8, 0x1f, 0x4f, 0x36, 0x1c, 0xcf, 0x03,
	0x80, 0x9e, 0x3f, 0x5c, 0xb7, 0x9c, 0xbb, 0x97, 0x4b, 0x67, 0xb9, 0xc0, 0x1d, 0x38, 0x02, 0x8d,
	0x39, 0x62, 0x21, 0xe1, 0x88, 0x80, 0x67, 0xd8, 0xb4, 0x7a, 0x0e, 0x78, 0x86, 0x8d, 0xee, 0x41,
	0xd1, 0x39, 0x77, 0xdb, 0x96, 0xd3, 0xf1, 0x06, 0x35, 0x9b, 0x56, 0xc3, 0x25, 0x1c, 0x25, 0xc5,
	0x10, 0x86, 0x4d, 0xcb, 0xdc, 0x28, 0xc2, 0xb0, 0x91, 0x02, 0x2b, 0xa3, 0xe9, 0xb0, 0xf3, 0x89,
	0x3a, 0xf2, 0xac, 0xd1, 0xc8, 0xa4, 0x55, 0x6c, 0x09, 0xc7, 0x68, 0x24, 0x82, 0xfa, 0xd3, 0x89,
	0x6d, 0x7d, 0x72, 0x4a, 0x22, 0xa8, 0x40, 0xad, 0x88, 0x50, 0xd0, 0x7b, 0x80, 0x86, 0xe6, 0x27,
	0x67, 0xd3, 0x61, 0x75, 0x3c, 0x1a, 0x59, 0x3d, 0xcf, 0xea, 0x1b, 0x96, 0x4b, 0x4b, 0xcc, 0x12,
	0x16, 0x70, 0xd0, 0x21, 0x6c, 0x26, 0xa8, 0xac, 0x80, 0x63, 0x55, 0x63, 0x09, 0xcf, 0xe0, 0x86,
	0x72, 0x86, 0xe5, 0xd2, 0x9d, 0x2d, 0x18, 0xfa, 0x4a, 0x54, 0x2e, 0xc9, 0x9d, 0x25, 0x67, 0xd8,
	0xb4, 0x0c, 0x9c, 0x21, 0x67, 0xd8, 0xe8, 0x5d, 0x58, 0xeb, 0xdb, 0x4f, 0x19, 0x51, 0x1b, 0x99,
	0xe7, 0x36, 0x2b, 0xff, 0x0a, 0x38, 0x49, 0x56, 0x7e, 0x5f, 0x02, 0x94, 0x3e, 0x70, 0xa1, 0x0d,
	0x58, 0xec, 0x39, 0x23, 0x6f, 0xc0, 0xd7, 0x0a, 0x6b, 0x04, 0x11, 0x96, 0x7d, 0x45, 0x84, 0x9d,
	0xc0, 0x0d, 0xd3, 0xd7, 0xa8, 0xb9, 0x1e, 0x2b, 0x06, 0x73, 0xa2, 0x13, 0xae, 0xda, 0x1f, 0xfa,
	0x00, 0x9c, 0x96, 0x51, 0xfe, 0x54, 0x82, 0x75, 0xc1, 0xc9, 0x6d, 0x4e, 0xf3, 0x30, 0x6c, 0x44,
	0xbb, 0x0a, 0x8e, 0x16, 0xcc, 0xc2, 0xc4, 0xe6, 0xa7, 0x4f, 0x7b, 0x3d, 0xcb, 0x75, 0x5b, 0x0e,
	0xaf, 0x8d, 0xb1, 0x50, 0x56, 0xf9, 0x23, 0x09, 0x6e, 0xa4, 0x8e, 0x83, 0x73, 0xda, 0x79, 0x06,
	0x28, 0xda, 0x57, 0xe4, 0xc2, 0xf3, 0xd5, 0x56, 0x0a, 0x24, 0x89, 0x37, 0xd7, 0x12, 0x67, 0xcc,
	0x39, 0x2d, 0xbc, 0x07, 0xc5, 0xe1, 0xd0, 0x32, 0x2c, 0x7d, 0xcf, 0x9c, 0x34, 0xfa, 0xd4, 0xb4,
	0x02, 0x8e, 0x92, 0x08, 0xc2, 0x1a, 0x9d, 0x07, 0x08, 0x96, 0x24, 0xa2, 0x24, 0x92, 0x7f, 0x07,
	0x43, 0x77, 0xc0, 0x73, 0x04, 0xfd, 0xad, 0xfc, 0xa5, 0x04, 0xa5, 0xd8, 0x21, 0x96, 0x64, 0x13,
	0x6a, 0x5a, 0xcb, 0xf6, 0xf3, 0x77, 0xd0, 0xbe, 0xb2, 0xb5, 0xbe, 0x8e, 0x33, 0xeb, 0x5b, 0xdc,
	0xd4, 0xa0, 0x8d, 0x54, 0xb2, 0x97, 0xb0, 0xee, 0x58, 0xb8, 0x2e, 0x50, 0x37, 0x27, 0x8f, 0x20,
	0x51, 0x08, 0x8e, 0x4b, 0x28, 0xdf, 0x95, 0x60, 0x25, 0x7a, 0x6a, 0x9e, 0xd3, 0xb7, 0x1f, 0xc0,
	0x8a, 0xc3, 0x74, 0x45, 0xd7, 0xcf, 0xed, 0xa4, 0x41, 0x21, 0x02, 0xc7, 0xf0, 0xca, 0x43, 0x58,
	0x32, 0x34, 0xf5, 0xf4, 0x08, 0x93, 0x9d, 0xcf, 0x1c, 0x9e, 0x3b, 0x35, 0xdb, 0xdf, 0xf9, 0x58,
	0xcb, 0xa7, 0x1b, 0xfe, 0x26, 0xc6, 0x5b, 0xca, 0xaf, 0x66, 0x61, 0x55, 0xc3, 0xea, 0x51, 0xdb,
	0x74, 0xcc, 0xa1, 0xdb, 0xf0, 0xac, 0x21, 0x5a, 0x85, 0xec, 0xc0, 0x77, 0x7c, 0x76, 0xd0, 0x47,
	0xff, 0x1f, 0x0a, 0xfd, 0x81, 0x63, 0xf5, 0xbc, 0xc1, 0x78, 0x44, 0xa5, 0x53, 0xae, 0x22, 0x0a,
	0x6a, 0x3e, 0x04, 0x87, 0x68, 0xb4, 0x03, 0x0b, 0xde, 0xcb, 0x89, 0x3f, 0x9e, 0xcd, 0xb4, 0x14,
	0xbd, 0xee, 0xa2, 0x18, 0xb2, 0x55, 0x3d, 0xef, 0x0d, 0x78, 0xd4, 0x90, 0x9f, 0x84, 0x62, 0x3a,
	0x13, 0x1a, 0x2c, 0x25, 0x4c, 0x7e, 0x12, 0x2f, 0x3f, 0xa3, 0x83, 0x5b, 0x62, 0x5e, 0xa6, 0x0d,
	0x4e, 0xe5, 0x3b, 0x07, 0xa3, 0x1a, 0x94, 0xca, 0x1c, 0xb1, 0xcc, 0xa8, 0x43, 0x1f, 0xcb, 0xdc,
	0x50, 0x08, 0xa8, 0x86, 0xad, 0x7c, 0x04, 0x32, 0xb1, 0xc6, 0x5f, 0xe1, 0x42, 0x37, 0xbc, 0x0f,
	0xcb, 0x7d, 0xab, 0x37, 0x70, 0x43, 0x2f, 0xbc, 0x6a, 0x5d, 0x06, 0x78, 0xe5, 0x3f, 0x24, 0xd8,
	0x14, 0x5f, 0x8c, 0xcc, 0x19, 0x38, 0x5f, 0x82, 0xa5, 0xa9, 0xa5, 0x0e, 0xcf, 0x1d, 0x5e, 0x83,
	0x6c, 0xa4, 0x2e, 0xad, 0x4e, 0x8f, 0x30, 0xe6, 0x18, 0xbe, 0x8d, 0x6a, 0x8e, 0x79, 0xee, 0x36,
	0x07, 0xfc, 0x0b, 0x08, 0xdb, 0x46, 0x03, 0x1a, 0xfa, 0x00, 0x8a, 0x16, 0x69, 0xb0, 0x80, 0x28,
	0x2f, 0xd2, 0x02, 0xe1, 0x6e, 0x7a, 0xe6, 0xc2, 0x80, 0xc1, 0x51, 0x01, 0xe5, 0x07, 0x12, 0x6c,
	0xcd, 0xb8, 0xa2, 0x99, 0x73, 0xac, 0x49, 0xeb, 0x73, 0x02, 0xeb, 0x8f, 0x60, 0x85, 0x18, 0x13,
	0xb9, 0x1f, 0xcc, 0xa5, 0xcf, 0x38, 0xc9, 0xa9, 0xc6, 0x31, 0x19, 0xe5, 0xaf, 0x25, 0xb8, 0x29,
	0xbc, 0x03, 0xfa, 0x1c, 0xec, 0xff, 0x00, 0x80, 0xd8, 0xc2, 0xd3, 0xff, 0xd5, 0xac, 0x8f, 0x48,
	0x28, 0xbf, 0x29, 0x81, 0x9c, 0xbc, 0x67, 0xfa, 0x1c, 0xcc, 0x2e, 0x43, 0x9e, 0x18, 0xd1, 0xe8,
	0x33, 0x9b, 0x0b, 0xd8, 0x6f, 0x2a, 0x53, 0x28, 0x04, 0x17, 0x56, 0x33, 0x0c, 0x79, 0x17, 0x16,
	0x49, 0x47, 0xfa, 0x25, 0x96, 0x30, 0x80, 0x8f, 0xec, 0x5c, 0x52, 0x70, 0x33, 0x80, 0xe2, 0x92,
	0x6e, 0xfd, 0x1b, 0xae, 0x79, 0xbb, 0x7d, 0x07, 0x56, 0x2f, 0xc6, 0x5c, 0x59, 0x98, 0x9f, 0x0b,
	0x38, 0x41, 0x55, 0x7e, 0x19, 0x20, 0xbc, 0x29, 0x8b, 0xed, 0x40, 0x52, 0x62, 0x07, 0xfa, 0x69,
	0x0c, 0xf9, 0xef, 0x25, 0xc8, 0xf3, 0xfb, 0xb6, 0xcf, 0xcf, 0xd1, 0x64, 0xe6, 0x2f, 0xc6, 0xe1,
	0x2e, 0x5a, 0xc0, 0x7e, 0x93, 0x5e, 0x48, 0x8e, 0x3b, 0xce, 0xe0, 0xd9, 0x33, 0xcb, 0xe1, 0x69,
	0x24, 0x51, 0x10, 0xe2, 0xc7, 0xba, 0x7f, 0xa0, 0xc1, 0x21, 0x56, 0x69, 0xc3, 0x32, 0xbd, 0x5d,
	0x13, 0x9f, 0xc7, 0x2a, 0xb0, 0x41, 0xce, 0x23, 0x8d, 0x51, 0x7f, 0xf0, 0x62, 0xd0, 0x9f, 0x9a,
	0x76, 0xeb, 0xe9, 0x53, 0xd7, 0xf2, 0xf8, 0xb6, 0x26, 0xe4, 0x29, 0x3f, 0x07, 0x40, 0x34, 0xb6,
	0xce, 0x7f, 0xc9, 0xea, 0x79, 0x64, 0x2b, 0xec, 0xdb, 0xc7, 0x8e, 0xf5, 0xdc, 0xdf, 0x22, 0x59,
	0x0b, 0xed, 0x43, 0x61, 0xc8, 0xfb, 0x75, 0xcb, 0x59, 0x6a, 0xf0, 0x66, 0xf2, 0x34, 0xcb, 0xd8,
	0x38, 0x04, 0x2a, 0xdf, 0xc9, 0xc1, 0x0d, 0x7e, 0x89, 0x44, 0x12, 0x60, 0xf5, 0x62, 0x3c, 0xe8,
	0x59, 0x68, 0x1f, 0x96, 0x27, 0x96, 0x43, 0x29, 0xfc, 0x8c, 0x96, 0x50, 0xd5, 0xe6, 0xdc, 0x7a,
	0x06, 0x07, 0x48, 0xb4, 0x07, 0x79, 0x73, 0x8f, 0x09, 0x65, 0x45, 0x57, 0x13, 0xea, 0x9e, 0x2f,
	0xe3, 0xe3, 0xa8, 0x48, 0x85, 0x89, 0xe4, 0x84, 0x22, 0x95, 0x50, 0xa4, 0x12, 0x8a, 0xdc, 0x67,
	0x22, 0x0b, 0x42, 0x91, 0xfb, 0xa1, 0xc8, 0xfd, 0x50, 0x64, 0x9f, 0x89, 0x2c, 0x0a, 0x45, 0xf6,
	0x43, 0x91, 0xfd, 0x50, 0xe4, 0x80, 0x89, 0x2c, 0x09, 0x45, 0x0e, 0x42, 0x91, 0x83, 0x50, 0xe4,
	0x90, 0x89, 0xe4, 0x85, 0x22, 0x87, 0xa1, 0x08, 0xfb, 0x79, 0xb4, 0x0c, 0x4b, 0x3d, 0xea, 0x71,
	0x65, 0x02, 0x1b, 0x9d, 0x0b, 0xc7, 0x72, 0x2f, 0xc6, 0x76, 0x5f, 0x33, 0x3a, 0x58, 0xe5, 0x33,
	0xf1, 0x0e, 0x94, 0x3c, 0x9f, 0x8e, 0x75, 0xdc, 0x66, 0x93, 0x5e, 0xcf, 0xe0, 0x38, 0x39, 0x89,
	0x7b, 0xc4, 0x02, 0x2a, 0x89, 0x7b, 0x14, 0xe9, 0xf1, 0xd7, 0x24, 0x58, 0x23, 0x5d, 0x9a, 0x61,
	0x9f, 0xe8, 0x21, 0xe4, 0x27, 0x8e, 0xe5, 0x5a, 0x23, 0x8f, 0x7f, 0xe5, 0x4b, 0x24, 0xef, 0xb8,
	0x89, 0x6d, 0x8c, 0x7d, 0x38, 0x7a, 0xdf, 0xd7, 0x2b, 0x7e, 0xf3, 0x22, 0x1a, 0x1b, 0xf6, 0x2d,
	0xf9, 0x08, 0x96, 0xfd, 0x78, 0x42, 0x18, 0x64, 0x87, 0x86, 0x63, 0x83, 0x88, 0xbf, 0x30, 0xed,
	0x53, 0x97, 0x9b, 0xf2, 0x8e, 0x38, 0x02, 0x71, 0x02, 0x8d, 0x53, 0xf2, 0xca, 0xd7, 0x21, 0xcf,
	0x43, 0x0f, 0xfd, 0x2c, 0x14, 0xcd, 0xbd, 0xc0, 0x18, 0x1e, 0xdb, 0xaf, 0xa5, 0x6d, 0x8d, 0x38,
	0x05, 0x47, 0x25, 0xa8, 0xae, 0x4a, 0xa8, 0xab, 0x72, 0x6d, 0x5d, 0xa1, 0x84, 0xf2, 0x36, 0xe4,
	0x79, 0xb0, 0x92, 0x6c, 0x6b, 0xde, 0xe7, 0xa9, 0x80, 0x67, 0x5b, 0xbf, 0x4d, 0xbb, 0xdc, 0x0f,
	0xbb, 0xdc, 0xbf, 0x76, 0x97, 0xa1, 0x84, 0xf2, 0x5b, 0x12, 0xe4, 0x79, 0xe8, 0x22, 0x15, 0x56,
	0xcc, 0x83, 0x80, 0xb5, 0x77, 0x35, 0x6d, 0x31, 0x91, 0x84, 0x8a, 0x0a, 0x9f, 0xfb, 0x6b, 0xa8,
	0xa8, 0x50, 0x27, 0x1c, 0x86, 0x4e, 0x38, 0x4c, 0x38, 0x81, 0xb7, 0x95, 0x1f, 0x49, 0x50, 0x8c,
	0xe4, 0x29, 0x74, 0x90, 0x8c, 0xd4, 0xd4, 0xf1, 0x27, 0xc0, 0x46, 0xc3, 0xf4, 0x41, 0x22, 0x4c,
	0x5f, 0x9f, 0x29, 0x15, 0x8f, 0x51, 0xb4, 0x0d, 0x70, 0xf1, 0xd2, 0xf5, 0x2c, 0xc7, 0x72, 0x07,
	0x2e, 0xdf, 0x40, 0x23, 0x14, 0x72, 0x28, 0xf3, 0x06, 0x43, 0xcb, 0x1b, 0x7b, 0x7c, 0xcb, 0x10,
	0x1e, 0xca, 0x3a, 0x83, 0xa1, 0xd5, 0xf1, 0x77, 0x0a, 0x1c, 0x97, 0x50, 0xfe, 0x55, 0x82, 0x15,
	0x66, 0x00, 0xbf, 0x97, 0xff, 0x2a, 0x39, 0x56, 0x05, 0x06, 0xb9, 0x7c, 0x82, 0x6e, 0xcd, 0x34,
	0x19, 0xc7, 0xe0, 0xe8, 0x04, 0xd6, 0xb8, 0xea, 0x47, 0x53, 0x73, 0xe4, 0x0d, 0xbc, 0x97, 0xbc,
	0xf0, 0x4f, 0xce, 0x4f, 0x1c, 0x84, 0x93, 0x52, 0xec, 0xc0, 0x49, 0x14, 0x3f, 0x9a, 0x9a, 0x36,
	0x51, 0x93, 0x9b, 0xed, 0x71, 0x0e, 0xc1, 0x71, 0x09, 0xe5, 0x0b, 0x50, 0x50, 0xfb, 0xf4, 0x53,
	0x48, 0xa3, 0x8f, 0xee, 0x42, 0xc1, 0xf4, 0x1b, 0x65, 0x89, 0x16, 0x5c, 0x21, 0x81, 0x40, 0x6b,
	0x96, 0x1d, 0x42, 0xfb, 0x7e, 0xc3, 0x87, 0x06, 0x04, 0x72, 0xf6, 0x46, 0xec, 0xa7, 0x4a, 0x0f,
	0x6c, 0x3c, 0x67, 0x3e, 0x88, 0xeb, 0x17, 0x7c, 0x08, 0x09, 0x6c, 0xa9, 0x67, 0x22, 0x5d, 0x13,
	0xc1, 0xb0, 0xb7, 0xac, 0x48, 0x30, 0xb0, 0x8c, 0x08, 0x06, 0x58, 0x74, 0x0f, 0xe0, 0x62, 0xec,
	0x8d, 0x3d, 0xd3, 0x79, 0x66, 0xb1, 0x12, 0xb3, 0x40, 0x3f, 0x35, 0x06, 0xb4, 0x48, 0xde, 0xfd,
	0x15, 0x09, 0x56, 0xa2, 0x46, 0xd3, 0x4b, 0xe8, 0x58, 0x28, 0xdf, 0x4d, 0x6f, 0xdb, 0x3e, 0x38,
	0x1a, 0xcb, 0x0f, 0x13, 0xb1, 0x7c, 0x6f, 0xb6, 0x58, 0x22, 0xe1, 0xfe, 0xba, 0x04, 0x4b, 0x94,
	0x5d, 0x23, 0xe5, 0xf1, 0x30, 0xa8, 0x2d, 0x82, 0x0b, 0xe7, 0x18, 0x8d, 0x14, 0x90, 0x4e, 0x24,
	0x2e, 0x1b, 0xfe, 0x05, 0x74, 0x82, 0x8a, 0x2a, 0xb0, 0x64, 0xb2, 0x63, 0x76, 0x4e, 0xf4, 0x15,
	0x32, 0x6a, 0x10, 0xe6, 0x48, 0xe5, 0xbf, 0x24, 0x28, 0xc5, 0xbe, 0x96, 0x5e, 0xf9, 0x6e, 0x38,
	0x28, 0x12, 0xb3, 0x34, 0x2c, 0x78, 0x91, 0xf8, 0x3e, 0x14, 0x43, 0xdb, 0xfd, 0x0b, 0xe2, 0x72,
	0xda, 0x10, 0x06, 0xc0, 0x51, 0x30, 0xfa, 0x9a, 0x1f, 0xe7, 0xcc, 0x12, 0xff, 0x00, 0x73, 0x5b,
	0x14, 0xe7, 0xfc, 0x3a, 0x3b, 0x2e, 0x80, 0xde, 0x83, 0xfc, 0x90, 0x8e, 0xd2, 0x3f, 0x79, 0x6e,
	0x08, 0x5c, 0x50, 0xc3, 0x3e, 0x48, 0x79, 0x08, 0xcb, 0xed, 0x6a, 0x43, 0xc5, 0xc7, 0xd5, 0xb3,
	0xeb, 0xdd, 0xdd, 0x2b, 0xbf, 0x43, 0xf2, 0x61, 0x58, 0x80, 0xa2, 0x0a, 0x2c, 0x4f, 0x7a, 0x03,
	0x95, 0x70, 0x67, 0x54, 0x6c, 0xbc, 0x1f, 0x1c, 0xe0, 0xae, 0x7c, 0x84, 0x42, 0xb0, 0xe0, 0xb8,
	0xce, 0x84, 0x67, 0x3d, 0xfa, 0x9b, 0xd3, 0x9e, 0xf3, 0xaa, 0x99, 0xfe, 0x56, 0x7e, 0x57, 0x82,
	0xb5, 0xc4, 0x27, 0xeb, 0x68, 0x29, 0x9f, 0xbb, 0xfe, 0xe1, 0x4d, 0x85, 0x55, 0x52, 0x11, 0x47,
	0xbe, 0x93, 0xe7, 0x5e, 0x55, 0x89, 0x27, 0x04, 0x94, 0x7f, 0xcf, 0x81, 0xdc, 0xac, 0xc4, 0xab,
	0x04, 0xf4, 0x04, 0x6e, 0x7a, 0x82, 0x6f, 0xd9, 0xfe, 0xdb, 0xa6, 0x37, 0x45, 0x9f, 0xcf, 0xe3,
	0x2a, 0x5c, 0x2c, 0xd6, 0x80, 0x7e, 0x11, 0xb6, 0x3c, 0xf1, 0xb7, 0x6c, 0x9e, 0x7d, 0xaf, 0xa4,
	0x7c, 0x96, 0x0e, 0x6a, 0xb9, 0xe0, 0x63, 0xb6, 0x7f, 0x47, 0x75, 0x45, 0xcb, 0x45, 0x1a, 0xa8,
	0xe5, 0xfa, 0xec, 0xb7, 0xc0, 0x57, 0xb6, 0x5c, 0xac, 0x03, 0x7d, 0x13, 0x36, 0xbc, 0x76, 0xbf,
	0x37, 0x11, 0x3d, 0x05, 0xbe, 0xa2, 0x6e, 0xa1, 0x02, 0xe5, 0x7b, 0x12, 0xac, 0x44, 0x5f, 0x38,
	0xcc, 0x99, 0x41, 0xea, 0xb0, 0x16, 0xaf, 0x20, 0xfd, 0x87, 0xbb, 0xdb, 0x49, 0x13, 0xe3, 0xe6,
	0xe1, 0xa4, 0x98, 0xf2, 0x7d, 0x09, 0xd6, 0xe9, 0x34, 0x62, 0x6b, 0xd2, 0xb6, 0x1c, 0xdd, 0x72,
	0x5e, 0x50, 0x4f, 0x5c, 0xd5, 0xbe, 0x32, 0xe4, 0x7b, 0xcf, 0x07, 0xf5, 0x01, 0x7d, 0x00, 0x99,
	0x7b, 0xb7, 0x84, 0xfd, 0x26, 0x39, 0x03, 0x3a, 0x8c, 0x91, 0xa3, 0xa6, 0xf3, 0x16, 0x7a, 0x0b,
	0x4a, 0x93, 0xa9, 0xdb, 0xbb, 0xd0, 0x07, 0x23, 0xa7, 0xce, 0xae, 0xc8, 0x08, 0x3b, 0x4e, 0x64,
	0xa8, 0x5e, 0x04, 0xb5, 0xe8, 0xa3, 0x22, 0x44, 0xe5, 0xcf, 0x24, 0xd8, 0x10, 0xbd, 0xf7, 0xf8,
	0x34, 0xee, 0x8d, 0x9c, 0xe2, 0x0d, 0xfe, 0x54, 0x9e, 0x69, 0xf4, 0x7d, 0xe2, 0x67, 0xea, 0x37,
	0x04, 0x8f, 0x42, 0xe2, 0xde, 0xc3, 0x42, 0x71, 0xe5, 0x0f, 0x24, 0xd8, 0x9c, 0xb1, 0x64, 0xae,
	0x6a, 0xef, 0x0e, 0xc8, 0xd4, 0x4f, 0x8d, 0x91, 0xf7, 0xb4, 0xfd, 0x2d, 0x27, 0xe2, 0xf7, 0x14,
	0x1d, 0xbd, 0x07, 0x88, 0x7a, 0x8b, 0xd2, 0xc6, 0xdf, 0xb2, 0x9c, 0x60, 0x32, 0x4a, 0x58, 0xc0,
	0x51, 0xbe, 0x0e, 0xcb, 0x6d, 0x7c, 0x64, 0xd0, 0x2f, 0xd5, 0xdb, 0x00, 0x13, 0xe7, 0x9c, 0xfe,
	0xa6, 0xf7, 0xdc, 0xc4, 0xf7, 0x11, 0x4a, 0x94, 0x4f, 0xef, 0xbb, 0x63, 0x7c, 0xc3, 0x56, 0x7e,
	0x90, 0x85, 0xad, 0xe8, 0x1a, 0xfb, 0x94, 0xa1, 0xf5, 0xbc, 0x37, 0xf8, 0xd0, 0xe4, 0x57, 0x05,
	0x05, 0xec, 0x37, 0xe9, 0x46, 0xc2, 0xfb, 0xe2, 0x71, 0x9f, 0xdc, 0x48, 0xf8, 0x38, 0x70, 0x80,
	0xa3, 0xb7, 0xd2, 0x3d, 0x97, 0x7e, 0x58, 0xa5, 0x0b, 0x89, 0x36, 0x48, 0xd9, 0x30, 0x9a, 0x0e,
	0xa9, 0xa5, 0x1d, 0x6f, 0x40, 0xd8, 0x2c, 0xce, 0x12, 0x54, 0x2e, 0x6d, 0xd8, 0xe5, 0xa5, 0x40,
	0xda, 0x48, 0x49, 0xd3, 0xeb, 0xf1, 0x94, 0xb4, 0x61, 0x93, 0x91, 0x38, 0xe6, 0xe8, 0xe3, 0x9a,
	0xbd, 0x57, 0x5e, 0x66, 0x23, 0xe1, 0xcd, 0x90, 0x53, 0x29, 0x17, 0xa2, 0x9c, 0x8a, 0xf2, 0xe7,
	0x12, 0x6c, 0x88, 0x5e, 0x04, 0xcd, 0x19, 0xda, 0x4f, 0xf8, 0x8b, 0x24, 0x71, 0x68, 0xbf, 0x3d,
	0xfb, 0xd5, 0x50, 0x2c, 0xbc, 0x45, 0x2a, 0x94, 0x7f, 0x96, 0x60, 0x73, 0x46, 0x5e, 0x9d, 0x7f,
	0xca, 0x7f, 0x06, 0x4a, 0xfe, 0x54, 0xb6, 0x7b, 0xe1, 0x7f, 0x2d, 0x99, 0x35, 0xef, 0x71, 0x70,
	0x54, 0x9a, 0x7e, 0x6a, 0xe7, 0xb7, 0x32, 0xaf, 0x94, 0xa6, 0x60, 0xe5, 0x37, 0x72, 0xb0, 0x2e,
	0x78, 0xe3, 0x34, 0xe7, 0x4c, 0x44, 0xc6, 0x9a, 0x8b, 0x8f, 0x95, 0x1c, 0x28, 0x4c, 0xcf, 0xfc,
	0x70, 0x6c, 0xf3, 0x70, 0x2d, 0xe1, 0x90, 0x10, 0xe1, 0x1a, 0x2c, 0x5a, 0x43, 0xae, 0xc1, 0x16,
	0xe6, 0xc7, 0x5e, 0xcd, 0xb2, 0xcd, 0x97, 0x35, 0x16, 0xad, 0x25, 0x1c, 0xa1, 0xd0, 0x04, 0xf2,
	0xb1, 0x57, 0x1b, 0xb8, 0x3d, 0xd3, 0xe9, 0x63, 0xd3, 0x23, 0xcb, 0x3b, 0xcf, 0x13, 0x48, 0x82,
	0x4e, 0x73, 0xf0, 0xc7, 0x5e, 0x73, 0xec, 0xba, 0x1c, 0xb8, 0x4c, 0x81, 0x71, 0x62, 0x02, 0x45,
	0x3f, 0xfb, 0x24, 0x51, 0xec, 0x79, 0x81, 0x77, 0xe1, 0x8c, 0xa7, 0xcf, 0x2e, 0x26, 0x53, 0xaf,
	0x66, 0x97, 0x81, 0x82, 0x62, 0xb4, 0x38, 0xc6, 0xb0, 0xcb, 0xc5, 0x24, 0xc6, 0xb0, 0x95, 0xef,
	0xe5, 0xa0, 0x10, 0xbc, 0xf1, 0x9a, 0x73, 0x17, 0x8d, 0xd6, 0xa3, 0xb9, 0x2b, 0xd6, 0xa3, 0x6f,
	0x43, 0x76, 0xa2, 0xd2, 0x49, 0x59, 0x4d, 0xde, 0x9d, 0x3d, 0x6e, 0x54, 0x1b, 0xd5, 0xb6, 0x8a,
	0xb3, 0x13, 0x95, 0x4c, 0x83, 0xeb, 0x99, 0x8e, 0xd7, 0x76, 0xce, 0x6b, 0xfe, 0x2c, 0x45, 0x28,
	0xb4, 0x6c, 0x1e, 0xf5, 0x19, 0x97, 0x4d, 0x52, 0xd0, 0x46, 0x5f, 0x82, 0x1b, 0xee, 0xf4, 0xfc,
	0xd8, 0x31, 0x87, 0xd6, 0xd1, 0xc0, 0x1b, 0x9a, 0xee, 0xc7, 0x35, 0x3f, 0xb1, 0xa4, 0x19, 0x24,
	0x1c, 0x26, 0xbb, 0x86, 0xd5, 0x26, 0xd9, 0x9f, 0x4f, 0x50, 0x48, 0x88, 0xda, 0x11, 0xcc, 0x4c,
	0x84, 0x12, 0xda, 0x61, 0xf8, 0x53, 0x12, 0xb4, 0x05, 0x76, 0xf0, 0x39, 0x49, 0xdb, 0x61, 0xd8,
	0xf4, 0xaa, 0x2e, 0xf1, 0xf8, 0x6e, 0xce, 0xe9, 0x39, 0x84, 0x25, 0xd7, 0xff, 0x46, 0x9f, 0xbb,
	0xc2, 0xb7, 0x40, 0x8e, 0x56, 0xfe, 0x56, 0x82, 0xc5, 0xaa, 0x5a, 0x35, 0xe9, 0x01, 0xe0, 0xdc,
	0x1c, 0xf9, 0x07, 0x46, 0xfa, 0x1b, 0x3d, 0x84, 0x42, 0xcf, 0xec, 0xd9, 0xa6, 0xeb, 0xf6, 0xfd,
	0x6a, 0x37, 0x71, 0x78, 0xa2, 0xb2, 0x55, 0x82, 0xa8, 0xd9, 0x38, 0x04, 0x47, 0x24, 0xa7, 0xb6,
	0xf8, 0xf3, 0x71, 0x28, 0x69, 0x84, 0x92, 0x53, 0xea, 0xc9, 0x9e, 0x33, 0x76, 0xdd, 0xaa, 0xe9,
	0x38, 0x03, 0xcb, 0xa1, 0x49, 0x92, 0x9f, 0x4a, 0xd2, 0x0c, 0xe5, 0x04, 0x16, 0x6b, 0x55, 0x62,
	0xfe, 0x07, 0xb0, 0xd2, 0x77, 0xce, 0x3b, 0x2f, 0x27, 0x16, 0x7d, 0x54, 0xc6, 0x0b, 0xff, 0x44,
	0x9f, 0x14, 0x5a, 0x63, 0x30, 0x1c, 0xc3, 0x2b, 0x3a, 0xac, 0x0b, 0xde, 0x2f, 0xce, 0xf7, 0xad,
	0x4a, 0xf9, 0x13, 0x09, 0xe4, 0xe4, 0x0b, 0xc6, 0x39, 0x3f, 0x7f, 0x7d, 0x01, 0x16, 0x7b, 0x66,
	0xd5, 0x9c, 0xf0, 0x45, 0xb8, 0x2e, 0x70, 0x2a, 0x66, 0x08, 0x02, 0xed, 0xf7, 0x08, 0x74, 0x41,
	0x04, 0xa5, 0xbe, 0xc0, 0x0c, 0x41, 0xb6, 0xa3, 0x42, 0xdb, 0x19, 0x4f, 0xd8, 0xab, 0xb3, 0x4f,
	0x73, 0xf6, 0x7c, 0x08, 0x5b, 0xa9, 0xd9, 0xe1, 0xcf, 0x7f, 0x58, 0x26, 0x9f, 0xc5, 0x46, 0x5f,
	0x81, 0x62, 0xcf, 0x0c, 0x3e, 0xd7, 0x8b, 0xdf, 0xea, 0x54, 0xd5, 0xf0, 0x7b, 0x7e, 0x14, 0x4d,
	0x5f, 0x59, 0x59, 0x66, 0xcf, 0xeb, 0x0c, 0x86, 0xfc, 0x8e, 0xae, 0x80, 0x23, 0x14, 0xe5, 0xdb,
	0x12, 0x2c, 0xfb, 0x2f, 0x38, 0xe7, 0xf4, 0xfc, 0x03, 0x00, 0xfa, 0x6e, 0xd3, 0x25, 0x8e, 0x12,
	0xbf, 0x54, 0x0b, 0x5c, 0x88, 0x23, 0x50, 0xe5, 0x6f, 0x24, 0x58, 0x8d, 0xbf, 0x22, 0x9d, 0xd3,
	0x92, 0x7d, 0x28, 0x30, 0xf5, 0x8d, 0x51, 0x9f, 0x1b, 0x32, 0x6b, 0x82, 0x42, 0x60, 0x24, 0x45,
	0x2c, 0x5c, 0x2b, 0x45, 0x7c, 0x5b, 0x82, 0x62, 0xe4, 0xfd, 0xea, 0xff, 0x86, 0xed, 0x8a, 0x0b,
	0x79, 0xfe, 0x9c, 0x75, 0xf6, 0xb7, 0xc4, 0xa1, 0x76, 0x79, 0xff, 0x0c, 0x40, 0x90, 0xae, 0x76,
	0xf9, 0x2b, 0x49, 0x06, 0x50, 0xbe, 0x23, 0x41, 0x29, 0xf6, 0x88, 0x76, 0xce, 0xa1, 0x47, 0x73,
	0xb4, 0x74, 0x8d, 0x09, 0x78, 0x01, 0x10, 0xbe, 0xc4, 0xfd, 0x1c, 0xc7, 0xff, 0xc7, 0x12, 0x6c,
	0x46, 0x9f, 0xef, 0xb6, 0x2d, 0xa7, 0x67, 0x8d, 0x3c, 0x72, 0x40, 0xb8, 0xea, 0x66, 0xb5, 0x0b,
	0xeb, 0xfc, 0xa9, 0x6f, 0x28, 0x1c, 0x5c, 0x7e, 0x89, 0x58, 0x42, 0x09, 0xc3, 0xe6, 0x57, 0x55,
	0x22, 0x96, 0xf2, 0x17, 0x12, 0xa0, 0xf4, 0x2b, 0xe3, 0x39, 0xe7, 0xea, 0x17, 0x60, 0xd3, 0x13,
	0x0e, 0x9d, 0xc7, 0xec, 0x5b, 0xb3, 0x5f, 0x39, 0x87, 0x58, 0x3c, 0x43, 0xc7, 0xce, 0x3f, 0x2d,
	0x41, 0x31, 0xf2, 0x1f, 0xec, 0xd0, 0x3a, 0xac, 0x19, 0x67, 0xdf, 0x38, 0x6b, 0x7d, 0xf3, 0xac,
	0x7b, 0xaa, 0xe9, 0xba, 0x7a, 0xa2, 0xc9, 0x19, 0xb4, 0x05, 0xeb, 0x55, 0xad, 0xd9, 0xec, 0x56,
	0x5b, 0x67, 0xc7, 0x8d, 0x93, 0x2e, 0xd6, 0x1e, 0x19, 0x9a, 0xde, 0x91, 0x25, 0xb4, 0x09, 0x28,
	0xce, 0x68, 0xb7, 0x70, 0x47, 0xce, 0xa2, 0x32, 0x6c, 0x18, 0x5a, 0x57, 0xad, 0x9d, 0x36, 0x74,
	0xbd, 0xd1, 0x3a, 0x0b, 0x24, 0x72, 0xe8, 0x16, 0xdc, 0x4c, 0x70, 0xf4, 0x76, 0xeb, 0x4c, 0xd7,
	0xe4, 0x05, 0xd2, 0x4b, 0x8c, 0xa5, 0x77, 0xd4, 0x8e, 0xa1, 0xcb, 0x8b, 0xe8, 0x26, 0xdc, 0x30,
	0x34, 0xd2, 0x47, 0x47, 0x7b, 0xdc, 0xe9, 0x1a, 0xed, 0x9a, 0xda, 0xd1, 0xe4, 0x25, 0x6a, 0xaa,
	0xd6, 0xc5, 0x1a, 0xef, 0xbc, 0x71, 0x56, 0x93, 0xf3, 0x08, 0xc1, 0x2a, 0x25, 0x36, 0x35, 0x55,
	0xd7, 0x28, 0x6d, 0x19, 0xdd, 0x85, 0xf2, 0x91, 0xa6, 0x62, 0x0d, 0x0b, 0x2c, 0x2a, 0xa0, 0xd7,
	0xe0, 0x96, 0x80, 0xcb, 0xad, 0x02, 0x74, 0x07, 0xb6, 0x52, 0x6c, 0x6e, 0x59, 0x91, 0x8c, 0x9f,
	0x33, 0xa3, 0x3d, 0xae, 0xa0, 0x55, 0x80, 0x7a, 0x2b, 0xe8, 0xa3, 0xc4, 0xdb, 0xc7, 0x6a, 0xa3,
	0x69, 0x60, 0x4d, 0x5e, 0x45, 0x6b, 0x50, 0xac, 0xb7, 0xba, 0xd5, 0xd6, 0x69, 0xbb, 0xa9, 0x75,
	0x34, 0x79, 0x8d, 0x0c, 0x11, 0x3f, 0xd6, 0x1b, 0x27, 0xdd, 0x53, 0x4d, 0xd5, 0x7d, 0x3f, 0xca,
	0x64, 0x34, 0xcd, 0x0a, 0xa3, 0xb1, 0x51, 0xca, 0x37, 0xc8, 0x68, 0xb0, 0x5a, 0x6b, 0xb4, 0xa2,
	0xd0, 0x6e, 0x5b, 0xc3, 0x5d, 0x43, 0x93, 0x11, 0xda, 0x86, 0xdb, 0x62, 0x2e, 0x99, 0x27, 0x79,
	0x9d, 0x48, 0xeb, 0xd5, 0xba, 0x56, 0x13, 0x49, 0x6f, 0x10, 0x69, 0x31, 0x97, 0x4a, 0xdf, 0x24,
	0xce, 0x20, 0x27, 0x2a, 0x91, 0xf0, 0x26, 0x71, 0x06, 0x99, 0x26, 0xb5, 0xad, 0x1e, 0x35, 0x9a,
	0x8d, 0xce, 0x93, 0x6e, 0xe3, 0xec, 0xb8, 0x25, 0x6f, 0xf1, 0x29, 0x8f, 0xd0, 0xb5, 0xb3, 0x47,
	0x46, 0x03, 0x3f, 0x91, 0xcb, 0xa8, 0x04, 0x05, 0x9d, 0x06, 0x90, 0x5a, 0xab, 0xc9, 0xb7, 0xd0,
	0x06, 0xc8, 0x41, 0xd3, 0x77, 0xf2, 0x6d, 0x24, 0xc3, 0x0a, 0xa3, 0xd6, 0x34, 0xea, 0xad, 0x3b,
	0xc4, 0x9d, 0x18, 0x9f, 0xfa, 0x2e, 0xb9, 0x4b, 0xbd, 0x17, 0xb4, 0x7d, 0xc1, 0xd7, 0xd0, 0x0a,
	0x2c, 0xeb, 0xda, 0xd9, 0x11, 0x55, 0xbe, 0x4d, 0xc2, 0xc5, 0x6f, 0xf9, 0x90, 0xd7, 0xc9, 0x44,
	0x50, 0x22, 0x57, 0x7d, 0x8f, 0x44, 0x6e, 0x07, 0xab, 0xc7, 0xc7, 0x8d, 0x6a, 0x57, 0x6f, 0x37,
	0x1b, 0x1d, 0xbf, 0x93, 0x37, 0x88, 0x36, 0x32, 0x67, 0xaa, 0xa1, 0x6b, 0xb2, 0x42, 0xb4, 0x61,
	0x5c, 0x8d, 0x4d, 0xcd, 0x9b, 0x3b, 0x1f, 0x41, 0x31, 0xf2, 0x94, 0x97, 0x8c, 0x4e, 0x3b, 0xd5,
	0xf0, 0x89, 0x76, 0x56, 0x7d, 0x22, 0x67, 0xd0, 0x0d, 0x28, 0xd5, 0x1b, 0x27, 0xf5, 0x7a, 0xbb,
	0xab, 0x56, 0xab, 0x9a, 0xae, 0xcb, 0x12, 0x41, 0x9c, 0x76, 0xfc, 0x66, 0x96, 0x20, 0x4e, 0x5b,
	0x5d, 0xbd, 0x71, 0x72, 0xa6, 0x36, 0x9b, 0x8d, 0xb3, 0x13, 0x39, 0x87, 0x8a, 0x90, 0x3f, 0x6d,
	0x75, 0x6b, 0x6a, 0x47, 0x95, 0x17, 0x76, 0xbe, 0x04, 0x72, 0x32, 0x35, 0x13, 0x80, 0x6e, 0x30,
	0x05, 0x19, 0xd2, 0xf0, 0x83, 0x4c, 0xda, 0x69, 0x42, 0x29, 0xf6, 0x52, 0x93, 0x38, 0x32, 0x58,
	0x2d, 0xb8, 0x79, 0x2c, 0x67, 0x88, 0xc3, 0x03, 0x0a, 0x0f, 0x50, 0x59, 0xa2, 0x63, 0xf3, 0xa9,
	0xad, 0x4e, 0x5d, 0xc3, 0xba, 0x9c, 0xdd, 0xf9, 0x06, 0xac, 0x44, 0x9f, 0x59, 0x92, 0xd9, 0x0e,
	0x63, 0x5e, 0xad, 0x76, 0x1a, 0x1f, 0x36, 0x3a, 0x64, 0x94, 0x6b, 0x50, 0xf4, 0xe9, 0xa4, 0x0f,
	0x89, 0xc4, 0xb0, 0x4f, 0x08, 0x94, 0x7d, 0x01, 0x4a, 0xb1, 0x97, 0x91, 0x68, 0x09, 0xb2, 0xb5,
	0xa6, 0x9c, 0x21, 0xff, 0x1a, 0xc4, 0x84, 0x65, 0x58, 0x38, 0x6a, 0x75, 0xea, 0x72, 0x76, 0x67,
	0x17, 0x96, 0xfd, 0xe7, 0x90, 0x64, 0x00, 0xe4, 0x77, 0xb7, 0xa6, 0x1d, 0xab, 0x46, 0xb3, 0x23,
	0x67, 0x88, 0x72, 0x4e, 0xa9, 0x35, 0xaa, 0x6a, 0x47, 0xab, 0xc9, 0xd2, 0xce, 0x7f, 0x4a, 0x64,
	0xe0, 0x91, 0x6f, 0xb4, 0x24, 0x6c, 0xfd, 0x60, 0x55, 0xb1, 0x7a, 0xda, 0x6d, 0xe3, 0xee, 0x59,
	0xab, 0x53, 0x27, 0x1e, 0xce, 0x90, 0xf5, 0x9f, 0x64, 0x92, 0x90, 0xa6, 0x0d, 0x59, 0x12, 0xc9,
	0xaa, 0x7b, 0x8c, 0x99, 0x15, 0x32, 0x2b, 0x8c, 0x99, 0x13, 0x32, 0xef, 0x33, 0xe6, 0x82, 0x90,
	0xb9, 0xcf, 0x98, 0x8b, 0x42, 0xe6, 0x01, 0x63, 0x2e, 0x09, 0x99, 0x87, 0x8c, 0x99, 0xdf, 0xf9,
	0x7e, 0x16, 0xca, 0xb3, 0x9e, 0x2f, 0x90, 0xd9, 0x0e, 0x46, 0xd6, 0x3d, 0xd5, 0xbb, 0x7b, 0x95,
	0x5d, 0x16, 0x03, 0x31, 0x6a, 0x65, 0x7f, 0x57, 0x96, 0x52, 0xd4, 0xfd, 0x87, 0xbb, 0x72, 0x36,
	0x45, 0x3d, 0xdc, 0xdf, 0x95, 0x73, 0x64, 0xf9, 0xc5, 0xf5, 0xee, 0x56, 0xf6, 0xe5, 0x85, 0x14,
	0xb9, 0xb2, 0xbb, 0xff, 0x90, 0x65, 0xf3, 0x18, 0xf9, 0x80, 0x98, 0xb1, 0x44, 0xe2, 0x29, 0xa5,
	0x64, 0x57, 0xce, 0x93, 0x60, 0x8c, 0xd0, 0x1b, 0x67, 0xdd, 0x3d, 0x79, 0x39, 0x4d, 0x3c, 0x94,
	0x0b, 0x09, 0xe3, 0x08, 0xb2, 0x22, 0x43, 0x9a, 0x7a, 0x7f, 0x57, 0x2e, 0xa6, 0xa9, 0x87, 0xbb,
	0xf2, 0xca, 0x8e, 0x0d, 0x72, 0xf2, 0x19, 0x0a, 0x49, 0x89, 0x9d, 0x3a, 0xd6, 0xf4, 0x7a, 0xab,
	0x59, 0xeb, 0x52, 0x62, 0x3c, 0x7c, 0xee, 0xc0, 0x96, 0x80, 0x8f, 0x75, 0xdc, 0x66, 0xc1, 0x23,
	0x66, 0x3e, 0x92, 0xb3, 0x3b, 0xff, 0x2d, 0x41, 0x29, 0xf6, 0xd5, 0x9e, 0x2c, 0xdf, 0x4e, 0xa7,
	0xd3, 0x3d, 0xd5, 0xc9, 0xbc, 0xac, 0xc0, 0x32, 0x6b, 0xd0, 0xf9, 0x08, 0x5a, 0x87, 0xfb, 0x72,
	0x36, 0x6c, 0x3d, 0x24, 0xfe, 0x2f, 0x41, 0x81, 0xb5, 0xf6, 0x76, 0x77, 0xe5, 0x85, 0x48, 0xb3,
	0x42, 0xfc, 0x1d, 0x36, 0x0f, 0x89, 0x9f, 0x83, 0x66, 0xe5, 0xe0, 0x50, 0xce, 0x87, 0xcd, 0xfb,
	0x95, 0x5d, 0x79, 0x39, 0x6c, 0x92, 0xf9, 0x2e, 0x84, 0xcd, 0x03, 0xea, 0xcb, 0xa0, 0x49, 0xe6,
	0xbd, 0x48, 0xd2, 0xb0, 0xdf, 0x6f, 0x65, 0x9f, 0xed, 0x7a, 0x41, 0xc7, 0xbb, 0x6c, 0xd7, 0x0b,
	0xba, 0xda, 0x95, 0x57, 0xc3, 0x36, 0x9d, 0xf2, 0xb5, 0x9d, 0x2f, 0xc2, 0x5a, 0xe2, 0x81, 0x00,
	0xf5, 0xc0, 0x23, 0xe6, 0xbd, 0x4c, 0xd8, 0x78, 0x24, 0x4b, 0x24, 0x65, 0xc4, 0x9e, 0x01, 0x10,
	0x2e, 0x7e, 0xd4, 0xd5, 0xd5, 0x53, 0x8d, 0x41, 0xf1, 0xa3, 0x2e, 0x4d, 0x19, 0xd2, 0xce, 0xef,
	0x49, 0xb0, 0x1a, 0xff, 0xb2, 0x4d, 0x16, 0x39, 0x4d, 0xd5, 0x8d, 0x5a, 0x97, 0xe4, 0xaa, 0xd6,
	0x59, 0x7c, 0x12, 0x5f, 0x87, 0x3b, 0x69, 0xb6, 0x5a, 0xab, 0x11, 0x62, 0xa3, 0x26, 0x4b, 0x62,
	0x40, 0x4d, 0x6b, 0x72, 0x40, 0x16, 0xdd, 0x83, 0xbb, 0x69, 0x40, 0xbd, 0xd5, 0x69, 0x75, 0x54,
	0x7c, 0xa2, 0x75, 0xe4, 0xdc, 0xce, 0x1f, 0xe6, 0xe0, 0xa6, 0xf0, 0xdb, 0x13, 0x7a, 0x1b, 0xde,
	0xf0, 0x77, 0x79, 0xbe, 0xb2, 0x1b, 0x67, 0x1d, 0x0d, 0x7f, 0xa8, 0x36, 0xbb, 0x67, 0x2d, 0xbf,
	0x18, 0xc8, 0xa0, 0x37, 0xe0, 0xb5, 0x59, 0x30, 0xba, 0x5e, 0x64, 0xe9, 0x15, 0x90, 0x03, 0xb2,
	0x84, 0x15, 0xd8, 0xbe, 0x54, 0x0b, 0x09, 0xa8, 0xcb, 0x31, 0x15, 0x1a, 0x65, 0x97, 0x63, 0x0e,
	0x76, 0x77, 0xe5, 0x45, 0xf4, 0x26, 0xbc, 0x7e, 0x69, 0x5f, 0x95, 0x7d, 0x79, 0x89, 0x78, 0x6e,
	0x16, 0x88, 0x8e, 0x2a, 0x7f, 0xe9, 0xa8, 0x78, 0x42, 0x78, 0x05, 0xa4, 0x22, 0x17, 0x5e, 0x05,
	0x39, 0x90, 0x61, 0xe7, 0x07, 0x12, 0xe4, 0xf9, 0x75, 0x20, 0xc9, 0x47, 0xf4, 0x67, 0xb7, 0xad,
	0x76, 0x6b, 0x47, 0x04, 0x62, 0xe8, 0x87, 0x6c, 0xbd, 0x27, 0xe9, 0x8f, 0xf7, 0x6b, 0xad, 0xce,
	0x83, 0x07, 0xac, 0x1e, 0x4e, 0x09, 0xdd, 0x67, 0xfb, 0x44, 0x8a, 0xbe, 0xc7, 0x84, 0x72, 0x64,
	0xd7, 0x8f, 0x32, 0x89, 0x73, 0x13, 0xa4, 0x3d, 0x79, 0x31, 0x49, 0xaa, 0xc8, 0x4b, 0x49, 0xd2,
	0x7d, 0x39, 0xbf, 0xf3, 0x5d, 0x09, 0x56, 0xa2, 0x17, 0x61, 0x24, 0x53, 0x56, 0xd5, 0xaa, 0xda,
	0xee, 0x56, 0x9b, 0xaa, 0xae, 0xd7, 0x9a, 0x5d, 0x55, 0xce, 0xa4, 0x89, 0x47, 0x6c, 0xd7, 0x8f,
	0x13, 0xab, 0x72, 0x36, 0x4d, 0xac, 0xc9, 0xb9, 0x34, 0x91, 0x54, 0xef, 0x29, 0xe2, 0xb1, 0xbc,
	0x98, 0x30, 0xc7, 0x48, 0x9a, 0x63, 0x88, 0xcc, 0x31, 0x44, 0xe6, 0x18, 0x22, 0x73, 0x0c, 0x91,
	0x39, 0x86, 0xc8, 0x1c, 0x83, 0x99, 0xf3, 0x45, 0x58, 0x89, 0xde, 0xbb, 0x91, 0x69, 0xa9, 0x55,
	0x09, 0xa8, 0x86, 0x8f, 0x3a, 0x4f, 0xda, 0x5a, 0x57, 0x37, 0xda, 0x24, 0x32, 0xb4, 0x9a, 0x9c,
	0xd9, 0xf9, 0x06, 0x14, 0x23, 0x77, 0x3d, 0xa4, 0xd2, 0xa8, 0xaa, 0xb5, 0x06, 0xd6, 0xd8, 0xea,
	0xa6, 0xd5, 0x4a, 0x82, 0x46, 0x2b, 0x97, 0x0d, 0x90, 0xa3, 0x34, 0x56, 0xc5, 0x54, 0xfe, 0x4a,
	0x02, 0xb9, 0xe1, 0x1f, 0xd3, 0xf8, 0xff, 0xef, 0x44, 0x2d, 0x28, 0xea, 0xd6, 0xa8, 0xcf, 0xff,
	0xc6, 0x0d, 0x4a, 0xbc, 0x9d, 0x4a, 0xfc, 0xe9, 0x9b, 0xdb, 0x77, 0x84, 0x6c, 0xf6, 0x1f, 0x98,
	0x94, 0xcc, 0xbb, 0xd2, 0xae, 0x84, 0x5a, 0x50, 0x22, 0x0a, 0x83, 0x3f, 0x40, 0x86, 0x2e, 0xf9,
	0xcf, 0xfa, 0xb7, 0x93, 0xef, 0x2f, 0x13, 0x7f, 0xb5, 0x4c, 0xc9, 0xec, 0x4a, 0x47, 0xe5, 0x7f,
	0xfc, 0xf1, 0xb6, 0xf4, 0xc3, 0x1f, 0x6f, 0x4b, 0x3f, 0xfa, 0xf1, 0xb6, 0xf4, 0xdb, 0x3f, 0xd9,
	0xce, 0xfc, 0xf0, 0x27, 0xdb, 0x99, 0x7f, 0xf9, 0xc9, 0x76, 0xe6, 0x7c, 0x89, 0xfe, 0xf5, 0xb3,
	0xfb, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0x97, 0x5c, 0x43, 0xac, 0x1a, 0x4d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// InterfaceServiceClient is the client API for InterfaceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InterfaceServiceClient interface {
	// SendControl is used by the controller to setup a bi-directional stream of control update messages
	// from RAN environment to which it can respond asynchronously.
	SendControl(ctx context.Context, opts ...grpc.CallOption) (InterfaceService_SendControlClient, error)
	// SendTelemetry is used by the controller to start receiving a stream of telemetry messages from RAN environment.
	SendTelemetry(ctx context.Context, in *L2MeasConfig, opts ...grpc.CallOption) (InterfaceService_SendTelemetryClient, error)
}

type interfaceServiceClient struct {
	cc *grpc.ClientConn
}

func NewInterfaceServiceClient(cc *grpc.ClientConn) InterfaceServiceClient {
	return &interfaceServiceClient{cc}
}

func (c *interfaceServiceClient) SendControl(ctx context.Context, opts ...grpc.CallOption) (InterfaceService_SendControlClient, error) {
	stream, err := c.cc.NewStream(ctx, &_InterfaceService_serviceDesc.Streams[0], "/interface.e2.InterfaceService/SendControl", opts...)
	if err != nil {
		return nil, err
	}
	x := &interfaceServiceSendControlClient{stream}
	return x, nil
}

type InterfaceService_SendControlClient interface {
	Send(*ControlResponse) error
	Recv() (*ControlUpdate, error)
	grpc.ClientStream
}

type interfaceServiceSendControlClient struct {
	grpc.ClientStream
}

func (x *interfaceServiceSendControlClient) Send(m *ControlResponse) error {
	return x.ClientStream.SendMsg(m)
}

func (x *interfaceServiceSendControlClient) Recv() (*ControlUpdate, error) {
	m := new(ControlUpdate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *interfaceServiceClient) SendTelemetry(ctx context.Context, in *L2MeasConfig, opts ...grpc.CallOption) (InterfaceService_SendTelemetryClient, error) {
	stream, err := c.cc.NewStream(ctx, &_InterfaceService_serviceDesc.Streams[1], "/interface.e2.InterfaceService/SendTelemetry", opts...)
	if err != nil {
		return nil, err
	}
	x := &interfaceServiceSendTelemetryClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type InterfaceService_SendTelemetryClient interface {
	Recv() (*TelemetryMessage, error)
	grpc.ClientStream
}

type interfaceServiceSendTelemetryClient struct {
	grpc.ClientStream
}

func (x *interfaceServiceSendTelemetryClient) Recv() (*TelemetryMessage, error) {
	m := new(TelemetryMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// InterfaceServiceServer is the server API for InterfaceService service.
type InterfaceServiceServer interface {
	// SendControl is used by the controller to setup a bi-directional stream of control update messages
	// from RAN environment to which it can respond asynchronously.
	SendControl(InterfaceService_SendControlServer) error
	// SendTelemetry is used by the controller to start receiving a stream of telemetry messages from RAN environment.
	SendTelemetry(*L2MeasConfig, InterfaceService_SendTelemetryServer) error
}

// UnimplementedInterfaceServiceServer can be embedded to have forward compatible implementations.
type UnimplementedInterfaceServiceServer struct {
}

func (*UnimplementedInterfaceServiceServer) SendControl(srv InterfaceService_SendControlServer) error {
	return status.Errorf(codes.Unimplemented, "method SendControl not implemented")
}
func (*UnimplementedInterfaceServiceServer) SendTelemetry(req *L2MeasConfig, srv InterfaceService_SendTelemetryServer) error {
	return status.Errorf(codes.Unimplemented, "method SendTelemetry not implemented")
}

func RegisterInterfaceServiceServer(s *grpc.Server, srv InterfaceServiceServer) {
	s.RegisterService(&_InterfaceService_serviceDesc, srv)
}

func _InterfaceService_SendControl_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InterfaceServiceServer).SendControl(&interfaceServiceSendControlServer{stream})
}

type InterfaceService_SendControlServer interface {
	Send(*ControlUpdate) error
	Recv() (*ControlResponse, error)
	grpc.ServerStream
}

type interfaceServiceSendControlServer struct {
	grpc.ServerStream
}

func (x *interfaceServiceSendControlServer) Send(m *ControlUpdate) error {
	return x.ServerStream.SendMsg(m)
}

func (x *interfaceServiceSendControlServer) Recv() (*ControlResponse, error) {
	m := new(ControlResponse)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _InterfaceService_SendTelemetry_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(L2MeasConfig)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InterfaceServiceServer).SendTelemetry(m, &interfaceServiceSendTelemetryServer{stream})
}

type InterfaceService_SendTelemetryServer interface {
	Send(*TelemetryMessage) error
	grpc.ServerStream
}

type interfaceServiceSendTelemetryServer struct {
	grpc.ServerStream
}

func (x *interfaceServiceSendTelemetryServer) Send(m *TelemetryMessage) error {
	return x.ServerStream.SendMsg(m)
}

var _InterfaceService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "interface.e2.InterfaceService",
	HandlerType: (*InterfaceServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SendControl",
			Handler:       _InterfaceService_SendControl_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "SendTelemetry",
			Handler:       _InterfaceService_SendTelemetry_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/e2/e2-interface.proto",
}

func (m *TelemetryMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelemetryMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.S != nil {
		{
			size := m.S.Size()
			i -= size
			if _, err := m.S.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MessageType != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MessageType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TelemetryMessage_RadioMeasReportPerUE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryMessage_RadioMeasReportPerUE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RadioMeasReportPerUE != nil {
		{
			size, err := m.RadioMeasReportPerUE.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *TelemetryMessage_RadioMeasReportPerCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryMessage_RadioMeasReportPerCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RadioMeasReportPerCell != nil {
		{
			size, err := m.RadioMeasReportPerCell.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *TelemetryMessage_SchedMeasReportPerCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryMessage_SchedMeasReportPerCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchedMeasReportPerCell != nil {
		{
			size, err := m.SchedMeasReportPerCell.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *TelemetryMessage_PDCPMeasReportPerUe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelemetryMessage_PDCPMeasReportPerUe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PDCPMeasReportPerUe != nil {
		{
			size, err := m.PDCPMeasReportPerUe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ControlUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.S != nil {
		{
			size := m.S.Size()
			i -= size
			if _, err := m.S.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MessageType != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MessageType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ControlUpdate_CellConfigReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate_CellConfigReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CellConfigReport != nil {
		{
			size, err := m.CellConfigReport.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ControlUpdate_RRMConfigStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate_RRMConfigStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RRMConfigStatus != nil {
		{
			size, err := m.RRMConfigStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ControlUpdate_UEAdmissionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate_UEAdmissionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UEAdmissionRequest != nil {
		{
			size, err := m.UEAdmissionRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ControlUpdate_UEAdmissionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate_UEAdmissionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UEAdmissionStatus != nil {
		{
			size, err := m.UEAdmissionStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ControlUpdate_UEContextUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate_UEContextUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UEContextUpdate != nil {
		{
			size, err := m.UEContextUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ControlUpdate_BearerAdmissionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate_BearerAdmissionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BearerAdmissionRequest != nil {
		{
			size, err := m.BearerAdmissionRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ControlUpdate_BearerAdmissionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate_BearerAdmissionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BearerAdmissionStatus != nil {
		{
			size, err := m.BearerAdmissionStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *ControlUpdate_HOComplete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate_HOComplete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HOComplete != nil {
		{
			size, err := m.HOComplete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *ControlUpdate_HOFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate_HOFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HOFailure != nil {
		{
			size, err := m.HOFailure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *ControlUpdate_HOCause) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate_HOCause) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HOCause != nil {
		{
			size, err := m.HOCause.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *ControlUpdate_UEReleaseInd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlUpdate_UEReleaseInd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UEReleaseInd != nil {
		{
			size, err := m.UEReleaseInd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *ControlResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ControlResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.S != nil {
		{
			size := m.S.Size()
			i -= size
			if _, err := m.S.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.MessageType != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MessageType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ControlResponse_CellConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlResponse_CellConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CellConfigRequest != nil {
		{
			size, err := m.CellConfigRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ControlResponse_RRMConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlResponse_RRMConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RRMConfig != nil {
		{
			size, err := m.RRMConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ControlResponse_UEAdmissionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlResponse_UEAdmissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UEAdmissionResponse != nil {
		{
			size, err := m.UEAdmissionResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ControlResponse_BearerAdmissionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlResponse_BearerAdmissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BearerAdmissionResponse != nil {
		{
			size, err := m.BearerAdmissionResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ControlResponse_HORequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ControlResponse_HORequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HORequest != nil {
		{
			size, err := m.HORequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *MessageHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessageHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MessageType != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MessageType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MessagePayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessagePayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.S != nil {
		{
			size := m.S.Size()
			i -= size
			if _, err := m.S.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MessagePayload_CellConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_CellConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CellConfigRequest != nil {
		{
			size, err := m.CellConfigRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_CellConfigReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_CellConfigReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.CellConfigReport != nil {
		{
			size, err := m.CellConfigReport.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_UEAdmissionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_UEAdmissionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UEAdmissionRequest != nil {
		{
			size, err := m.UEAdmissionRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_UEAdmissionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_UEAdmissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UEAdmissionResponse != nil {
		{
			size, err := m.UEAdmissionResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_UEAdmissionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_UEAdmissionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UEAdmissionStatus != nil {
		{
			size, err := m.UEAdmissionStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_UEContextUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_UEContextUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UEContextUpdate != nil {
		{
			size, err := m.UEContextUpdate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_UEReconfigInd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_UEReconfigInd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UEReconfigInd != nil {
		{
			size, err := m.UEReconfigInd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_UEReleaseInd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_UEReleaseInd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UEReleaseInd != nil {
		{
			size, err := m.UEReleaseInd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_BearerAdmissionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_BearerAdmissionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BearerAdmissionRequest != nil {
		{
			size, err := m.BearerAdmissionRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_BearerAdmissionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_BearerAdmissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BearerAdmissionResponse != nil {
		{
			size, err := m.BearerAdmissionResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_BearerAdmissionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_BearerAdmissionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BearerAdmissionStatus != nil {
		{
			size, err := m.BearerAdmissionStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_BearerReleaseInd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_BearerReleaseInd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BearerReleaseInd != nil {
		{
			size, err := m.BearerReleaseInd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_HORequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_HORequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HORequest != nil {
		{
			size, err := m.HORequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_HOFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_HOFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HOFailure != nil {
		{
			size, err := m.HOFailure.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_HOComplete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_HOComplete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HOComplete != nil {
		{
			size, err := m.HOComplete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_HOCause) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_HOCause) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HOCause != nil {
		{
			size, err := m.HOCause.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_RRCMeasConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_RRCMeasConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RRCMeasConfig != nil {
		{
			size, err := m.RRCMeasConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_RxSigMeasReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_RxSigMeasReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RxSigMeasReport != nil {
		{
			size, err := m.RxSigMeasReport.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_L2MeasConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_L2MeasConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.L2MeasConfig != nil {
		{
			size, err := m.L2MeasConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_RadioMeasReportPerU) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_RadioMeasReportPerU) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RadioMeasReportPerU != nil {
		{
			size, err := m.RadioMeasReportPerU.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_RadioMeasReportPerCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_RadioMeasReportPerCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RadioMeasReportPerCell != nil {
		{
			size, err := m.RadioMeasReportPerCell.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_SchedMeasReportPerUE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_SchedMeasReportPerUE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchedMeasReportPerUE != nil {
		{
			size, err := m.SchedMeasReportPerUE.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_SchedMeasReportPerCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_SchedMeasReportPerCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SchedMeasReportPerCell != nil {
		{
			size, err := m.SchedMeasReportPerCell.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_PDCPMeasReportPerUe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_PDCPMeasReportPerUe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PDCPMeasReportPerUe != nil {
		{
			size, err := m.PDCPMeasReportPerUe.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_RRMConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_RRMConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RRMConfig != nil {
		{
			size, err := m.RRMConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_RRMConfigStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_RRMConfigStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RRMConfigStatus != nil {
		{
			size, err := m.RRMConfigStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_UECapabilityEnquiry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_UECapabilityEnquiry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UECapabilityEnquiry != nil {
		{
			size, err := m.UECapabilityEnquiry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_UECapabilityInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_UECapabilityInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.UECapabilityInfo != nil {
		{
			size, err := m.UECapabilityInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_ScellAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_ScellAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ScellAdd != nil {
		{
			size, err := m.ScellAdd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_ScellAddStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_ScellAddStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ScellAddStatus != nil {
		{
			size, err := m.ScellAddStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_ScellDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_ScellDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ScellDelete != nil {
		{
			size, err := m.ScellDelete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_SeNBAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_SeNBAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SeNBAdd != nil {
		{
			size, err := m.SeNBAdd.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_SeNBAddStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_SeNBAddStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SeNBAddStatus != nil {
		{
			size, err := m.SeNBAddStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_SeNBDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_SeNBDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SeNBDelete != nil {
		{
			size, err := m.SeNBDelete.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	return len(dAtA) - i, nil
}
func (m *MessagePayload_TrafficSplitConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MessagePayload_TrafficSplitConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TrafficSplitConfig != nil {
		{
			size, err := m.TrafficSplitConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	return len(dAtA) - i, nil
}
func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ResultMessage) > 0 {
		i -= len(m.ResultMessage)
		copy(dAtA[i:], m.ResultMessage)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.ResultMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.ResultCode != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.ResultCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ECGI) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ECGI) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ECGI) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ecid) > 0 {
		i -= len(m.Ecid)
		copy(dAtA[i:], m.Ecid)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Ecid)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PlmnId) > 0 {
		i -= len(m.PlmnId)
		copy(dAtA[i:], m.PlmnId)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.PlmnId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CandScell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CandScell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CandScell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EarfcnDl) > 0 {
		i -= len(m.EarfcnDl)
		copy(dAtA[i:], m.EarfcnDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.EarfcnDl)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pci != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CellConfigRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellConfigRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CellConfigRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CellConfigReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CellConfigReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CellConfigReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DlfsSchedEnable) > 0 {
		i -= len(m.DlfsSchedEnable)
		copy(dAtA[i:], m.DlfsSchedEnable)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.DlfsSchedEnable)))
		i--
		dAtA[i] = 0x72
	}
	if m.MaxNumUesSchedPerTtiUl != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MaxNumUesSchedPerTtiUl))
		i--
		dAtA[i] = 0x68
	}
	if m.MaxNumUesSchedPerTtiDl != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MaxNumUesSchedPerTtiDl))
		i--
		dAtA[i] = 0x60
	}
	if m.MaxNumConnectedBearers != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MaxNumConnectedBearers))
		i--
		dAtA[i] = 0x58
	}
	if m.MaxNumConnectedUes != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.MaxNumConnectedUes))
		i--
		dAtA[i] = 0x50
	}
	if len(m.DuplexMode) > 0 {
		i -= len(m.DuplexMode)
		copy(dAtA[i:], m.DuplexMode)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.DuplexMode)))
		i--
		dAtA[i] = 0x4a
	}
	if m.NumTxAntenna != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.NumTxAntenna))
		i--
		dAtA[i] = 0x40
	}
	if m.RbsPerTtiUl != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.RbsPerTtiUl))
		i--
		dAtA[i] = 0x38
	}
	if m.RbsPerTtiDl != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.RbsPerTtiDl))
		i--
		dAtA[i] = 0x30
	}
	if len(m.EarfcnUl) > 0 {
		i -= len(m.EarfcnUl)
		copy(dAtA[i:], m.EarfcnUl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.EarfcnUl)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.EarfcnDl) > 0 {
		i -= len(m.EarfcnDl)
		copy(dAtA[i:], m.EarfcnDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.EarfcnDl)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CandScells) > 0 {
		for iNdEx := len(m.CandScells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CandScells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Pci != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x10
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEAdmissionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEAdmissionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEAdmissionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdmissionEstCause != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.AdmissionEstCause))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEAdmissionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEAdmissionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEAdmissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdmissionEstResponse != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.AdmissionEstResponse))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEAdmissionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEAdmissionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEAdmissionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AdmissionEstStatus != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.AdmissionEstStatus))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEContextUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEContextUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEContextUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Imsi) > 0 {
		i -= len(m.Imsi)
		copy(dAtA[i:], m.Imsi)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Imsi)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.EnbUeS1ApId) > 0 {
		i -= len(m.EnbUeS1ApId)
		copy(dAtA[i:], m.EnbUeS1ApId)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.EnbUeS1ApId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MmeUeS1ApId) > 0 {
		i -= len(m.MmeUeS1ApId)
		copy(dAtA[i:], m.MmeUeS1ApId)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.MmeUeS1ApId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEReconfigInd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEReconfigInd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEReconfigInd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReconfigCause != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.ReconfigCause))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CrntiNew) > 0 {
		i -= len(m.CrntiNew)
		copy(dAtA[i:], m.CrntiNew)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CrntiNew)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CrntiOld) > 0 {
		i -= len(m.CrntiOld)
		copy(dAtA[i:], m.CrntiOld)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CrntiOld)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEReleaseInd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEReleaseInd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEReleaseInd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReleaseCause != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.ReleaseCause))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UEAMBR) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UEAMBR) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UEAMBR) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AmbrUl) > 0 {
		i -= len(m.AmbrUl)
		copy(dAtA[i:], m.AmbrUl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.AmbrUl)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AmbrDl) > 0 {
		i -= len(m.AmbrDl)
		copy(dAtA[i:], m.AmbrDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.AmbrDl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ERABParamsItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ERABParamsItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ERABParamsItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MbrUl) > 0 {
		i -= len(m.MbrUl)
		copy(dAtA[i:], m.MbrUl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.MbrUl)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.MbrDl) > 0 {
		i -= len(m.MbrDl)
		copy(dAtA[i:], m.MbrDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.MbrDl)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.GbrUl) > 0 {
		i -= len(m.GbrUl)
		copy(dAtA[i:], m.GbrUl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.GbrUl)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.GbrDl) > 0 {
		i -= len(m.GbrDl)
		copy(dAtA[i:], m.GbrDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.GbrDl)))
		i--
		dAtA[i] = 0x32
	}
	if m.Arp != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Arp))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Qci) > 0 {
		i -= len(m.Qci)
		copy(dAtA[i:], m.Qci)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Qci)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Direction != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Direction))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ERABResponseItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ERABResponseItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ERABResponseItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Decision != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Decision))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerAdmissionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerAdmissionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerAdmissionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErabsParams) > 0 {
		for iNdEx := len(m.ErabsParams) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ErabsParams[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.NumErabsList != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.NumErabsList))
		i--
		dAtA[i] = 0x20
	}
	if m.UeAmbr != nil {
		{
			size, err := m.UeAmbr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerAdmissionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerAdmissionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerAdmissionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErabResponse) > 0 {
		for iNdEx := len(m.ErabResponse) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ErabResponse[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NumErabsList != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.NumErabsList))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerAdmissionStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerAdmissionStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerAdmissionStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErabStatus) > 0 {
		for iNdEx := len(m.ErabStatus) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ErabStatus[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NumErabsList != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.NumErabsList))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BearerReleaseInd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BearerReleaseInd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BearerReleaseInd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErabIds) > 0 {
		for iNdEx := len(m.ErabIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ErabIds[iNdEx])
			copy(dAtA[i:], m.ErabIds[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.ErabIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NumErabsList != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.NumErabsList))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HORequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HORequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HORequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EcgiT != nil {
		{
			size, err := m.EcgiT.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.EcgiS != nil {
		{
			size, err := m.EcgiS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HOFailure) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HOFailure) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HOFailure) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HoFailureCause) > 0 {
		i -= len(m.HoFailureCause)
		copy(dAtA[i:], m.HoFailureCause)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.HoFailureCause)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EcgiS != nil {
		{
			size, err := m.EcgiS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HOComplete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HOComplete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HOComplete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EcgiT != nil {
		{
			size, err := m.EcgiT.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.EcgiS != nil {
		{
			size, err := m.EcgiS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CrntiNew) > 0 {
		i -= len(m.CrntiNew)
		copy(dAtA[i:], m.CrntiNew)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CrntiNew)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HOCause) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HOCause) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HOCause) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.HoTrigger) > 0 {
		for iNdEx := len(m.HoTrigger) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HoTrigger[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.HoCause) > 0 {
		i -= len(m.HoCause)
		copy(dAtA[i:], m.HoCause)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.HoCause)))
		i--
		dAtA[i] = 0x22
	}
	if m.EcgiT != nil {
		{
			size, err := m.EcgiT.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.EcgiS != nil {
		{
			size, err := m.EcgiS.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MeasCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CellIndividualOffset) > 0 {
		i -= len(m.CellIndividualOffset)
		copy(dAtA[i:], m.CellIndividualOffset)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CellIndividualOffset)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pci != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MeasObject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasObject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasObject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MeasCells) > 0 {
		for iNdEx := len(m.MeasCells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MeasCells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.DlFreq) > 0 {
		i -= len(m.DlFreq)
		copy(dAtA[i:], m.DlFreq)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.DlFreq)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportParamChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportParamChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ReportParamChoice_PerParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_PerParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PerParam != nil {
		{
			size, err := m.PerParam.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A1Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A1Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A1Param != nil {
		{
			size, err := m.A1Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A2Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A2Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A2Param != nil {
		{
			size, err := m.A2Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A3Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A3Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A3Param != nil {
		{
			size, err := m.A3Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A4Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A4Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A4Param != nil {
		{
			size, err := m.A4Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A5Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A5Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A5Param != nil {
		{
			size, err := m.A5Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *ReportParamChoice_A6Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParamChoice_A6Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.A6Param != nil {
		{
			size, err := m.A6Param.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *ThresholdEUTRAChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThresholdEUTRAChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdEUTRAChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ThresholdEUTRAChoice_ThresholdRSRP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdEUTRAChoice_ThresholdRSRP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ThresholdRSRP)
	copy(dAtA[i:], m.ThresholdRSRP)
	i = encodeVarintE2Interface(dAtA, i, uint64(len(m.ThresholdRSRP)))
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}
func (m *ThresholdEUTRAChoice_ThresholdRSRQ) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThresholdEUTRAChoice_ThresholdRSRQ) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.ThresholdRSRQ)
	copy(dAtA[i:], m.ThresholdRSRQ)
	i = encodeVarintE2Interface(dAtA, i, uint64(len(m.ThresholdRSRQ)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *ThreasholdEUTRA) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ThreasholdEUTRA) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ThreasholdEUTRA) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size, err := m.Choice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Present != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Present))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PerParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PerParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PerParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReportIntervalMs != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.ReportIntervalMs))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *A1Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A1Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A1Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.A1Threshold != nil {
		{
			size, err := m.A1Threshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *A2Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A2Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A2Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.A2Threshold != nil {
		{
			size, err := m.A2Threshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *A3Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A3Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A3Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.A3Offset) > 0 {
		i -= len(m.A3Offset)
		copy(dAtA[i:], m.A3Offset)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.A3Offset)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *A4Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A4Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A4Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.A4Threshold != nil {
		{
			size, err := m.A4Threshold.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *A5Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A5Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A5Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.A5Threshold2 != nil {
		{
			size, err := m.A5Threshold2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.A5Threshold1 != nil {
		{
			size, err := m.A5Threshold1.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *A6Param) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *A6Param) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *A6Param) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.A6Offset) > 0 {
		i -= len(m.A6Offset)
		copy(dAtA[i:], m.A6Offset)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.A6Offset)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportParam) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportParam) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportParam) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timetotrigger != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Timetotrigger))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Hysteresis) > 0 {
		i -= len(m.Hysteresis)
		copy(dAtA[i:], m.Hysteresis)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Hysteresis)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Choice != nil {
		{
			size, err := m.Choice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Present != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Present))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReportConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReportQuality != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.ReportQuality))
		i--
		dAtA[i] = 0x18
	}
	if m.TriggerQuantity != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.TriggerQuantity))
		i--
		dAtA[i] = 0x10
	}
	if m.ReportParams != nil {
		{
			size, err := m.ReportParams.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddMeasId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddMeasId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddMeasId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AddMeasId) > 0 {
		for iNdEx := len(m.AddMeasId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AddMeasId[iNdEx])
			copy(dAtA[i:], m.AddMeasId[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.AddMeasId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DelMeasId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelMeasId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelMeasId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DelMeasId) > 0 {
		for iNdEx := len(m.DelMeasId) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DelMeasId[iNdEx])
			copy(dAtA[i:], m.DelMeasId[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.DelMeasId[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MeasIdActionChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasIdActionChoice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasIdActionChoice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size := m.Choice.Size()
			i -= size
			if _, err := m.Choice.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MeasIdActionChoice_AddMeasId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasIdActionChoice_AddMeasId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddMeasId != nil {
		{
			size, err := m.AddMeasId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MeasIdActionChoice_DelMeasId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasIdActionChoice_DelMeasId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.DelMeasId != nil {
		{
			size, err := m.DelMeasId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *MeasIdActionChoice_Hototarget) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasIdActionChoice_Hototarget) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Hototarget)
	copy(dAtA[i:], m.Hototarget)
	i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Hototarget)))
	i--
	dAtA[i] = 0x1a
	return len(dAtA) - i, nil
}
func (m *MeasIdAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasIdAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasIdAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Choice != nil {
		{
			size, err := m.Choice.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Present != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Present))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MeasID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size, err := m.Action.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ReportConfigId) > 0 {
		i -= len(m.ReportConfigId)
		copy(dAtA[i:], m.ReportConfigId)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.ReportConfigId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MeasObjectId) > 0 {
		i -= len(m.MeasObjectId)
		copy(dAtA[i:], m.MeasObjectId)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.MeasObjectId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RRCMeasConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RRCMeasConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RRCMeasConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MeasIds) > 0 {
		for iNdEx := len(m.MeasIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MeasIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.ReportConfigs) > 0 {
		for iNdEx := len(m.ReportConfigs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReportConfigs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.MeasObjects) > 0 {
		for iNdEx := len(m.MeasObjects) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.MeasObjects[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Crnti) > 0 {
		for iNdEx := len(m.Crnti) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Crnti[iNdEx])
			copy(dAtA[i:], m.Crnti[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PCIARFCN) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PCIARFCN) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PCIARFCN) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EarfcnDl) > 0 {
		i -= len(m.EarfcnDl)
		copy(dAtA[i:], m.EarfcnDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.EarfcnDl)))
		i--
		dAtA[i] = 0x12
	}
	if m.Pci != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Pci))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RXSigReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RXSigReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RXSigReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rsrq) > 0 {
		i -= len(m.Rsrq)
		copy(dAtA[i:], m.Rsrq)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Rsrq)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Rsrp) > 0 {
		i -= len(m.Rsrp)
		copy(dAtA[i:], m.Rsrp)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Rsrp)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.PciArfcn != nil {
		{
			size, err := m.PciArfcn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RxSigMeasReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RxSigMeasReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RxSigMeasReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CellMeasReport) > 0 {
		for iNdEx := len(m.CellMeasReport) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CellMeasReport[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		for iNdEx := len(m.Crnti) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Crnti[iNdEx])
			copy(dAtA[i:], m.Crnti[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *L2ReportInterval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2ReportInterval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2ReportInterval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TPdcpMeasReportPerUe != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.TPdcpMeasReportPerUe))
		i--
		dAtA[i] = 0x28
	}
	if m.TSchedMeasReportPerCell != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.TSchedMeasReportPerCell))
		i--
		dAtA[i] = 0x20
	}
	if m.TSchedMeasReportPerUe != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.TSchedMeasReportPerUe))
		i--
		dAtA[i] = 0x18
	}
	if m.TRadioMeasReportPerCell != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.TRadioMeasReportPerCell))
		i--
		dAtA[i] = 0x10
	}
	if m.TRadioMeasReportPerUe != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.TRadioMeasReportPerUe))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *L2MeasConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *L2MeasConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *L2MeasConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReportIntervals != nil {
		{
			size, err := m.ReportIntervals.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Crnti) > 0 {
		for iNdEx := len(m.Crnti) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Crnti[iNdEx])
			copy(dAtA[i:], m.Crnti[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RadioRepPerServCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadioRepPerServCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RadioRepPerServCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PucchSinrHist) > 0 {
		for iNdEx := len(m.PucchSinrHist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PucchSinrHist[iNdEx])
			copy(dAtA[i:], m.PucchSinrHist[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.PucchSinrHist[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PuschSinrHist) > 0 {
		for iNdEx := len(m.PuschSinrHist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PuschSinrHist[iNdEx])
			copy(dAtA[i:], m.PuschSinrHist[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.PuschSinrHist[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RiHist) > 0 {
		for iNdEx := len(m.RiHist) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RiHist[iNdEx])
			copy(dAtA[i:], m.RiHist[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.RiHist[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CqiHist) > 0 {
		dAtA105 := make([]byte, len(m.CqiHist)*10)
		var j104 int
		for _, num := range m.CqiHist {
			for num >= 1<<7 {
				dAtA105[j104] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j104++
			}
			dAtA105[j104] = uint8(num)
			j104++
		}
		i -= j104
		copy(dAtA[i:], dAtA105[:j104])
		i = encodeVarintE2Interface(dAtA, i, uint64(j104))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RadioMeasReportPerUE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadioMeasReportPerUE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RadioMeasReportPerUE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RadioReportServCells) > 0 {
		for iNdEx := len(m.RadioReportServCells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RadioReportServCells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RadioMeasReportPerCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RadioMeasReportPerCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RadioMeasReportPerCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PucchIntfPowerHist) > 0 {
		dAtA109 := make([]byte, len(m.PucchIntfPowerHist)*10)
		var j108 int
		for _, num := range m.PucchIntfPowerHist {
			for num >= 1<<7 {
				dAtA109[j108] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j108++
			}
			dAtA109[j108] = uint8(num)
			j108++
		}
		i -= j108
		copy(dAtA[i:], dAtA109[:j108])
		i = encodeVarintE2Interface(dAtA, i, uint64(j108))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PuschIntfPwrHist) > 0 {
		dAtA111 := make([]byte, len(m.PuschIntfPwrHist)*10)
		var j110 int
		for _, num := range m.PuschIntfPwrHist {
			for num >= 1<<7 {
				dAtA111[j110] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j110++
			}
			dAtA111[j110] = uint8(num)
			j110++
		}
		i -= j110
		copy(dAtA[i:], dAtA111[:j110])
		i = encodeVarintE2Interface(dAtA, i, uint64(j110))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PRBUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PRBUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PRBUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PrbUsageUl) > 0 {
		for iNdEx := len(m.PrbUsageUl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PrbUsageUl[iNdEx])
			copy(dAtA[i:], m.PrbUsageUl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.PrbUsageUl[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.PrbUsageDl) > 0 {
		for iNdEx := len(m.PrbUsageDl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PrbUsageDl[iNdEx])
			copy(dAtA[i:], m.PrbUsageDl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.PrbUsageDl[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SchedMeasRepPerServCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedMeasRepPerServCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedMeasRepPerServCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RankDl2) > 0 {
		for iNdEx := len(m.RankDl2) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RankDl2[iNdEx])
			copy(dAtA[i:], m.RankDl2[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.RankDl2[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.RankDl1) > 0 {
		for iNdEx := len(m.RankDl1) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RankDl1[iNdEx])
			copy(dAtA[i:], m.RankDl1[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.RankDl1[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.NumSchedTtisUl) > 0 {
		for iNdEx := len(m.NumSchedTtisUl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NumSchedTtisUl[iNdEx])
			copy(dAtA[i:], m.NumSchedTtisUl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.NumSchedTtisUl[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.McsUl) > 0 {
		for iNdEx := len(m.McsUl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.McsUl[iNdEx])
			copy(dAtA[i:], m.McsUl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.McsUl[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.NumSchedTtisDl) > 0 {
		for iNdEx := len(m.NumSchedTtisDl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NumSchedTtisDl[iNdEx])
			copy(dAtA[i:], m.NumSchedTtisDl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.NumSchedTtisDl[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.McsDl) > 0 {
		for iNdEx := len(m.McsDl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.McsDl[iNdEx])
			copy(dAtA[i:], m.McsDl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.McsDl[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.PrbUsage != nil {
		{
			size, err := m.PrbUsage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.QciVals) > 0 {
		for iNdEx := len(m.QciVals) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.QciVals[iNdEx])
			copy(dAtA[i:], m.QciVals[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.QciVals[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchedMeasReportPerUE) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedMeasReportPerUE) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedMeasReportPerUE) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SchedReportServCells) > 0 {
		for iNdEx := len(m.SchedReportServCells) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SchedReportServCells[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchedMeasReportPerCell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedMeasReportPerCell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedMeasReportPerCell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PrbUsageScell != nil {
		{
			size, err := m.PrbUsageScell.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PrbUsagePcell != nil {
		{
			size, err := m.PrbUsagePcell.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.QciVals) > 0 {
		for iNdEx := len(m.QciVals) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.QciVals[iNdEx])
			copy(dAtA[i:], m.QciVals[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.QciVals[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PDCPMeasReportPerUe) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PDCPMeasReportPerUe) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PDCPMeasReportPerUe) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ThroughputUl) > 0 {
		dAtA120 := make([]byte, len(m.ThroughputUl)*10)
		var j119 int
		for _, num := range m.ThroughputUl {
			for num >= 1<<7 {
				dAtA120[j119] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j119++
			}
			dAtA120[j119] = uint8(num)
			j119++
		}
		i -= j119
		copy(dAtA[i:], dAtA120[:j119])
		i = encodeVarintE2Interface(dAtA, i, uint64(j119))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ThroughputDl) > 0 {
		dAtA122 := make([]byte, len(m.ThroughputDl)*10)
		var j121 int
		for _, num := range m.ThroughputDl {
			for num >= 1<<7 {
				dAtA122[j121] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j121++
			}
			dAtA122[j121] = uint8(num)
			j121++
		}
		i -= j121
		copy(dAtA[i:], dAtA122[:j121])
		i = encodeVarintE2Interface(dAtA, i, uint64(j121))
		i--
		dAtA[i] = 0x52
	}
	if len(m.PktLossRateUl) > 0 {
		dAtA124 := make([]byte, len(m.PktLossRateUl)*10)
		var j123 int
		for _, num := range m.PktLossRateUl {
			for num >= 1<<7 {
				dAtA124[j123] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j123++
			}
			dAtA124[j123] = uint8(num)
			j123++
		}
		i -= j123
		copy(dAtA[i:], dAtA124[:j123])
		i = encodeVarintE2Interface(dAtA, i, uint64(j123))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PktLossRateDl) > 0 {
		dAtA126 := make([]byte, len(m.PktLossRateDl)*10)
		var j125 int
		for _, num := range m.PktLossRateDl {
			for num >= 1<<7 {
				dAtA126[j125] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j125++
			}
			dAtA126[j125] = uint8(num)
			j125++
		}
		i -= j125
		copy(dAtA[i:], dAtA126[:j125])
		i = encodeVarintE2Interface(dAtA, i, uint64(j125))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PktDiscardRateDl) > 0 {
		dAtA128 := make([]byte, len(m.PktDiscardRateDl)*10)
		var j127 int
		for _, num := range m.PktDiscardRateDl {
			for num >= 1<<7 {
				dAtA128[j127] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j127++
			}
			dAtA128[j127] = uint8(num)
			j127++
		}
		i -= j127
		copy(dAtA[i:], dAtA128[:j127])
		i = encodeVarintE2Interface(dAtA, i, uint64(j127))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.PktDelayDl) > 0 {
		dAtA130 := make([]byte, len(m.PktDelayDl)*10)
		var j129 int
		for _, num := range m.PktDelayDl {
			for num >= 1<<7 {
				dAtA130[j129] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j129++
			}
			dAtA130[j129] = uint8(num)
			j129++
		}
		i -= j129
		copy(dAtA[i:], dAtA130[:j129])
		i = encodeVarintE2Interface(dAtA, i, uint64(j129))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DataVolUl) > 0 {
		dAtA132 := make([]byte, len(m.DataVolUl)*10)
		var j131 int
		for _, num := range m.DataVolUl {
			for num >= 1<<7 {
				dAtA132[j131] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j131++
			}
			dAtA132[j131] = uint8(num)
			j131++
		}
		i -= j131
		copy(dAtA[i:], dAtA132[:j131])
		i = encodeVarintE2Interface(dAtA, i, uint64(j131))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DataVolDl) > 0 {
		dAtA134 := make([]byte, len(m.DataVolDl)*10)
		var j133 int
		for _, num := range m.DataVolDl {
			for num >= 1<<7 {
				dAtA134[j133] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j133++
			}
			dAtA134[j133] = uint8(num)
			j133++
		}
		i -= j133
		copy(dAtA[i:], dAtA134[:j133])
		i = encodeVarintE2Interface(dAtA, i, uint64(j133))
		i--
		dAtA[i] = 0x22
	}
	if len(m.QciVals) > 0 {
		for iNdEx := len(m.QciVals) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.QciVals[iNdEx])
			copy(dAtA[i:], m.QciVals[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.QciVals[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RRMConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RRMConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RRMConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SubFrameBitmaskUl) > 0 {
		for iNdEx := len(m.SubFrameBitmaskUl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubFrameBitmaskUl[iNdEx])
			copy(dAtA[i:], m.SubFrameBitmaskUl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.SubFrameBitmaskUl[iNdEx])))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.EndPrbUl) > 0 {
		dAtA137 := make([]byte, len(m.EndPrbUl)*10)
		var j136 int
		for _, num := range m.EndPrbUl {
			for num >= 1<<7 {
				dAtA137[j136] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j136++
			}
			dAtA137[j136] = uint8(num)
			j136++
		}
		i -= j136
		copy(dAtA[i:], dAtA137[:j136])
		i = encodeVarintE2Interface(dAtA, i, uint64(j136))
		i--
		dAtA[i] = 0x52
	}
	if len(m.StartPrbUl) > 0 {
		dAtA139 := make([]byte, len(m.StartPrbUl)*10)
		var j138 int
		for _, num := range m.StartPrbUl {
			for num >= 1<<7 {
				dAtA139[j138] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j138++
			}
			dAtA139[j138] = uint8(num)
			j138++
		}
		i -= j138
		copy(dAtA[i:], dAtA139[:j138])
		i = encodeVarintE2Interface(dAtA, i, uint64(j138))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.P0UePusch) > 0 {
		dAtA141 := make([]byte, len(m.P0UePusch)*10)
		var j140 int
		for _, num := range m.P0UePusch {
			for num >= 1<<7 {
				dAtA141[j140] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j140++
			}
			dAtA141[j140] = uint8(num)
			j140++
		}
		i -= j140
		copy(dAtA[i:], dAtA141[:j140])
		i = encodeVarintE2Interface(dAtA, i, uint64(j140))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SubFrameBitmaskDl) > 0 {
		for iNdEx := len(m.SubFrameBitmaskDl) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SubFrameBitmaskDl[iNdEx])
			copy(dAtA[i:], m.SubFrameBitmaskDl[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.SubFrameBitmaskDl[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.EndPrbDl) > 0 {
		dAtA143 := make([]byte, len(m.EndPrbDl)*10)
		var j142 int
		for _, num := range m.EndPrbDl {
			for num >= 1<<7 {
				dAtA143[j142] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j142++
			}
			dAtA143[j142] = uint8(num)
			j142++
		}
		i -= j142
		copy(dAtA[i:], dAtA143[:j142])
		i = encodeVarintE2Interface(dAtA, i, uint64(j142))
		i--
		dAtA[i] = 0x32
	}
	if len(m.StartPrbDl) > 0 {
		dAtA145 := make([]byte, len(m.StartPrbDl)*10)
		var j144 int
		for _, num := range m.StartPrbDl {
			for num >= 1<<7 {
				dAtA145[j144] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j144++
			}
			dAtA145[j144] = uint8(num)
			j144++
		}
		i -= j144
		copy(dAtA[i:], dAtA145[:j144])
		i = encodeVarintE2Interface(dAtA, i, uint64(j144))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PA) > 0 {
		dAtA147 := make([]byte, len(m.PA)*10)
		var j146 int
		for _, num := range m.PA {
			for num >= 1<<7 {
				dAtA147[j146] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j146++
			}
			dAtA147[j146] = uint8(num)
			j146++
		}
		i -= j146
		copy(dAtA[i:], dAtA147[:j146])
		i = encodeVarintE2Interface(dAtA, i, uint64(j146))
		i--
		dAtA[i] = 0x22
	}
	if m.PciArfcn != nil {
		{
			size, err := m.PciArfcn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Crnti) > 0 {
		for iNdEx := len(m.Crnti) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Crnti[iNdEx])
			copy(dAtA[i:], m.Crnti[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RRMConfigStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RRMConfigStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RRMConfigStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA151 := make([]byte, len(m.Status)*10)
		var j150 int
		for _, num := range m.Status {
			for num >= 1<<7 {
				dAtA151[j150] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j150++
			}
			dAtA151[j150] = uint8(num)
			j150++
		}
		i -= j150
		copy(dAtA[i:], dAtA151[:j150])
		i = encodeVarintE2Interface(dAtA, i, uint64(j150))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Crnti) > 0 {
		for iNdEx := len(m.Crnti) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Crnti[iNdEx])
			copy(dAtA[i:], m.Crnti[iNdEx])
			i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CACap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CACap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CACap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CrossCarrierSched) > 0 {
		i -= len(m.CrossCarrierSched)
		copy(dAtA[i:], m.CrossCarrierSched)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CrossCarrierSched)))
		i--
		dAtA[i] = 0x22
	}
	if m.Caclassul != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Caclassul))
		i--
		dAtA[i] = 0x18
	}
	if m.Caclassdl != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Caclassdl))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Band) > 0 {
		i -= len(m.Band)
		copy(dAtA[i:], m.Band)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Band)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DCCap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DCCap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DCCap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DrbTypeSplit != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.DrbTypeSplit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UECapabilityEnquiry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UECapabilityEnquiry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UECapabilityEnquiry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UECapabilityInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UECapabilityInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UECapabilityInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DcCap != nil {
		{
			size, err := m.DcCap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CaCap != nil {
		{
			size, err := m.CaCap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PropScell) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PropScell) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PropScell) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeactTimer) > 0 {
		i -= len(m.DeactTimer)
		copy(dAtA[i:], m.DeactTimer)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.DeactTimer)))
		i--
		dAtA[i] = 0x22
	}
	if m.CaDirection != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.CaDirection))
		i--
		dAtA[i] = 0x18
	}
	if len(m.CrossCarrierSchedEnable) > 0 {
		i -= len(m.CrossCarrierSchedEnable)
		copy(dAtA[i:], m.CrossCarrierSchedEnable)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.CrossCarrierSchedEnable)))
		i--
		dAtA[i] = 0x12
	}
	if m.PciArfcn != nil {
		{
			size, err := m.PciArfcn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScellAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScellAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScellAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScellsProp) > 0 {
		for iNdEx := len(m.ScellsProp) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ScellsProp[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScellAddStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScellAddStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScellAddStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		dAtA160 := make([]byte, len(m.Status)*10)
		var j159 int
		for _, num := range m.Status {
			for num >= 1<<7 {
				dAtA160[j159] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j159++
			}
			dAtA160[j159] = uint8(num)
			j159++
		}
		i -= j159
		copy(dAtA[i:], dAtA160[:j159])
		i = encodeVarintE2Interface(dAtA, i, uint64(j159))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ScellsInd) > 0 {
		for iNdEx := len(m.ScellsInd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ScellsInd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScellDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScellDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScellDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScellsInd) > 0 {
		for iNdEx := len(m.ScellsInd) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ScellsInd[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SeNBAdd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeNBAdd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeNBAdd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SEcgi != nil {
		{
			size, err := m.SEcgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MEcgi != nil {
		{
			size, err := m.MEcgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SeNBAddStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeNBAddStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeNBAddStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintE2Interface(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SeNBDelete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeNBDelete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeNBDelete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SEcgi != nil {
		{
			size, err := m.SEcgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.MEcgi != nil {
		{
			size, err := m.MEcgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrafficSplitPercentage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficSplitPercentage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrafficSplitPercentage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrafficPercentageUl) > 0 {
		i -= len(m.TrafficPercentageUl)
		copy(dAtA[i:], m.TrafficPercentageUl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.TrafficPercentageUl)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TrafficPercentageDl) > 0 {
		i -= len(m.TrafficPercentageDl)
		copy(dAtA[i:], m.TrafficPercentageDl)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.TrafficPercentageDl)))
		i--
		dAtA[i] = 0x12
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrafficSplitConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrafficSplitConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrafficSplitConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrafficSplitPercentage) > 0 {
		for iNdEx := len(m.TrafficSplitPercentage) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TrafficSplitPercentage[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintE2Interface(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Ecgi != nil {
		{
			size, err := m.Ecgi.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintE2Interface(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Crnti) > 0 {
		i -= len(m.Crnti)
		copy(dAtA[i:], m.Crnti)
		i = encodeVarintE2Interface(dAtA, i, uint64(len(m.Crnti)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintE2Interface(dAtA []byte, offset int, v uint64) int {
	offset -= sovE2Interface(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TelemetryMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageType != 0 {
		n += 1 + sovE2Interface(uint64(m.MessageType))
	}
	if m.S != nil {
		n += m.S.Size()
	}
	return n
}

func (m *TelemetryMessage_RadioMeasReportPerUE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RadioMeasReportPerUE != nil {
		l = m.RadioMeasReportPerUE.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *TelemetryMessage_RadioMeasReportPerCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RadioMeasReportPerCell != nil {
		l = m.RadioMeasReportPerCell.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *TelemetryMessage_SchedMeasReportPerCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchedMeasReportPerCell != nil {
		l = m.SchedMeasReportPerCell.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *TelemetryMessage_PDCPMeasReportPerUe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PDCPMeasReportPerUe != nil {
		l = m.PDCPMeasReportPerUe.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageType != 0 {
		n += 1 + sovE2Interface(uint64(m.MessageType))
	}
	if m.S != nil {
		n += m.S.Size()
	}
	return n
}

func (m *ControlUpdate_CellConfigReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CellConfigReport != nil {
		l = m.CellConfigReport.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlUpdate_RRMConfigStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RRMConfigStatus != nil {
		l = m.RRMConfigStatus.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlUpdate_UEAdmissionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UEAdmissionRequest != nil {
		l = m.UEAdmissionRequest.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlUpdate_UEAdmissionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UEAdmissionStatus != nil {
		l = m.UEAdmissionStatus.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlUpdate_UEContextUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UEContextUpdate != nil {
		l = m.UEContextUpdate.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlUpdate_BearerAdmissionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BearerAdmissionRequest != nil {
		l = m.BearerAdmissionRequest.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlUpdate_BearerAdmissionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BearerAdmissionStatus != nil {
		l = m.BearerAdmissionStatus.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlUpdate_HOComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HOComplete != nil {
		l = m.HOComplete.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlUpdate_HOFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HOFailure != nil {
		l = m.HOFailure.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlUpdate_HOCause) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HOCause != nil {
		l = m.HOCause.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlUpdate_UEReleaseInd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UEReleaseInd != nil {
		l = m.UEReleaseInd.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageType != 0 {
		n += 1 + sovE2Interface(uint64(m.MessageType))
	}
	if m.S != nil {
		n += m.S.Size()
	}
	return n
}

func (m *ControlResponse_CellConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CellConfigRequest != nil {
		l = m.CellConfigRequest.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlResponse_RRMConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RRMConfig != nil {
		l = m.RRMConfig.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlResponse_UEAdmissionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UEAdmissionResponse != nil {
		l = m.UEAdmissionResponse.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlResponse_BearerAdmissionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BearerAdmissionResponse != nil {
		l = m.BearerAdmissionResponse.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ControlResponse_HORequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HORequest != nil {
		l = m.HORequest.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessageHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MessageType != 0 {
		n += 1 + sovE2Interface(uint64(m.MessageType))
	}
	return n
}

func (m *MessagePayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.S != nil {
		n += m.S.Size()
	}
	return n
}

func (m *MessagePayload_CellConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CellConfigRequest != nil {
		l = m.CellConfigRequest.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_CellConfigReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CellConfigReport != nil {
		l = m.CellConfigReport.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_UEAdmissionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UEAdmissionRequest != nil {
		l = m.UEAdmissionRequest.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_UEAdmissionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UEAdmissionResponse != nil {
		l = m.UEAdmissionResponse.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_UEAdmissionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UEAdmissionStatus != nil {
		l = m.UEAdmissionStatus.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_UEContextUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UEContextUpdate != nil {
		l = m.UEContextUpdate.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_UEReconfigInd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UEReconfigInd != nil {
		l = m.UEReconfigInd.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_UEReleaseInd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UEReleaseInd != nil {
		l = m.UEReleaseInd.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_BearerAdmissionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BearerAdmissionRequest != nil {
		l = m.BearerAdmissionRequest.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_BearerAdmissionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BearerAdmissionResponse != nil {
		l = m.BearerAdmissionResponse.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_BearerAdmissionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BearerAdmissionStatus != nil {
		l = m.BearerAdmissionStatus.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_BearerReleaseInd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BearerReleaseInd != nil {
		l = m.BearerReleaseInd.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_HORequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HORequest != nil {
		l = m.HORequest.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_HOFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HOFailure != nil {
		l = m.HOFailure.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_HOComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HOComplete != nil {
		l = m.HOComplete.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_HOCause) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HOCause != nil {
		l = m.HOCause.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_RRCMeasConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RRCMeasConfig != nil {
		l = m.RRCMeasConfig.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_RxSigMeasReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RxSigMeasReport != nil {
		l = m.RxSigMeasReport.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_L2MeasConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.L2MeasConfig != nil {
		l = m.L2MeasConfig.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_RadioMeasReportPerU) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RadioMeasReportPerU != nil {
		l = m.RadioMeasReportPerU.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_RadioMeasReportPerCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RadioMeasReportPerCell != nil {
		l = m.RadioMeasReportPerCell.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_SchedMeasReportPerUE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchedMeasReportPerUE != nil {
		l = m.SchedMeasReportPerUE.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_SchedMeasReportPerCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SchedMeasReportPerCell != nil {
		l = m.SchedMeasReportPerCell.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_PDCPMeasReportPerUe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PDCPMeasReportPerUe != nil {
		l = m.PDCPMeasReportPerUe.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_RRMConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RRMConfig != nil {
		l = m.RRMConfig.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_RRMConfigStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RRMConfigStatus != nil {
		l = m.RRMConfigStatus.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_UECapabilityEnquiry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UECapabilityEnquiry != nil {
		l = m.UECapabilityEnquiry.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_UECapabilityInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UECapabilityInfo != nil {
		l = m.UECapabilityInfo.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_ScellAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScellAdd != nil {
		l = m.ScellAdd.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_ScellAddStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScellAddStatus != nil {
		l = m.ScellAddStatus.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_ScellDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ScellDelete != nil {
		l = m.ScellDelete.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_SeNBAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeNBAdd != nil {
		l = m.SeNBAdd.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_SeNBAddStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeNBAddStatus != nil {
		l = m.SeNBAddStatus.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_SeNBDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SeNBDelete != nil {
		l = m.SeNBDelete.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MessagePayload_TrafficSplitConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrafficSplitConfig != nil {
		l = m.TrafficSplitConfig.Size()
		n += 2 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *ServiceResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResultCode != 0 {
		n += 1 + sovE2Interface(uint64(m.ResultCode))
	}
	l = len(m.ResultMessage)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *ECGI) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PlmnId)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Ecid)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *CandScell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pci != 0 {
		n += 1 + sovE2Interface(uint64(m.Pci))
	}
	l = len(m.EarfcnDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *CellConfigRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *CellConfigReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Pci != 0 {
		n += 1 + sovE2Interface(uint64(m.Pci))
	}
	if len(m.CandScells) > 0 {
		for _, e := range m.CandScells {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	l = len(m.EarfcnDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.EarfcnUl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.RbsPerTtiDl != 0 {
		n += 1 + sovE2Interface(uint64(m.RbsPerTtiDl))
	}
	if m.RbsPerTtiUl != 0 {
		n += 1 + sovE2Interface(uint64(m.RbsPerTtiUl))
	}
	if m.NumTxAntenna != 0 {
		n += 1 + sovE2Interface(uint64(m.NumTxAntenna))
	}
	l = len(m.DuplexMode)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.MaxNumConnectedUes != 0 {
		n += 1 + sovE2Interface(uint64(m.MaxNumConnectedUes))
	}
	if m.MaxNumConnectedBearers != 0 {
		n += 1 + sovE2Interface(uint64(m.MaxNumConnectedBearers))
	}
	if m.MaxNumUesSchedPerTtiDl != 0 {
		n += 1 + sovE2Interface(uint64(m.MaxNumUesSchedPerTtiDl))
	}
	if m.MaxNumUesSchedPerTtiUl != 0 {
		n += 1 + sovE2Interface(uint64(m.MaxNumUesSchedPerTtiUl))
	}
	l = len(m.DlfsSchedEnable)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *UEAdmissionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.AdmissionEstCause != 0 {
		n += 1 + sovE2Interface(uint64(m.AdmissionEstCause))
	}
	return n
}

func (m *UEAdmissionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.AdmissionEstResponse != 0 {
		n += 1 + sovE2Interface(uint64(m.AdmissionEstResponse))
	}
	return n
}

func (m *UEAdmissionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.AdmissionEstStatus != 0 {
		n += 1 + sovE2Interface(uint64(m.AdmissionEstStatus))
	}
	return n
}

func (m *UEContextUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.MmeUeS1ApId)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.EnbUeS1ApId)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Imsi)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *UEReconfigInd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CrntiOld)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.CrntiNew)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.ReconfigCause != 0 {
		n += 1 + sovE2Interface(uint64(m.ReconfigCause))
	}
	return n
}

func (m *UEReleaseInd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.ReleaseCause != 0 {
		n += 1 + sovE2Interface(uint64(m.ReleaseCause))
	}
	return n
}

func (m *UEAMBR) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AmbrDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.AmbrUl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *ERABParamsItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Direction != 0 {
		n += 1 + sovE2Interface(uint64(m.Direction))
	}
	if m.Type != 0 {
		n += 1 + sovE2Interface(uint64(m.Type))
	}
	l = len(m.Qci)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Arp != 0 {
		n += 1 + sovE2Interface(uint64(m.Arp))
	}
	l = len(m.GbrDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.GbrUl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.MbrDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.MbrUl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *ERABResponseItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Decision != 0 {
		n += 1 + sovE2Interface(uint64(m.Decision))
	}
	return n
}

func (m *BearerAdmissionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.UeAmbr != nil {
		l = m.UeAmbr.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.NumErabsList != 0 {
		n += 1 + sovE2Interface(uint64(m.NumErabsList))
	}
	if len(m.ErabsParams) > 0 {
		for _, e := range m.ErabsParams {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *BearerAdmissionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.NumErabsList != 0 {
		n += 1 + sovE2Interface(uint64(m.NumErabsList))
	}
	if len(m.ErabResponse) > 0 {
		for _, e := range m.ErabResponse {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *BearerAdmissionStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.NumErabsList != 0 {
		n += 1 + sovE2Interface(uint64(m.NumErabsList))
	}
	if len(m.ErabStatus) > 0 {
		for _, e := range m.ErabStatus {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *BearerReleaseInd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.NumErabsList != 0 {
		n += 1 + sovE2Interface(uint64(m.NumErabsList))
	}
	if len(m.ErabIds) > 0 {
		for _, s := range m.ErabIds {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *HORequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiS != nil {
		l = m.EcgiS.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiT != nil {
		l = m.EcgiT.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *HOFailure) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiS != nil {
		l = m.EcgiS.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.HoFailureCause)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *HOComplete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CrntiNew)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiS != nil {
		l = m.EcgiS.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiT != nil {
		l = m.EcgiT.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *HOCause) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiS != nil {
		l = m.EcgiS.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.EcgiT != nil {
		l = m.EcgiT.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.HoCause)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.HoTrigger) > 0 {
		for _, e := range m.HoTrigger {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *MeasCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pci != 0 {
		n += 1 + sovE2Interface(uint64(m.Pci))
	}
	l = len(m.CellIndividualOffset)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *MeasObject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DlFreq)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.MeasCells) > 0 {
		for _, e := range m.MeasCells {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *ReportParamChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *ReportParamChoice_PerParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PerParam != nil {
		l = m.PerParam.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A1Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A1Param != nil {
		l = m.A1Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A2Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A2Param != nil {
		l = m.A2Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A3Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A3Param != nil {
		l = m.A3Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A4Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A4Param != nil {
		l = m.A4Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A5Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A5Param != nil {
		l = m.A5Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ReportParamChoice_A6Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A6Param != nil {
		l = m.A6Param.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *ThresholdEUTRAChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *ThresholdEUTRAChoice_ThresholdRSRP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ThresholdRSRP)
	n += 1 + l + sovE2Interface(uint64(l))
	return n
}
func (m *ThresholdEUTRAChoice_ThresholdRSRQ) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ThresholdRSRQ)
	n += 1 + l + sovE2Interface(uint64(l))
	return n
}
func (m *ThreasholdEUTRA) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Present != 0 {
		n += 1 + sovE2Interface(uint64(m.Present))
	}
	if m.Choice != nil {
		l = m.Choice.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *PerParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReportIntervalMs != 0 {
		n += 1 + sovE2Interface(uint64(m.ReportIntervalMs))
	}
	return n
}

func (m *A1Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A1Threshold != nil {
		l = m.A1Threshold.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *A2Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A2Threshold != nil {
		l = m.A2Threshold.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *A3Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.A3Offset)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *A4Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A4Threshold != nil {
		l = m.A4Threshold.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *A5Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.A5Threshold1 != nil {
		l = m.A5Threshold1.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.A5Threshold2 != nil {
		l = m.A5Threshold2.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *A6Param) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.A6Offset)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *ReportParam) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Present != 0 {
		n += 1 + sovE2Interface(uint64(m.Present))
	}
	if m.Choice != nil {
		l = m.Choice.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Hysteresis)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Timetotrigger != 0 {
		n += 1 + sovE2Interface(uint64(m.Timetotrigger))
	}
	return n
}

func (m *ReportConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReportParams != nil {
		l = m.ReportParams.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.TriggerQuantity != 0 {
		n += 1 + sovE2Interface(uint64(m.TriggerQuantity))
	}
	if m.ReportQuality != 0 {
		n += 1 + sovE2Interface(uint64(m.ReportQuality))
	}
	return n
}

func (m *AddMeasId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AddMeasId) > 0 {
		for _, s := range m.AddMeasId {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *DelMeasId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DelMeasId) > 0 {
		for _, s := range m.DelMeasId {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *MeasIdActionChoice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Choice != nil {
		n += m.Choice.Size()
	}
	return n
}

func (m *MeasIdActionChoice_AddMeasId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddMeasId != nil {
		l = m.AddMeasId.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MeasIdActionChoice_DelMeasId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DelMeasId != nil {
		l = m.DelMeasId.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}
func (m *MeasIdActionChoice_Hototarget) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hototarget)
	n += 1 + l + sovE2Interface(uint64(l))
	return n
}
func (m *MeasIdAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Present != 0 {
		n += 1 + sovE2Interface(uint64(m.Present))
	}
	if m.Choice != nil {
		l = m.Choice.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *MeasID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MeasObjectId)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.ReportConfigId)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *RRCMeasConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.Crnti) > 0 {
		for _, s := range m.Crnti {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.MeasObjects) > 0 {
		for _, e := range m.MeasObjects {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.ReportConfigs) > 0 {
		for _, e := range m.ReportConfigs {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.MeasIds) > 0 {
		for _, e := range m.MeasIds {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *PCIARFCN) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pci != 0 {
		n += 1 + sovE2Interface(uint64(m.Pci))
	}
	l = len(m.EarfcnDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *RXSigReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PciArfcn != nil {
		l = m.PciArfcn.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Rsrp)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Rsrq)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *RxSigMeasReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Crnti) > 0 {
		for _, s := range m.Crnti {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.CellMeasReport) > 0 {
		for _, e := range m.CellMeasReport {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *L2ReportInterval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TRadioMeasReportPerUe != 0 {
		n += 1 + sovE2Interface(uint64(m.TRadioMeasReportPerUe))
	}
	if m.TRadioMeasReportPerCell != 0 {
		n += 1 + sovE2Interface(uint64(m.TRadioMeasReportPerCell))
	}
	if m.TSchedMeasReportPerUe != 0 {
		n += 1 + sovE2Interface(uint64(m.TSchedMeasReportPerUe))
	}
	if m.TSchedMeasReportPerCell != 0 {
		n += 1 + sovE2Interface(uint64(m.TSchedMeasReportPerCell))
	}
	if m.TPdcpMeasReportPerUe != 0 {
		n += 1 + sovE2Interface(uint64(m.TPdcpMeasReportPerUe))
	}
	return n
}

func (m *L2MeasConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.Crnti) > 0 {
		for _, s := range m.Crnti {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if m.ReportIntervals != nil {
		l = m.ReportIntervals.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *RadioRepPerServCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.CqiHist) > 0 {
		l = 0
		for _, e := range m.CqiHist {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.RiHist) > 0 {
		for _, s := range m.RiHist {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.PuschSinrHist) > 0 {
		for _, s := range m.PuschSinrHist {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.PucchSinrHist) > 0 {
		for _, s := range m.PucchSinrHist {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *RadioMeasReportPerUE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.RadioReportServCells) > 0 {
		for _, e := range m.RadioReportServCells {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *RadioMeasReportPerCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.PuschIntfPwrHist) > 0 {
		l = 0
		for _, e := range m.PuschIntfPwrHist {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.PucchIntfPowerHist) > 0 {
		l = 0
		for _, e := range m.PucchIntfPowerHist {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	return n
}

func (m *PRBUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PrbUsageDl) > 0 {
		for _, s := range m.PrbUsageDl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.PrbUsageUl) > 0 {
		for _, s := range m.PrbUsageUl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *SchedMeasRepPerServCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.QciVals) > 0 {
		for _, s := range m.QciVals {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if m.PrbUsage != nil {
		l = m.PrbUsage.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.McsDl) > 0 {
		for _, s := range m.McsDl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.NumSchedTtisDl) > 0 {
		for _, s := range m.NumSchedTtisDl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.McsUl) > 0 {
		for _, s := range m.McsUl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.NumSchedTtisUl) > 0 {
		for _, s := range m.NumSchedTtisUl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.RankDl1) > 0 {
		for _, s := range m.RankDl1 {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.RankDl2) > 0 {
		for _, s := range m.RankDl2 {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *SchedMeasReportPerUE) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.SchedReportServCells) > 0 {
		for _, e := range m.SchedReportServCells {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *SchedMeasReportPerCell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.QciVals) > 0 {
		for _, s := range m.QciVals {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if m.PrbUsagePcell != nil {
		l = m.PrbUsagePcell.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.PrbUsageScell != nil {
		l = m.PrbUsageScell.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *PDCPMeasReportPerUe) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.QciVals) > 0 {
		for _, s := range m.QciVals {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.DataVolDl) > 0 {
		l = 0
		for _, e := range m.DataVolDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.DataVolUl) > 0 {
		l = 0
		for _, e := range m.DataVolUl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.PktDelayDl) > 0 {
		l = 0
		for _, e := range m.PktDelayDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.PktDiscardRateDl) > 0 {
		l = 0
		for _, e := range m.PktDiscardRateDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.PktLossRateDl) > 0 {
		l = 0
		for _, e := range m.PktLossRateDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.PktLossRateUl) > 0 {
		l = 0
		for _, e := range m.PktLossRateUl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.ThroughputDl) > 0 {
		l = 0
		for _, e := range m.ThroughputDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.ThroughputUl) > 0 {
		l = 0
		for _, e := range m.ThroughputUl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	return n
}

func (m *RRMConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.Crnti) > 0 {
		for _, s := range m.Crnti {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if m.PciArfcn != nil {
		l = m.PciArfcn.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.PA) > 0 {
		l = 0
		for _, e := range m.PA {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.StartPrbDl) > 0 {
		l = 0
		for _, e := range m.StartPrbDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.EndPrbDl) > 0 {
		l = 0
		for _, e := range m.EndPrbDl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.SubFrameBitmaskDl) > 0 {
		for _, s := range m.SubFrameBitmaskDl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.P0UePusch) > 0 {
		l = 0
		for _, e := range m.P0UePusch {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.StartPrbUl) > 0 {
		l = 0
		for _, e := range m.StartPrbUl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.EndPrbUl) > 0 {
		l = 0
		for _, e := range m.EndPrbUl {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	if len(m.SubFrameBitmaskUl) > 0 {
		for _, s := range m.SubFrameBitmaskUl {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *RRMConfigStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.Crnti) > 0 {
		for _, s := range m.Crnti {
			l = len(s)
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	return n
}

func (m *CACap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Band)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Caclassdl != 0 {
		n += 1 + sovE2Interface(uint64(m.Caclassdl))
	}
	if m.Caclassul != 0 {
		n += 1 + sovE2Interface(uint64(m.Caclassul))
	}
	l = len(m.CrossCarrierSched)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *DCCap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DrbTypeSplit != 0 {
		n += 1 + sovE2Interface(uint64(m.DrbTypeSplit))
	}
	return n
}

func (m *UECapabilityEnquiry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *UECapabilityInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.CaCap != nil {
		l = m.CaCap.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.DcCap != nil {
		l = m.DcCap.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *PropScell) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PciArfcn != nil {
		l = m.PciArfcn.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.CrossCarrierSchedEnable)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.CaDirection != 0 {
		n += 1 + sovE2Interface(uint64(m.CaDirection))
	}
	l = len(m.DeactTimer)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *ScellAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.ScellsProp) > 0 {
		for _, e := range m.ScellsProp {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *ScellAddStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.ScellsInd) > 0 {
		for _, e := range m.ScellsInd {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	if len(m.Status) > 0 {
		l = 0
		for _, e := range m.Status {
			l += sovE2Interface(uint64(e))
		}
		n += 1 + sovE2Interface(uint64(l)) + l
	}
	return n
}

func (m *ScellDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.ScellsInd) > 0 {
		for _, e := range m.ScellsInd {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func (m *SeNBAdd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.MEcgi != nil {
		l = m.MEcgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.SEcgi != nil {
		l = m.SEcgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *SeNBAddStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovE2Interface(uint64(m.Status))
	}
	return n
}

func (m *SeNBDelete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.MEcgi != nil {
		l = m.MEcgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.SEcgi != nil {
		l = m.SEcgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *TrafficSplitPercentage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.TrafficPercentageDl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	l = len(m.TrafficPercentageUl)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	return n
}

func (m *TrafficSplitConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Crnti)
	if l > 0 {
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if m.Ecgi != nil {
		l = m.Ecgi.Size()
		n += 1 + l + sovE2Interface(uint64(l))
	}
	if len(m.TrafficSplitPercentage) > 0 {
		for _, e := range m.TrafficSplitPercentage {
			l = e.Size()
			n += 1 + l + sovE2Interface(uint64(l))
		}
	}
	return n
}

func sovE2Interface(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozE2Interface(x uint64) (n int) {
	return sovE2Interface(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TelemetryMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelemetryMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelemetryMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadioMeasReportPerUE", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RadioMeasReportPerUE{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &TelemetryMessage_RadioMeasReportPerUE{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadioMeasReportPerCell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RadioMeasReportPerCell{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &TelemetryMessage_RadioMeasReportPerCell{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedMeasReportPerCell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchedMeasReportPerCell{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &TelemetryMessage_SchedMeasReportPerCell{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDCPMeasReportPerUe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PDCPMeasReportPerUe{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &TelemetryMessage_PDCPMeasReportPerUe{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellConfigReport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CellConfigReport{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlUpdate_CellConfigReport{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RRMConfigStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RRMConfigStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlUpdate_RRMConfigStatus{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEAdmissionRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEAdmissionRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlUpdate_UEAdmissionRequest{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEAdmissionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEAdmissionStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlUpdate_UEAdmissionStatus{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEContextUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEContextUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlUpdate_UEContextUpdate{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerAdmissionRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BearerAdmissionRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlUpdate_BearerAdmissionRequest{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerAdmissionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BearerAdmissionStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlUpdate_BearerAdmissionStatus{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HOComplete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HOComplete{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlUpdate_HOComplete{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HOFailure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HOFailure{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlUpdate_HOFailure{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HOCause", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HOCause{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlUpdate_HOCause{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEReleaseInd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEReleaseInd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlUpdate_UEReleaseInd{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ControlResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ControlResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ControlResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellConfigRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CellConfigRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlResponse_CellConfigRequest{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RRMConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RRMConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlResponse_RRMConfig{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEAdmissionResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEAdmissionResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlResponse_UEAdmissionResponse{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerAdmissionResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BearerAdmissionResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlResponse_BearerAdmissionResponse{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HORequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HORequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &ControlResponse_HORequest{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessageHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			m.MessageType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MessageType |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MessagePayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessagePayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessagePayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellConfigRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CellConfigRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_CellConfigRequest{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellConfigReport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CellConfigReport{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_CellConfigReport{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEAdmissionRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEAdmissionRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_UEAdmissionRequest{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEAdmissionResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEAdmissionResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_UEAdmissionResponse{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEAdmissionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEAdmissionStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_UEAdmissionStatus{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEContextUpdate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEContextUpdate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_UEContextUpdate{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEReconfigInd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEReconfigInd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_UEReconfigInd{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UEReleaseInd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UEReleaseInd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_UEReleaseInd{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerAdmissionRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BearerAdmissionRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_BearerAdmissionRequest{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerAdmissionResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BearerAdmissionResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_BearerAdmissionResponse{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerAdmissionStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BearerAdmissionStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_BearerAdmissionStatus{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BearerReleaseInd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BearerReleaseInd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_BearerReleaseInd{v}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HORequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HORequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_HORequest{v}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HOFailure", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HOFailure{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_HOFailure{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HOComplete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HOComplete{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_HOComplete{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HOCause", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HOCause{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_HOCause{v}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RRCMeasConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RRCMeasConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_RRCMeasConfig{v}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RxSigMeasReport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RxSigMeasReport{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_RxSigMeasReport{v}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field L2MeasConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &L2MeasConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_L2MeasConfig{v}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadioMeasReportPerU", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RadioMeasReportPerUE{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_RadioMeasReportPerU{v}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadioMeasReportPerCell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RadioMeasReportPerCell{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_RadioMeasReportPerCell{v}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedMeasReportPerUE", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchedMeasReportPerUE{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_SchedMeasReportPerUE{v}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedMeasReportPerCell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SchedMeasReportPerCell{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_SchedMeasReportPerCell{v}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PDCPMeasReportPerUe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PDCPMeasReportPerUe{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_PDCPMeasReportPerUe{v}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RRMConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RRMConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_RRMConfig{v}
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RRMConfigStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RRMConfigStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_RRMConfigStatus{v}
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UECapabilityEnquiry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UECapabilityEnquiry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_UECapabilityEnquiry{v}
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UECapabilityInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &UECapabilityInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_UECapabilityInfo{v}
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScellAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScellAdd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_ScellAdd{v}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScellAddStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScellAddStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_ScellAddStatus{v}
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScellDelete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ScellDelete{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_ScellDelete{v}
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeNBAdd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SeNBAdd{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_SeNBAdd{v}
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeNBAddStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SeNBAddStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_SeNBAddStatus{v}
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeNBDelete", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SeNBDelete{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_SeNBDelete{v}
			iNdEx = postIndex
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficSplitConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &TrafficSplitConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.S = &MessagePayload_TrafficSplitConfig{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &MessageHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &MessagePayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultCode", wireType)
			}
			m.ResultCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResultCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResultMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ECGI) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ECGI: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ECGI: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlmnId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlmnId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ecid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CandScell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CandScell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CandScell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellConfigRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellConfigRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellConfigRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CellConfigReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CellConfigReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CellConfigReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CandScells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CandScells = append(m.CandScells, &CandScell{})
			if err := m.CandScells[len(m.CandScells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RbsPerTtiDl", wireType)
			}
			m.RbsPerTtiDl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RbsPerTtiDl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RbsPerTtiUl", wireType)
			}
			m.RbsPerTtiUl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RbsPerTtiUl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumTxAntenna", wireType)
			}
			m.NumTxAntenna = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumTxAntenna |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DuplexMode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DuplexMode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumConnectedUes", wireType)
			}
			m.MaxNumConnectedUes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumConnectedUes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumConnectedBearers", wireType)
			}
			m.MaxNumConnectedBearers = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumConnectedBearers |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumUesSchedPerTtiDl", wireType)
			}
			m.MaxNumUesSchedPerTtiDl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumUesSchedPerTtiDl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNumUesSchedPerTtiUl", wireType)
			}
			m.MaxNumUesSchedPerTtiUl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNumUesSchedPerTtiUl |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DlfsSchedEnable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DlfsSchedEnable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEAdmissionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEAdmissionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEAdmissionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionEstCause", wireType)
			}
			m.AdmissionEstCause = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdmissionEstCause |= AdmEstCause(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEAdmissionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEAdmissionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEAdmissionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionEstResponse", wireType)
			}
			m.AdmissionEstResponse = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdmissionEstResponse |= SuccessOrFailure(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEAdmissionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEAdmissionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEAdmissionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionEstStatus", wireType)
			}
			m.AdmissionEstStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AdmissionEstStatus |= SuccessOrFailure(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEContextUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEContextUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEContextUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MmeUeS1ApId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MmeUeS1ApId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnbUeS1ApId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnbUeS1ApId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imsi", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imsi = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEReconfigInd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEReconfigInd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEReconfigInd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrntiOld", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrntiOld = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrntiNew", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrntiNew = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReconfigCause", wireType)
			}
			m.ReconfigCause = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReconfigCause |= ReconfigCause(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEReleaseInd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEReleaseInd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEReleaseInd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseCause", wireType)
			}
			m.ReleaseCause = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReleaseCause |= ReleaseCause(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UEAMBR) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UEAMBR: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UEAMBR: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmbrDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmbrDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmbrUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmbrUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ERABParamsItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ERABParamsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ERABParamsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Direction", wireType)
			}
			m.Direction = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Direction |= ERABDirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ERABType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qci", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Qci = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arp", wireType)
			}
			m.Arp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Arp |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GbrDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GbrDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GbrUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GbrUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MbrDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MbrDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MbrUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MbrUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ERABResponseItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ERABResponseItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ERABResponseItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decision", wireType)
			}
			m.Decision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decision |= SuccessOrFailure(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerAdmissionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerAdmissionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerAdmissionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UeAmbr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UeAmbr == nil {
				m.UeAmbr = &UEAMBR{}
			}
			if err := m.UeAmbr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumErabsList", wireType)
			}
			m.NumErabsList = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumErabsList |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErabsParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErabsParams = append(m.ErabsParams, &ERABParamsItem{})
			if err := m.ErabsParams[len(m.ErabsParams)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerAdmissionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerAdmissionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerAdmissionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumErabsList", wireType)
			}
			m.NumErabsList = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumErabsList |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErabResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErabResponse = append(m.ErabResponse, &ERABResponseItem{})
			if err := m.ErabResponse[len(m.ErabResponse)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerAdmissionStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerAdmissionStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerAdmissionStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumErabsList", wireType)
			}
			m.NumErabsList = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumErabsList |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErabStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErabStatus = append(m.ErabStatus, &ERABResponseItem{})
			if err := m.ErabStatus[len(m.ErabStatus)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BearerReleaseInd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BearerReleaseInd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BearerReleaseInd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumErabsList", wireType)
			}
			m.NumErabsList = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumErabsList |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErabIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErabIds = append(m.ErabIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HORequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HORequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HORequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiS == nil {
				m.EcgiS = &ECGI{}
			}
			if err := m.EcgiS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiT == nil {
				m.EcgiT = &ECGI{}
			}
			if err := m.EcgiT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HOFailure) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HOFailure: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HOFailure: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiS == nil {
				m.EcgiS = &ECGI{}
			}
			if err := m.EcgiS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoFailureCause", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HoFailureCause = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HOComplete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HOComplete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HOComplete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrntiNew", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrntiNew = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiS == nil {
				m.EcgiS = &ECGI{}
			}
			if err := m.EcgiS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiT == nil {
				m.EcgiT = &ECGI{}
			}
			if err := m.EcgiT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HOCause) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HOCause: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HOCause: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiS == nil {
				m.EcgiS = &ECGI{}
			}
			if err := m.EcgiS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EcgiT", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EcgiT == nil {
				m.EcgiT = &ECGI{}
			}
			if err := m.EcgiT.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoCause", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HoCause = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoTrigger", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HoTrigger = append(m.HoTrigger, &RXSigReport{})
			if err := m.HoTrigger[len(m.HoTrigger)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellIndividualOffset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CellIndividualOffset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasObject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasObject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasObject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DlFreq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DlFreq = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasCells = append(m.MeasCells, &MeasCell{})
			if err := m.MeasCells[len(m.MeasCells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportParamChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportParamChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportParamChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerParam", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PerParam{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_PerParam{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A1Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A1Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A1Param{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A2Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A2Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A2Param{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A3Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A3Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A3Param{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A4Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A4Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A4Param{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A5Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A5Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A5Param{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A6Param", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &A6Param{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &ReportParamChoice_A6Param{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThresholdEUTRAChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThresholdEUTRAChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThresholdEUTRAChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdRSRP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &ThresholdEUTRAChoice_ThresholdRSRP{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThresholdRSRQ", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &ThresholdEUTRAChoice_ThresholdRSRQ{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ThreasholdEUTRA) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ThreasholdEUTRA: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ThreasholdEUTRA: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Present", wireType)
			}
			m.Present = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Present |= ThresholdEUTRAPR(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Choice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Choice == nil {
				m.Choice = &ThresholdEUTRAChoice{}
			}
			if err := m.Choice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PerParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PerParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PerParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportIntervalMs", wireType)
			}
			m.ReportIntervalMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportIntervalMs |= PerParamReportIntervalMs(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A1Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A1Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A1Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A1Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A1Threshold == nil {
				m.A1Threshold = &ThreasholdEUTRA{}
			}
			if err := m.A1Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A2Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A2Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A2Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A2Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A2Threshold == nil {
				m.A2Threshold = &ThreasholdEUTRA{}
			}
			if err := m.A2Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A3Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A3Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A3Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A3Offset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A3Offset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A4Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A4Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A4Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A4Threshold", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A4Threshold == nil {
				m.A4Threshold = &ThreasholdEUTRA{}
			}
			if err := m.A4Threshold.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A5Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A5Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A5Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A5Threshold1", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A5Threshold1 == nil {
				m.A5Threshold1 = &ThreasholdEUTRA{}
			}
			if err := m.A5Threshold1.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A5Threshold2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.A5Threshold2 == nil {
				m.A5Threshold2 = &ThreasholdEUTRA{}
			}
			if err := m.A5Threshold2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *A6Param) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: A6Param: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: A6Param: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field A6Offset", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.A6Offset = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportParam) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportParam: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportParam: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Present", wireType)
			}
			m.Present = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Present |= ReportParamPR(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Choice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Choice == nil {
				m.Choice = &ReportParamChoice{}
			}
			if err := m.Choice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hysteresis", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hysteresis = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timetotrigger", wireType)
			}
			m.Timetotrigger = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timetotrigger |= TimeToTrigger(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportParams", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportParams == nil {
				m.ReportParams = &ReportParam{}
			}
			if err := m.ReportParams.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TriggerQuantity", wireType)
			}
			m.TriggerQuantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TriggerQuantity |= TriggerQuantity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportQuality", wireType)
			}
			m.ReportQuality = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportQuality |= ReportQuality(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddMeasId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddMeasId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddMeasId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddMeasId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddMeasId = append(m.AddMeasId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelMeasId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelMeasId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelMeasId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelMeasId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelMeasId = append(m.DelMeasId, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasIdActionChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasIdActionChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasIdActionChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddMeasId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AddMeasId{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &MeasIdActionChoice_AddMeasId{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelMeasId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &DelMeasId{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Choice = &MeasIdActionChoice_DelMeasId{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hototarget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Choice = &MeasIdActionChoice_Hototarget{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasIdAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasIdAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasIdAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Present", wireType)
			}
			m.Present = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Present |= MeasIdActionPR(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Choice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Choice == nil {
				m.Choice = &MeasIdActionChoice{}
			}
			if err := m.Choice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasObjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasObjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportConfigId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportConfigId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &MeasIdAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RRCMeasConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RRCMeasConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RRCMeasConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = append(m.Crnti, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasObjects", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasObjects = append(m.MeasObjects, &MeasObject{})
			if err := m.MeasObjects[len(m.MeasObjects)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportConfigs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportConfigs = append(m.ReportConfigs, &ReportConfig{})
			if err := m.ReportConfigs[len(m.ReportConfigs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasIds = append(m.MeasIds, &MeasID{})
			if err := m.MeasIds[len(m.MeasIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PCIARFCN) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PCIARFCN: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PCIARFCN: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pci", wireType)
			}
			m.Pci = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pci |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EarfcnDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EarfcnDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RXSigReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RXSigReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RXSigReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PciArfcn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PciArfcn == nil {
				m.PciArfcn = &PCIARFCN{}
			}
			if err := m.PciArfcn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rsrp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rsrq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rsrq = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RxSigMeasReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RxSigMeasReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RxSigMeasReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = append(m.Crnti, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CellMeasReport", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CellMeasReport = append(m.CellMeasReport, &RXSigReport{})
			if err := m.CellMeasReport[len(m.CellMeasReport)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2ReportInterval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2ReportInterval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2ReportInterval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TRadioMeasReportPerUe", wireType)
			}
			m.TRadioMeasReportPerUe = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TRadioMeasReportPerUe |= L2MeasReportIntervals(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TRadioMeasReportPerCell", wireType)
			}
			m.TRadioMeasReportPerCell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TRadioMeasReportPerCell |= L2MeasReportIntervals(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TSchedMeasReportPerUe", wireType)
			}
			m.TSchedMeasReportPerUe = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TSchedMeasReportPerUe |= L2MeasReportIntervals(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TSchedMeasReportPerCell", wireType)
			}
			m.TSchedMeasReportPerCell = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TSchedMeasReportPerCell |= L2MeasReportIntervals(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TPdcpMeasReportPerUe", wireType)
			}
			m.TPdcpMeasReportPerUe = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TPdcpMeasReportPerUe |= L2MeasReportIntervals(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *L2MeasConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: L2MeasConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: L2MeasConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = append(m.Crnti, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportIntervals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReportIntervals == nil {
				m.ReportIntervals = &L2ReportInterval{}
			}
			if err := m.ReportIntervals.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadioRepPerServCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadioRepPerServCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadioRepPerServCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.CqiHist = append(m.CqiHist, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.CqiHist) == 0 {
					m.CqiHist = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.CqiHist = append(m.CqiHist, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field CqiHist", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiHist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RiHist = append(m.RiHist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PuschSinrHist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PuschSinrHist = append(m.PuschSinrHist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PucchSinrHist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PucchSinrHist = append(m.PucchSinrHist, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadioMeasReportPerUE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadioMeasReportPerUE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadioMeasReportPerUE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RadioReportServCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RadioReportServCells = append(m.RadioReportServCells, &RadioRepPerServCell{})
			if err := m.RadioReportServCells[len(m.RadioReportServCells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RadioMeasReportPerCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RadioMeasReportPerCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RadioMeasReportPerCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PuschIntfPwrHist = append(m.PuschIntfPwrHist, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PuschIntfPwrHist) == 0 {
					m.PuschIntfPwrHist = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PuschIntfPwrHist = append(m.PuschIntfPwrHist, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PuschIntfPwrHist", wireType)
			}
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PucchIntfPowerHist = append(m.PucchIntfPowerHist, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PucchIntfPowerHist) == 0 {
					m.PucchIntfPowerHist = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PucchIntfPowerHist = append(m.PucchIntfPowerHist, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PucchIntfPowerHist", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PRBUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PRBUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PRBUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrbUsageDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrbUsageDl = append(m.PrbUsageDl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrbUsageUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrbUsageUl = append(m.PrbUsageUl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedMeasRepPerServCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedMeasRepPerServCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedMeasRepPerServCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QciVals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QciVals = append(m.QciVals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrbUsage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrbUsage == nil {
				m.PrbUsage = &PRBUsage{}
			}
			if err := m.PrbUsage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McsDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McsDl = append(m.McsDl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSchedTtisDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumSchedTtisDl = append(m.NumSchedTtisDl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field McsUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.McsUl = append(m.McsUl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumSchedTtisUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NumSchedTtisUl = append(m.NumSchedTtisUl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankDl1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankDl1 = append(m.RankDl1, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RankDl2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RankDl2 = append(m.RankDl2, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedMeasReportPerUE) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedMeasReportPerUE: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedMeasReportPerUE: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedReportServCells", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchedReportServCells = append(m.SchedReportServCells, &SchedMeasRepPerServCell{})
			if err := m.SchedReportServCells[len(m.SchedReportServCells)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedMeasReportPerCell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedMeasReportPerCell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedMeasReportPerCell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QciVals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QciVals = append(m.QciVals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrbUsagePcell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrbUsagePcell == nil {
				m.PrbUsagePcell = &PRBUsage{}
			}
			if err := m.PrbUsagePcell.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrbUsageScell", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PrbUsageScell == nil {
				m.PrbUsageScell = &PRBUsage{}
			}
			if err := m.PrbUsageScell.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PDCPMeasReportPerUe) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PDCPMeasReportPerUe: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PDCPMeasReportPerUe: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QciVals", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QciVals = append(m.QciVals, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DataVolDl = append(m.DataVolDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DataVolDl) == 0 {
					m.DataVolDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DataVolDl = append(m.DataVolDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DataVolDl", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.DataVolUl = append(m.DataVolUl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.DataVolUl) == 0 {
					m.DataVolUl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.DataVolUl = append(m.DataVolUl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field DataVolUl", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PktDelayDl = append(m.PktDelayDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PktDelayDl) == 0 {
					m.PktDelayDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PktDelayDl = append(m.PktDelayDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PktDelayDl", wireType)
			}
		case 7:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PktDiscardRateDl = append(m.PktDiscardRateDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PktDiscardRateDl) == 0 {
					m.PktDiscardRateDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PktDiscardRateDl = append(m.PktDiscardRateDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PktDiscardRateDl", wireType)
			}
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PktLossRateDl = append(m.PktLossRateDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PktLossRateDl) == 0 {
					m.PktLossRateDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PktLossRateDl = append(m.PktLossRateDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PktLossRateDl", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PktLossRateUl = append(m.PktLossRateUl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.PktLossRateUl) == 0 {
					m.PktLossRateUl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PktLossRateUl = append(m.PktLossRateUl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PktLossRateUl", wireType)
			}
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ThroughputDl = append(m.ThroughputDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ThroughputDl) == 0 {
					m.ThroughputDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ThroughputDl = append(m.ThroughputDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ThroughputDl", wireType)
			}
		case 11:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ThroughputUl = append(m.ThroughputUl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ThroughputUl) == 0 {
					m.ThroughputUl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ThroughputUl = append(m.ThroughputUl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ThroughputUl", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RRMConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RRMConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RRMConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = append(m.Crnti, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PciArfcn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PciArfcn == nil {
				m.PciArfcn = &PCIARFCN{}
			}
			if err := m.PciArfcn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v XICICPA
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= XICICPA(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.PA = append(m.PA, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.PA) == 0 {
					m.PA = make([]XICICPA, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v XICICPA
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= XICICPA(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.PA = append(m.PA, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field PA", wireType)
			}
		case 5:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StartPrbDl = append(m.StartPrbDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StartPrbDl) == 0 {
					m.StartPrbDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StartPrbDl = append(m.StartPrbDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPrbDl", wireType)
			}
		case 6:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EndPrbDl = append(m.EndPrbDl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EndPrbDl) == 0 {
					m.EndPrbDl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EndPrbDl = append(m.EndPrbDl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPrbDl", wireType)
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubFrameBitmaskDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubFrameBitmaskDl = append(m.SubFrameBitmaskDl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.P0UePusch = append(m.P0UePusch, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.P0UePusch) == 0 {
					m.P0UePusch = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.P0UePusch = append(m.P0UePusch, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field P0UePusch", wireType)
			}
		case 9:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.StartPrbUl = append(m.StartPrbUl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.StartPrbUl) == 0 {
					m.StartPrbUl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.StartPrbUl = append(m.StartPrbUl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field StartPrbUl", wireType)
			}
		case 10:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.EndPrbUl = append(m.EndPrbUl, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.EndPrbUl) == 0 {
					m.EndPrbUl = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.EndPrbUl = append(m.EndPrbUl, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field EndPrbUl", wireType)
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubFrameBitmaskUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubFrameBitmaskUl = append(m.SubFrameBitmaskUl, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RRMConfigStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RRMConfigStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RRMConfigStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = append(m.Crnti, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v SuccessOrFailure
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= SuccessOrFailure(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]SuccessOrFailure, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v SuccessOrFailure
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= SuccessOrFailure(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CACap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CACap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CACap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Band", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Band = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caclassdl", wireType)
			}
			m.Caclassdl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Caclassdl |= CACapClassDl(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caclassul", wireType)
			}
			m.Caclassul = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Caclassul |= CACapClassUl(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossCarrierSched", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossCarrierSched = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DCCap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DCCap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DCCap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DrbTypeSplit", wireType)
			}
			m.DrbTypeSplit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DrbTypeSplit |= DCCapDrbType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UECapabilityEnquiry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UECapabilityEnquiry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UECapabilityEnquiry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UECapabilityInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UECapabilityInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UECapabilityInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CaCap == nil {
				m.CaCap = &CACap{}
			}
			if err := m.CaCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcCap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DcCap == nil {
				m.DcCap = &DCCap{}
			}
			if err := m.DcCap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PropScell) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PropScell: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PropScell: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PciArfcn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PciArfcn == nil {
				m.PciArfcn = &PCIARFCN{}
			}
			if err := m.PciArfcn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossCarrierSchedEnable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CrossCarrierSchedEnable = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaDirection", wireType)
			}
			m.CaDirection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaDirection |= CADirection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeactTimer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeactTimer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScellAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScellAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScellAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScellsProp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScellsProp = append(m.ScellsProp, &PropScell{})
			if err := m.ScellsProp[len(m.ScellsProp)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScellAddStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScellAddStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScellAddStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScellsInd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScellsInd = append(m.ScellsInd, &PCIARFCN{})
			if err := m.ScellsInd[len(m.ScellsInd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v SuccessOrFailure
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= SuccessOrFailure(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Status = append(m.Status, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowE2Interface
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthE2Interface
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthE2Interface
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Status) == 0 {
					m.Status = make([]SuccessOrFailure, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v SuccessOrFailure
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowE2Interface
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= SuccessOrFailure(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Status = append(m.Status, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScellDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScellDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScellDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScellsInd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScellsInd = append(m.ScellsInd, &PCIARFCN{})
			if err := m.ScellsInd[len(m.ScellsInd)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeNBAdd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeNBAdd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeNBAdd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MEcgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MEcgi == nil {
				m.MEcgi = &ECGI{}
			}
			if err := m.MEcgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SEcgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SEcgi == nil {
				m.SEcgi = &ECGI{}
			}
			if err := m.SEcgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeNBAddStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeNBAddStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeNBAddStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= SuccessOrFailure(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeNBDelete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeNBDelete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeNBDelete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MEcgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MEcgi == nil {
				m.MEcgi = &ECGI{}
			}
			if err := m.MEcgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SEcgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SEcgi == nil {
				m.SEcgi = &ECGI{}
			}
			if err := m.SEcgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficSplitPercentage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficSplitPercentage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficSplitPercentage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPercentageDl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrafficPercentageDl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficPercentageUl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrafficPercentageUl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrafficSplitConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrafficSplitConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrafficSplitConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Crnti", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Crnti = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ecgi", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ecgi == nil {
				m.Ecgi = &ECGI{}
			}
			if err := m.Ecgi.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrafficSplitPercentage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthE2Interface
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthE2Interface
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrafficSplitPercentage = append(m.TrafficSplitPercentage, &TrafficSplitPercentage{})
			if err := m.TrafficSplitPercentage[len(m.TrafficSplitPercentage)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipE2Interface(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthE2Interface
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipE2Interface(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowE2Interface
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowE2Interface
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthE2Interface
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupE2Interface
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthE2Interface
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthE2Interface        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowE2Interface          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupE2Interface = fmt.Errorf("proto: unexpected end of group")
)
